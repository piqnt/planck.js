{"version":3,"file":"planck-with-testbed.min.js","sources":["../src/util/options.ts","../src/util/common.ts","../src/common/Math.ts","../src/common/Vec2.ts","../src/collision/AABB.ts","../src/Settings.ts","../src/util/Pool.ts","../src/collision/DynamicTree.ts","../src/collision/BroadPhase.ts","../src/common/Rot.ts","../src/common/Transform.ts","../src/common/Sweep.ts","../src/dynamics/Velocity.ts","../src/dynamics/Position.ts","../src/collision/Shape.ts","../src/dynamics/Fixture.ts","../src/dynamics/Body.ts","../src/dynamics/Joint.ts","../src/util/stats.ts","../src/util/Timer.ts","../src/collision/Distance.ts","../src/collision/TimeOfImpact.ts","../src/collision/Manifold.ts","../src/dynamics/Solver.ts","../src/common/Mat22.ts","../src/dynamics/Contact.ts","../src/dynamics/World.ts","../src/common/Vec3.ts","../src/collision/shape/EdgeShape.ts","../src/collision/shape/ChainShape.ts","../src/collision/shape/PolygonShape.ts","../src/collision/shape/BoxShape.ts","../src/collision/shape/CircleShape.ts","../src/dynamics/joint/DistanceJoint.ts","../src/dynamics/joint/FrictionJoint.ts","../src/common/Mat33.ts","../src/dynamics/joint/RevoluteJoint.ts","../src/dynamics/joint/PrismaticJoint.ts","../src/dynamics/joint/GearJoint.ts","../src/dynamics/joint/MotorJoint.ts","../src/dynamics/joint/MouseJoint.ts","../src/dynamics/joint/PulleyJoint.ts","../src/dynamics/joint/RopeJoint.ts","../src/dynamics/joint/WeldJoint.ts","../src/dynamics/joint/WheelJoint.ts","../src/serializer/index.ts","../src/collision/shape/CollideCircle.ts","../src/collision/shape/CollideEdgeCircle.ts","../src/collision/shape/CollidePolygon.ts","../src/collision/shape/CollideEdgePolygon.ts","../src/collision/shape/CollideCirclePolygon.ts","../src/index.ts","../testbed/index.ts"],"sourcesContent":["export const options = function<T>(input: T, defaults: object): T {\n  if (input === null || typeof input === 'undefined') {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    input = {} as T;\n  }\n\n  const output = {...input};\n\n  // tslint:disable-next-line:no-for-in\n  for (const key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n      output[key] = defaults[key];\n    }\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    const symbols = Object.getOwnPropertySymbols(defaults);\n    for (let i = 0; i < symbols.length; i++) {\n      const symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n        output[symbol] = defaults[symbol];\n      }\n    }\n  }\n\n  return output;\n}\n","const _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport const debug = function(...rest: any[]): void {\n  if (!_DEBUG) return;\n  console.log.apply(console, arguments);\n};\n\nexport const assert = function(statement: boolean, err?: string, log?: any): void {\n  if (!_ASSERT) return;\n  if (statement) return;\n  log && console.log(log);\n  throw new Error(err);\n};\n\nexport default {\n  assert,\n  debug,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nconst native = Object.create(Math) as typeof Math;\n\nconst extended = Object.assign(native, {\n  EPSILON: 1e-9, // TODO\n\n  /**\n   * This function is used to ensure that a floating point number is not a NaN or\n   * infinity.\n   */\n  isFinite: function(x: unknown): boolean {\n    return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n  },\n\n  assert: function(x: any): void {\n    if (!_ASSERT) return;\n    if (!extended.isFinite(x)) {\n      _DEBUG && common.debug(x);\n      throw new Error('Invalid Number!');\n    }\n  },\n\n  /**\n  * This is a approximate yet fast inverse square-root (todo).\n  */\n\n  invSqrt: function(x: number): number {\n    // TODO:\n    return 1 / native.sqrt(x);\n  },\n\n  /**\n   * Next Largest Power of 2 Given a binary integer value x, the next largest\n   * power of 2 can be computed by a SWAR algorithm that recursively \"folds\" the\n   * upper bits into the lower bits. This process yields a bit vector with the\n   * same most significant 1 as x, but all 1's below it. Adding 1 to that value\n   * yields the next largest power of 2. For a 32-bit value:\n   */\n  nextPowerOfTwo: function(x: number): number {\n    // TODO\n    x |= (x >> 1);\n    x |= (x >> 2);\n    x |= (x >> 4);\n    x |= (x >> 8);\n    x |= (x >> 16);\n    return x + 1;\n  },\n\n  isPowerOfTwo: function(x: number): boolean {\n    return x > 0 && (x & (x - 1)) === 0;\n  },\n\n  mod: function(num: number, min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    if (max > min) {\n      num = (num - min) % (max - min);\n      return num + (num < 0 ? max : min);\n    } else {\n      num = (num - max) % (min - max);\n      return num + (num <= 0 ? min : max);\n    }\n  },\n  /**\n   * Returns a min if num is less than min, and max if more than max, otherwise returns num.\n   */\n  clamp: function(num: number, min: number, max: number): number {\n    if (num < min) {\n      return min;\n    } else if (num > max) {\n      return max;\n    } else {\n      return num;\n    }\n  },\n  /**\n   * Returns a random number between min and max when two arguments are provided.\n   * If one arg is provided between 0 to max.\n   * If one arg is passed between 0 to 1.\n   */\n  random: function(min?: number, max?: number): number {\n    if (typeof min === 'undefined') {\n      max = 1;\n      min = 0;\n    } else if (typeof max === 'undefined') {\n      max = min;\n      min = 0;\n    }\n    return min === max ? min : native.random() * (max - min) + min;\n  }\n});\n\nexport { extended as Math };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Math } from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(obj: { x: number, y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?) {\n    if (!(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    _ASSERT && Vec2.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    return obj;\n  }\n\n  static zero(): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = x;\n    obj.y = y;\n    return obj;\n  }\n\n  static clone(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(v.x, v.y);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Vec2.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Vec2!');\n    }\n  }\n\n  clone(): Vec2 {\n    return Vec2.clone(this);\n  }\n\n  /**\n   * Set this vector to all zeros.\n   *\n   * @returns this\n   */\n  setZero(): Vec2 {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number): Vec2;\n  set(value: Vec2): Vec2;\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  // tslint:disable-next-line:typedef\n  set(x, y?) {\n    if (typeof x === 'object') {\n      _ASSERT && Vec2.assert(x);\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      _ASSERT && Math.assert(x);\n      _ASSERT && Math.assert(y);\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n   setNum(x: number, y: number) {\n    _ASSERT && Math.assert(x);\n    _ASSERT && Math.assert(y);\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  setVec2(value: Vec2) {\n    _ASSERT && Vec2.assert(value);\n    this.x = value.x;\n    this.y = value.y;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use setCombine or setMul\n   */\n  wSet(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.setCombine(a, v, b, w);\n    } else {\n      return this.setMul(a, v);\n    }\n  }\n\n  /**\n   * Set linear combination of v and w: `a * v + b * w`\n   */\n  setCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add a vector to this vector.\n   *\n   * @returns this\n   */\n  add(w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x += w.x;\n    this.y += w.y;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use addCombine or addMul\n   */\n  wAdd(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.addCombine(a, v, b, w);\n    } else {\n      return this.addMul(a, v);\n    }\n  }\n\n  /**\n   * Add linear combination of v and w: `a * v + b * w`\n   */\n  addCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  addMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @deprecated Use subCombine or subMul\n   */\n  wSub(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.subCombine(a, v, b, w);\n    } else {\n      return this.subMul(a, v);\n    }}\n\n  /**\n   * Subtract linear combination of v and w: `a * v + b * w`\n   */\n  subCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  subMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  /**\n   * Subtract a vector from this vector\n   *\n   * @returns this\n   */\n  sub(w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x -= w.x;\n    this.y -= w.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * @returns this\n   */\n  mul(m: number): Vec2 {\n    _ASSERT && Math.assert(m);\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  length(): number {\n    return Vec2.lengthOf(this);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  lengthSquared(): number {\n    return Vec2.lengthSquared(this);\n  }\n\n  /**\n   * Convert this vector into a unit vector.\n   *\n   * @returns old length\n   */\n  normalize(): number {\n    const length = this.length();\n    if (length < Math.EPSILON) {\n      return 0.0;\n    }\n    const invLength = 1.0 / length;\n    this.x *= invLength;\n    this.y *= invLength;\n    return length;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  static lengthOf(v: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  static lengthSquared(v: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    return v.x * v.x + v.y * v.y;\n  }\n\n  static distance(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distanceSquared(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return dx * dx + dy * dy;\n  }\n\n  static areEqual(v: Vec2, w: Vec2): boolean {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n  }\n\n  /**\n   * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n   */\n  static skew(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.y, v.x);\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.x + v.y * w.y;\n  }\n\n  static cross(v: Vec2, w: Vec2): number;\n  static cross(v: Vec2, w: number): Vec2;\n  static cross(v: number, w: Vec2): Vec2;\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   *\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  // tslint:disable-next-line:typedef\n  static cross(v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y, -w * v.x);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y, v * w.x);\n\n    } else {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return v.x * w.y - v.y * w.x;\n    }\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static crossVec2Vec2(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.y - v.y * w.x;\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossVec2Num(v: Vec2, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y, -w * v.x);\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossNumVec2(v: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y, v * w.x);\n  }\n\n  static addCross(a: Vec2, v: Vec2, w: number): Vec2;\n  static addCross(a: Vec2, v: number, w: Vec2): Vec2;\n  /**\n   * Returns `a + (v x w)`\n   */\n  // tslint:disable-next-line:typedef\n  static addCross(a, v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossVec2Num(a: Vec2, v: Vec2, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossNumVec2(a: Vec2, v: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n  }\n\n  static add(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x + w.x, v.y + w.y);\n  }\n\n  /** @internal @deprecated */\n  static wAdd(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return Vec2.combine(a, v, b, w);\n    } else {\n      return Vec2.mulNumVec2(a, v);\n    }\n  }\n\n  static combine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    return Vec2.zero().setCombine(a, v, b, w);\n  }\n\n  static sub(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x - w.x, v.y - w.y);\n  }\n\n  static mul(a: Vec2, b: number): Vec2;\n  static mul(a: number, b: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (typeof a === 'object') {\n      _ASSERT && Vec2.assert(a);\n      _ASSERT && Math.assert(b);\n      return Vec2.neo(a.x * b, a.y * b);\n\n    } else if (typeof b === 'object') {\n      _ASSERT && Math.assert(a);\n      _ASSERT && Vec2.assert(b);\n      return Vec2.neo(a * b.x, a * b.y);\n    }\n  }\n\n  static mulVec2Num(a: Vec2, b: number): Vec2 {\n    _ASSERT && Vec2.assert(a);\n    _ASSERT && Math.assert(b);\n    return Vec2.neo(a.x * b, a.y * b);\n  }\n\n  static mulNumVec2(a: number, b: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(b);\n    return Vec2.neo(a * b.x, a * b.y);\n  }\n\n  neg(): Vec2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  static neg(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.x, -v.y);\n  }\n\n  static abs(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Math.abs(v.x), Math.abs(v.y));\n  }\n\n  static mid(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n  }\n\n  static upper(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));\n  }\n\n  static lower(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));\n  }\n\n  clamp(max: number): Vec2 {\n    const lengthSqr = this.x * this.x + this.y * this.y;\n    if (lengthSqr > max * max) {\n      const invLength = Math.invSqrt(lengthSqr);\n      this.x *= invLength * max;\n      this.y *= invLength * max;\n    }\n    return this;\n  }\n\n  static clamp(v: Vec2, max: number): Vec2 {\n    v = Vec2.neo(v.x, v.y);\n    v.clamp(max);\n    return v;\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static scaleFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x * x, v.y * y);\n    };\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static translateFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x + x, v.y + y);\n    };\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Math } from '../common/Math';\nimport { Vec2 } from '../common/Vec2';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n */\nexport interface RayCastInput {\n  p1: Vec2;\n  p2: Vec2;\n  maxFraction: number;\n}\n\nexport type RayCastCallback = (subInput: RayCastInput, id: number) => number;\n\n/**\n * Ray-cast output data. The ray hits at `p1 + fraction * (p2 - p1)`,\n * where `p1` and `p2` come from RayCastInput.\n */\nexport interface RayCastOutput {\n  normal: Vec2;\n  fraction: number;\n}\n\nexport class AABB {\n  lowerBound: Vec2;\n  upperBound: Vec2;\n\n  constructor(lower?: Vec2, upper?: Vec2) {\n    if (!(this instanceof AABB)) {\n      return new AABB(lower, upper);\n    }\n\n    this.lowerBound = Vec2.zero();\n    this.upperBound = Vec2.zero();\n\n    if (typeof lower === 'object') {\n      this.lowerBound.setVec2(lower);\n    }\n    if (typeof upper === 'object') {\n      this.upperBound.setVec2(upper);\n    } else if (typeof lower === 'object') {\n      this.upperBound.setVec2(lower);\n    }\n  }\n\n  /**\n   * Verify that the bounds are sorted.\n   */\n  isValid(): boolean {\n    return AABB.isValid(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!AABB.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid AABB!');\n    }\n  }\n\n  /**\n   * Get the center of the AABB.\n   */\n  getCenter(): Vec2 {\n    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n  }\n\n  /**\n   * Get the extents of the AABB (half-widths).\n   */\n  getExtents(): Vec2 {\n    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n  }\n\n  /**\n   * Get the perimeter length.\n   */\n  getPerimeter(): number {\n    return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n  }\n\n  /**\n   * Combine one or two AABB into this one.\n   */\n  combine(a: AABB, b?: AABB): void {\n    b = b || this;\n\n    const lowerA = a.lowerBound;\n    const upperA = a.upperBound;\n    const lowerB = b.lowerBound;\n    const upperB = b.upperBound;\n\n    const lowerX = Math.min(lowerA.x, lowerB.x);\n    const lowerY = Math.min(lowerA.y, lowerB.y);\n    const upperX = Math.max(upperB.x, upperA.x);\n    const upperY = Math.max(upperB.y, upperA.y);\n\n    this.lowerBound.setNum(lowerX, lowerY);\n    this.upperBound.setNum(upperX, upperY);\n  }\n\n  combinePoints(a: Vec2, b: Vec2): void {\n    this.lowerBound.setNum(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    this.upperBound.setNum(Math.max(a.x, b.x), Math.max(a.y, b.y));\n  }\n\n  set(aabb: AABB): void {\n    this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n    this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n  }\n\n  contains(aabb: AABB): boolean {\n    let result = true;\n    result = result && this.lowerBound.x <= aabb.lowerBound.x;\n    result = result && this.lowerBound.y <= aabb.lowerBound.y;\n    result = result && aabb.upperBound.x <= this.upperBound.x;\n    result = result && aabb.upperBound.y <= this.upperBound.y;\n    return result;\n  }\n\n  extend(value: number): AABB {\n    AABB.extend(this, value);\n    return this;\n  }\n\n  static extend(aabb: AABB, value: number): void {\n    aabb.lowerBound.x -= value;\n    aabb.lowerBound.y -= value;\n    aabb.upperBound.x += value;\n    aabb.upperBound.y += value;\n  }\n\n  static testOverlap(a: AABB, b: AABB): boolean {\n    const d1x = b.lowerBound.x - a.upperBound.x;\n    const d2x = a.lowerBound.x - b.upperBound.x;\n\n    const d1y = b.lowerBound.y - a.upperBound.y;\n    const d2y = a.lowerBound.y - b.upperBound.y;\n\n    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  static areEqual(a: AABB, b: AABB): boolean {\n    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n  }\n\n  static diff(a: AABB, b: AABB): number {\n    const wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x));\n    const hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));\n\n    const wA = a.upperBound.x - a.lowerBound.x;\n    const hA = a.upperBound.y - a.lowerBound.y;\n\n    const wB = b.upperBound.x - b.lowerBound.x;\n    const hB = b.upperBound.y - b.lowerBound.y;\n\n    return wA * hA + wB * hB - wD * hD;\n  }\n\n  rayCast(output: RayCastOutput, input: RayCastInput): boolean {\n    // From Real-time Collision Detection, p179.\n\n    let tmin = -Infinity;\n    let tmax = Infinity;\n\n    const p = input.p1;\n    const d = Vec2.sub(input.p2, input.p1);\n    const absD = Vec2.abs(d);\n\n    const normal = Vec2.zero();\n\n    for (let f: 'x' | 'y' = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n      if (absD.x < Math.EPSILON) {\n        // Parallel.\n        if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n          return false;\n        }\n      } else {\n        const inv_d = 1.0 / d[f];\n        let t1 = (this.lowerBound[f] - p[f]) * inv_d;\n        let t2 = (this.upperBound[f] - p[f]) * inv_d;\n\n        // Sign of the normal vector.\n        let s = -1.0;\n\n        if (t1 > t2) {\n          const temp = t1;\n          t1 = t2;\n          t2 = temp;\n          s = 1.0;\n        }\n\n        // Push the min up\n        if (t1 > tmin) {\n          normal.setZero();\n          normal[f] = s;\n          tmin = t1;\n        }\n\n        // Pull the max down\n        tmax = Math.min(tmax, t2);\n\n        if (tmin > tmax) {\n          return false;\n        }\n      }\n    }\n\n    // Does the ray start inside the box?\n    // Does the ray intersect beyond the max fraction?\n    if (tmin < 0.0 || input.maxFraction < tmin) {\n      return false;\n    }\n\n    // Intersection.\n    output.fraction = tmin;\n    output.normal = normal;\n    return true;\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// TODO merge with World options?\n\n/**\n * Tuning constants based on meters-kilograms-seconds (MKS) units.\n */\n// tslint:disable-next-line:no-unnecessary-class\nexport class Settings {\n  // Collision\n  /**\n   * The maximum number of contact points between two convex shapes. Do not change\n   * this value.\n   */\n  static maxManifoldPoints: number = 2;\n\n  /**\n   * The maximum number of vertices on a convex polygon. You cannot increase this\n   * too much because BlockAllocator has a maximum object size.\n   */\n  static maxPolygonVertices: number = 12;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n   * by a small amount without triggering a tree adjustment. This is in meters.\n   */\n  static aabbExtension: number = 0.1;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n   * future position based on the current displacement. This is a dimensionless\n   * multiplier.\n   */\n  static aabbMultiplier: number = 2.0;\n\n  /**\n   * A small length used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static linearSlop: number = 0.005;\n  static get linearSlopSquared(): number { return Settings.linearSlop * Settings.linearSlop; }\n\n  /**\n   * A small angle used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static angularSlop: number = (2.0 / 180.0 * Math.PI);\n\n  /**\n   * The radius of the polygon/edge shape skin. This should not be modified.\n   * Making this smaller means polygons will have an insufficient buffer for\n   * continuous collision. Making it larger may create artifacts for vertex\n   * collision.\n   */\n  static get polygonRadius(): number { return 2.0 * Settings.linearSlop; }\n\n  /**\n   * Maximum number of sub-steps per contact in continuous physics simulation.\n   */\n  static maxSubSteps: number = 8;\n\n// Dynamics\n\n  /**\n   * Maximum number of contacts to be handled to solve a TOI impact.\n   */\n  static maxTOIContacts: number = 32;\n\n  /**\n   * Maximum iterations to solve a TOI.\n   */\n  static maxTOIIterations: number = 20;\n\n  /**\n   * Maximum iterations to find Distance.\n   */\n  static maxDistnceIterations: number = 20;\n\n  /**\n   * A velocity threshold for elastic collisions. Any collision with a relative\n   * linear velocity below this threshold will be treated as inelastic.\n   */\n  static velocityThreshold: number = 1.0;\n\n  /**\n   * The maximum linear position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxLinearCorrection: number = 0.2;\n\n  /**\n   * The maximum angular position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxAngularCorrection: number = (8.0 / 180.0 * Math.PI);\n\n  /**\n   * The maximum linear velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxTranslation: number = 2.0;\n  static get maxTranslationSquared(): number { return Settings.maxTranslation * Settings.maxTranslation; }\n\n  /**\n   * The maximum angular velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxRotation: number = (0.5 * Math.PI);\n  static get maxRotationSquared(): number { return Settings.maxRotation * Settings.maxRotation; }\n\n  /**\n   * This scale factor controls how fast overlap is resolved. Ideally this would\n   * be 1 so that overlap is removed in one time step. However using values close\n   * to 1 often lead to overshoot.\n   */\n  static baumgarte: number = 0.2;\n  static toiBaugarte: number = 0.75;\n\n  // Sleep\n\n  /**\n   * The time that a body must be still before it will go to sleep.\n   */\n  static timeToSleep: number = 0.5;\n\n  /**\n   * A body cannot sleep if its linear velocity is above this tolerance.\n   */\n  static linearSleepTolerance: number = 0.01;\n  static get linearSleepToleranceSqr(): number { return Math.pow(Settings.linearSleepTolerance, 2); }\n\n  /**\n   * A body cannot sleep if its angular velocity is above this tolerance.\n   */\n  static angularSleepTolerance: number = (2.0 / 180.0 * Math.PI);\n  static get angularSleepToleranceSqr(): number { return Math.pow(Settings.angularSleepTolerance, 2); }\n\n}\n","/*\n * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\nexport class Pool<T> {\n  _list: T[] = [];\n  _max: number = Infinity;\n\n  _createFn: () => T;\n  _outFn: (item: T) => void;\n  _inFn: (item: T) => void;\n  _discardFn: (item: T) => T;\n\n  _createCount: number = 0;\n  _outCount: number = 0;\n  _inCount: number = 0;\n  _discardCount: number = 0;\n\n  constructor(opts: {\n    max?: number,\n    create?: () => T,\n    allocate?: (item: T) => void,\n    release?: (item: T) => void,\n    discard?: (item: T) => T,\n  }) {\n    this._list = [];\n    this._max = opts.max || this._max;\n\n    this._createFn = opts.create;\n    this._outFn = opts.allocate;\n    this._inFn = opts.release;\n    this._discardFn = opts.discard;\n  }\n\n  max(n?: number): number | Pool<T> {\n    if (typeof n === 'number') {\n      this._max = n;\n      return this;\n    }\n    return this._max;\n  }\n\n  size(): number {\n    return this._list.length;\n  }\n\n  allocate(): T {\n    let item: T;\n    if (this._list.length > 0) {\n      item = this._list.shift();\n    } else {\n      this._createCount++;\n      if (typeof this._createFn === 'function') {\n        item = this._createFn();\n      } else {\n        // tslint:disable-next-line:no-object-literal-type-assertion\n        item = {} as T;\n      }\n    }\n    this._outCount++;\n    if (typeof this._outFn === 'function') {\n      this._outFn(item);\n    }\n    return item;\n  }\n\n  release(item: T): void {\n    if (this._list.length < this._max) {\n      this._inCount++;\n      if (typeof this._inFn === 'function') {\n        this._inFn(item);\n      }\n      this._list.push(item);\n    } else {\n      this._discardCount++;\n      if (typeof this._discardFn === 'function') {\n        item = this._discardFn(item);\n      }\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return \" +\" + this._createCount + \" >\" + this._outCount + \" <\" + this._inCount + \" -\"\n      + this._discardCount + \" =\" + this._list.length + \"/\" + this._max;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Settings } from '../Settings';\nimport common from '../util/common';\nimport { Pool } from '../util/Pool';\nimport { Vec2 } from '../common/Vec2';\nimport { Math } from '../common/Math';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type DynamicTreeQueryCallback = (nodeId: number) => boolean;\n\n/**\n * A node in the dynamic tree. The client does not interact with this directly.\n */\nexport class TreeNode<T> {\n  id: number;\n  /** Enlarged AABB */\n  aabb: AABB = new AABB();\n  userData: T = null;\n  parent: TreeNode<T> = null;\n  child1: TreeNode<T> = null;\n  child2: TreeNode<T> = null;\n  /** 0: leaf, -1: free node */\n  height: number = -1;\n\n  constructor(id?: number) {\n    this.id = id;\n  }\n\n  /** @internal */\n  toString(): string {\n    return this.id + \": \" + this.userData;\n  }\n\n  isLeaf(): boolean {\n    return this.child1 == null;\n  }\n}\n\n/**\n * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n * dynamic tree arranges data in a binary tree to accelerate queries such as\n * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n * than the client object. This allows the client object to move by small\n * amounts without triggering a tree update.\n *\n * Nodes are pooled and relocatable, so we use node indices rather than\n * pointers.\n */\nexport class DynamicTree<T> {\n  m_root: TreeNode<T>;\n  m_lastProxyId: number;\n  m_nodes: {\n    [id: number]: TreeNode<T>\n  };\n  m_pool: Pool<TreeNode<T>>;\n\n  constructor() {\n    this.m_root = null;\n    this.m_nodes = {};\n    this.m_lastProxyId = 0;\n\n    this.m_pool = new Pool<TreeNode<T>>({\n      create(): TreeNode<T> {\n        return new TreeNode();\n      }\n    });\n  }\n\n  /**\n   * Get proxy user data.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getUserData(id: number): T {\n    const node = this.m_nodes[id];\n    _ASSERT && common.assert(!!node);\n    return node.userData;\n  }\n\n  /**\n   * Get the fat AABB for a node id.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getFatAABB(id: number): AABB {\n    const node = this.m_nodes[id];\n    _ASSERT && common.assert(!!node);\n    return node.aabb;\n  }\n\n  allocateNode(): TreeNode<T> {\n    const node = this.m_pool.allocate();\n    node.id = ++this.m_lastProxyId;\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    this.m_nodes[node.id] = node;\n    return node;\n  }\n\n  freeNode(node: TreeNode<T>): void {\n    this.m_pool.release(node);\n    node.height = -1;\n    // tslint:disable-next-line:no-dynamic-delete\n    delete this.m_nodes[node.id];\n  }\n\n  /**\n   * Create a proxy in the tree as a leaf node. We return the index of the node\n   * instead of a pointer so that we can grow the node pool.\n   *\n   * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n   */\n  createProxy(aabb: AABB, userData: T): number {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n\n    const node = this.allocateNode();\n\n    node.aabb.set(aabb);\n\n    // Fatten the aabb.\n    AABB.extend(node.aabb, Settings.aabbExtension);\n\n    node.userData = userData;\n    node.height = 0;\n\n    this.insertLeaf(node);\n\n    return node.id;\n  }\n\n  /**\n   * Destroy a proxy. This asserts if the id is invalid.\n   */\n  destroyProxy(id: number): void {\n    const node = this.m_nodes[id];\n\n    _ASSERT && common.assert(!!node);\n    _ASSERT && common.assert(node.isLeaf());\n\n    this.removeLeaf(node);\n    this.freeNode(node);\n  }\n\n  /**\n   * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n   * fattened AABB, then the proxy is removed from the tree and re-inserted.\n   * Otherwise the function returns immediately.\n   *\n   * @param d Displacement\n   *\n   * @return true if the proxy was re-inserted.\n   */\n  moveProxy(id: number, aabb: AABB, d: Vec2): boolean {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    _ASSERT && common.assert(!d || Vec2.isValid(d));\n\n    const node = this.m_nodes[id];\n\n    _ASSERT && common.assert(!!node);\n    _ASSERT && common.assert(node.isLeaf());\n\n    if (node.aabb.contains(aabb)) {\n      return false;\n    }\n\n    this.removeLeaf(node);\n\n    node.aabb.set(aabb);\n\n    // Extend AABB.\n    aabb = node.aabb;\n    AABB.extend(aabb, Settings.aabbExtension);\n\n    // Predict AABB displacement.\n    // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n\n    if (d.x < 0.0) {\n      aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n    }\n\n    if (d.y < 0.0) {\n      aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n    }\n\n    this.insertLeaf(node);\n\n    return true;\n  }\n\n  insertLeaf(leaf: TreeNode<T>): void {\n    _ASSERT && common.assert(AABB.isValid(leaf.aabb));\n\n    if (this.m_root == null) {\n      this.m_root = leaf;\n      this.m_root.parent = null;\n      return;\n    }\n\n    // Find the best sibling for this node\n    const leafAABB = leaf.aabb;\n    let index = this.m_root;\n    while (!index.isLeaf()) {\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      const area = index.aabb.getPerimeter();\n\n      const combinedAABB = new AABB();\n      combinedAABB.combine(index.aabb, leafAABB);\n      const combinedArea = combinedAABB.getPerimeter();\n\n      // Cost of creating a new parent for this node and the new leaf\n      const cost = 2.0 * combinedArea;\n\n      // Minimum cost of pushing the leaf further down the tree\n      const inheritanceCost = 2.0 * (combinedArea - area);\n\n      // Cost of descending into child1\n      let cost1;\n      if (child1.isLeaf()) {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child1.aabb);\n        cost1 = aabb.getPerimeter() + inheritanceCost;\n      } else {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child1.aabb);\n        const oldArea = child1.aabb.getPerimeter();\n        const newArea = aabb.getPerimeter();\n        cost1 = (newArea - oldArea) + inheritanceCost;\n      }\n\n      // Cost of descending into child2\n      let cost2;\n      if (child2.isLeaf()) {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child2.aabb);\n        cost2 = aabb.getPerimeter() + inheritanceCost;\n      } else {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child2.aabb);\n        const oldArea = child2.aabb.getPerimeter();\n        const newArea = aabb.getPerimeter();\n        cost2 = newArea - oldArea + inheritanceCost;\n      }\n\n      // Descend according to the minimum cost.\n      if (cost < cost1 && cost < cost2) {\n        break;\n      }\n\n      // Descend\n      if (cost1 < cost2) {\n        index = child1;\n      } else {\n        index = child2;\n      }\n    }\n\n    const sibling = index;\n\n    // Create a new parent.\n    const oldParent = sibling.parent;\n    const newParent = this.allocateNode();\n    newParent.parent = oldParent;\n    newParent.userData = null;\n    newParent.aabb.combine(leafAABB, sibling.aabb);\n    newParent.height = sibling.height + 1;\n\n    if (oldParent != null) {\n      // The sibling was not the root.\n      if (oldParent.child1 === sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n    } else {\n      // The sibling was the root.\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n      this.m_root = newParent;\n    }\n\n    // Walk back up the tree fixing heights and AABBs\n    index = leaf.parent;\n    while (index != null) {\n      index = this.balance(index);\n\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      _ASSERT && common.assert(child1 != null);\n      _ASSERT && common.assert(child2 != null);\n\n      index.height = 1 + Math.max(child1.height, child2.height);\n      index.aabb.combine(child1.aabb, child2.aabb);\n\n      index = index.parent;\n    }\n\n    // validate();\n  }\n\n  removeLeaf(leaf: TreeNode<T>): void {\n    if (leaf === this.m_root) {\n      this.m_root = null;\n      return;\n    }\n\n    const parent = leaf.parent;\n    const grandParent = parent.parent;\n    let sibling;\n    if (parent.child1 === leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (grandParent != null) {\n      // Destroy parent and connect sibling to grandParent.\n      if (grandParent.child1 === parent) {\n        grandParent.child1 = sibling;\n      } else {\n        grandParent.child2 = sibling;\n      }\n      sibling.parent = grandParent;\n      this.freeNode(parent);\n\n      // Adjust ancestor bounds.\n      let index = grandParent;\n      while (index != null) {\n        index = this.balance(index);\n\n        const child1 = index.child1;\n        const child2 = index.child2;\n\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index.height = 1 + Math.max(child1.height, child2.height);\n\n        index = index.parent;\n      }\n    } else {\n      this.m_root = sibling;\n      sibling.parent = null;\n      this.freeNode(parent);\n    }\n\n    // validate();\n  }\n\n  /**\n   * Perform a left or right rotation if node A is imbalanced. Returns the new\n   * root index.\n   */\n  balance(iA: TreeNode<T>): TreeNode<T> {\n    _ASSERT && common.assert(iA != null);\n\n    const A = iA;\n    if (A.isLeaf() || A.height < 2) {\n      return iA;\n    }\n\n    const B = A.child1;\n    const C = A.child2;\n\n    const balance = C.height - B.height;\n\n    // Rotate C up\n    if (balance > 1) {\n      const F = C.child1;\n      const G = C.child2;\n\n      // Swap A and C\n      C.child1 = A;\n      C.parent = A.parent;\n      A.parent = C;\n\n      // A's old parent should point to C\n      if (C.parent != null) {\n        if (C.parent.child1 === iA) {\n          C.parent.child1 = C;\n        } else {\n          C.parent.child2 = C;\n        }\n      } else {\n        this.m_root = C;\n      }\n\n      // Rotate\n      if (F.height > G.height) {\n        C.child2 = F;\n        A.child2 = G;\n        G.parent = A;\n        A.aabb.combine(B.aabb, G.aabb);\n        C.aabb.combine(A.aabb, F.aabb);\n\n        A.height = 1 + Math.max(B.height, G.height);\n        C.height = 1 + Math.max(A.height, F.height);\n      } else {\n        C.child2 = G;\n        A.child2 = F;\n        F.parent = A;\n        A.aabb.combine(B.aabb, F.aabb);\n        C.aabb.combine(A.aabb, G.aabb);\n\n        A.height = 1 + Math.max(B.height, F.height);\n        C.height = 1 + Math.max(A.height, G.height);\n      }\n\n      return C;\n    }\n\n    // Rotate B up\n    if (balance < -1) {\n      const D = B.child1;\n      const E = B.child2;\n\n      // Swap A and B\n      B.child1 = A;\n      B.parent = A.parent;\n      A.parent = B;\n\n      // A's old parent should point to B\n      if (B.parent != null) {\n        if (B.parent.child1 === A) {\n          B.parent.child1 = B;\n        } else {\n          B.parent.child2 = B;\n        }\n      } else {\n        this.m_root = B;\n      }\n\n      // Rotate\n      if (D.height > E.height) {\n        B.child2 = D;\n        A.child1 = E;\n        E.parent = A;\n        A.aabb.combine(C.aabb, E.aabb);\n        B.aabb.combine(A.aabb, D.aabb);\n\n        A.height = 1 + Math.max(C.height, E.height);\n        B.height = 1 + Math.max(A.height, D.height);\n      } else {\n        B.child2 = E;\n        A.child1 = D;\n        D.parent = A;\n        A.aabb.combine(C.aabb, D.aabb);\n        B.aabb.combine(A.aabb, E.aabb);\n\n        A.height = 1 + Math.max(C.height, D.height);\n        B.height = 1 + Math.max(A.height, E.height);\n      }\n\n      return B;\n    }\n\n    return A;\n  }\n\n  /**\n   * Compute the height of the binary tree in O(N) time. Should not be called\n   * often.\n   */\n  getHeight(): number {\n    if (this.m_root == null) {\n      return 0;\n    }\n\n    return this.m_root.height;\n  }\n\n  /**\n   * Get the ratio of the sum of the node areas to the root area.\n   */\n  getAreaRatio(): number {\n    if (this.m_root == null) {\n      return 0.0;\n    }\n\n    const root = this.m_root;\n    const rootArea = root.aabb.getPerimeter();\n\n    let totalArea = 0.0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // Free node in pool\n        continue;\n      }\n\n      totalArea += node.aabb.getPerimeter();\n    }\n\n    this.iteratorPool.release(it);\n\n    return totalArea / rootArea;\n  }\n\n  /**\n   * Compute the height of a sub-tree.\n   */\n  computeHeight(id?: number): number {\n    let node;\n    if (typeof id !== 'undefined') {\n      node = this.m_nodes[id];\n    } else {\n      node = this.m_root;\n    }\n\n    // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);\n\n    if (node.isLeaf()) {\n      return 0;\n    }\n\n    const height1 = this.computeHeight(node.child1.id);\n    const height2 = this.computeHeight(node.child2.id);\n    return 1 + Math.max(height1, height2);\n  }\n\n  validateStructure(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    if (node === this.m_root) {\n      _ASSERT && common.assert(node.parent == null);\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && common.assert(child1 == null);\n      _ASSERT && common.assert(child2 == null);\n      _ASSERT && common.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    _ASSERT && common.assert(child1.parent === node);\n    _ASSERT && common.assert(child2.parent === node);\n\n    this.validateStructure(child1);\n    this.validateStructure(child2);\n  }\n\n  validateMetrics(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && common.assert(child1 == null);\n      _ASSERT && common.assert(child2 == null);\n      _ASSERT && common.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    const height1 = child1.height;\n    const height2 = child2.height;\n    const height = 1 + Math.max(height1, height2);\n    _ASSERT && common.assert(node.height === height);\n\n    const aabb = new AABB();\n    aabb.combine(child1.aabb, child2.aabb);\n\n    _ASSERT && common.assert(AABB.areEqual(aabb, node.aabb));\n\n    this.validateMetrics(child1);\n    this.validateMetrics(child2);\n  }\n\n  /**\n   * Validate this tree. For testing.\n   */\n  validate(): void {\n    this.validateStructure(this.m_root);\n    this.validateMetrics(this.m_root);\n\n    _ASSERT && common.assert(this.getHeight() === this.computeHeight());\n  }\n\n  /**\n   * Get the maximum balance of an node in the tree. The balance is the difference\n   * in height of the two children of a node.\n   */\n  getMaxBalance(): number {\n    let maxBalance = 0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height <= 1) {\n        continue;\n      }\n\n      _ASSERT && common.assert(!node.isLeaf());\n\n      const balance = Math.abs(node.child2.height - node.child1.height);\n      maxBalance = Math.max(maxBalance, balance);\n    }\n    this.iteratorPool.release(it);\n\n    return maxBalance;\n  }\n\n  /**\n   * Build an optimal tree. Very expensive. For testing.\n   */\n  rebuildBottomUp(): void {\n    const nodes = [];\n    let count = 0;\n\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // free node in pool\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        node.parent = null;\n        nodes[count] = node;\n        ++count;\n      } else {\n        this.freeNode(node);\n      }\n    }\n    this.iteratorPool.release(it);\n\n    while (count > 1) {\n      let minCost = Infinity;\n      let iMin = -1;\n      let jMin = -1;\n      for (let i = 0; i < count; ++i) {\n        const aabbi = nodes[i].aabb;\n        for (let j = i + 1; j < count; ++j) {\n          const aabbj = nodes[j].aabb;\n          const b = new AABB();\n          b.combine(aabbi, aabbj);\n          const cost = b.getPerimeter();\n          if (cost < minCost) {\n            iMin = i;\n            jMin = j;\n            minCost = cost;\n          }\n        }\n      }\n\n      const child1 = nodes[iMin];\n      const child2 = nodes[jMin];\n\n      const parent = this.allocateNode();\n      parent.child1 = child1;\n      parent.child2 = child2;\n      parent.height = 1 + Math.max(child1.height, child2.height);\n      parent.aabb.combine(child1.aabb, child2.aabb);\n      parent.parent = null;\n\n      child1.parent = parent;\n      child2.parent = parent;\n\n      nodes[jMin] = nodes[count - 1];\n      nodes[iMin] = parent;\n      --count;\n    }\n\n    this.m_root = nodes[0];\n\n    this.validate();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      const aabb = node.aabb;\n      aabb.lowerBound.x -= newOrigin.x;\n      aabb.lowerBound.y -= newOrigin.y;\n      aabb.upperBound.x -= newOrigin.x;\n      aabb.upperBound.y -= newOrigin.y;\n    }\n    this.iteratorPool.release(it);\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query(aabb: AABB, queryCallback: DynamicTreeQueryCallback): void {\n    _ASSERT && common.assert(typeof queryCallback === 'function');\n    const stack = this.stackPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, aabb)) {\n        if (node.isLeaf()) {\n          const proceed = queryCallback(node.id);\n          if (proceed === false) {\n            return;\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n    }\n\n    this.stackPool.release(stack);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    // TODO: GC\n    _ASSERT && common.assert(typeof rayCastCallback === 'function');\n    const p1 = input.p1;\n    const p2 = input.p2;\n    const r = Vec2.sub(p2, p1);\n    _ASSERT && common.assert(r.lengthSquared() > 0.0);\n    r.normalize();\n\n    // v is perpendicular to the segment.\n    const v = Vec2.crossNumVec2(1.0, r);\n    const abs_v = Vec2.abs(v);\n\n    // Separating axis for segment (Gino, p80).\n    // |dot(v, p1 - c)| > dot(|v|, h)\n\n    let maxFraction = input.maxFraction;\n\n    // Build a bounding box for the segment.\n    const segmentAABB = new AABB();\n    let t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n    segmentAABB.combinePoints(p1, t);\n\n    const stack = this.stackPool.allocate();\n    const subInput = this.inputPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n        continue;\n      }\n\n      // Separating axis for segment (Gino, p80).\n      // |dot(v, p1 - c)| > dot(|v|, h)\n      const c = node.aabb.getCenter();\n      const h = node.aabb.getExtents();\n      const separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n      if (separation > 0.0) {\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        subInput.p1 = Vec2.clone(input.p1);\n        subInput.p2 = Vec2.clone(input.p2);\n        subInput.maxFraction = maxFraction;\n\n        const value = rayCastCallback(subInput, node.id);\n\n        if (value === 0.0) {\n          // The client has terminated the ray cast.\n          return;\n        }\n\n        if (value > 0.0) {\n          // update segment bounding box.\n          maxFraction = value;\n          t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n          segmentAABB.combinePoints(p1, t);\n        }\n      } else {\n        stack.push(node.child1);\n        stack.push(node.child2);\n      }\n    }\n    this.stackPool.release(stack);\n    this.inputPool.release(subInput);\n  }\n\n  private inputPool: Pool<RayCastInput> = new Pool<RayCastInput>({\n    create(): RayCastInput {\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      return {} as RayCastInput;\n    },\n    release(stack: RayCastInput): void {\n    }\n  });\n\n  private stackPool: Pool<Array<TreeNode<T>>> = new Pool<Array<TreeNode<T>>>({\n    create(): Array<TreeNode<T>> {\n      return [];\n    },\n    release(stack: Array<TreeNode<T>>): void {\n      stack.length = 0;\n    }\n  });\n\n  private iteratorPool: Pool<Iterator<T>> = new Pool<Iterator<T>>({\n    create(): Iterator<T> {\n      return new Iterator();\n    },\n    release(iterator: Iterator<T>): void {\n      iterator.close();\n    }\n  });\n\n}\n\nclass Iterator<T> {\n  parents: Array<TreeNode<T>> = [];\n  states: number[] = [];\n  preorder(root: TreeNode<T>): Iterator<T> {\n    this.parents.length = 0;\n    this.parents.push(root);\n    this.states.length = 0;\n    this.states.push(0);\n    return this;\n  }\n  next(): TreeNode<T> {\n    while (this.parents.length > 0) {\n      const i = this.parents.length - 1;\n      const node = this.parents[i];\n      if (this.states[i] === 0) {\n        this.states[i] = 1;\n        return node;\n      }\n      if (this.states[i] === 1) {\n        this.states[i] = 2;\n        if (node.child1) {\n          this.parents.push(node.child1);\n          this.states.push(1);\n          return node.child1;\n        }\n      }\n      if (this.states[i] === 2) {\n        this.states[i] = 3;\n        if (node.child2) {\n          this.parents.push(node.child2);\n          this.states.push(1);\n          return node.child2;\n        }\n      }\n      this.parents.pop();\n      this.states.pop();\n    }\n  }\n  close(): void {\n    this.parents.length = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Vec2 } from '../common/Vec2';\nimport { Math } from '../common/Math';\nimport { AABB, RayCastCallback, RayCastInput } from './AABB';\nimport { DynamicTree, DynamicTreeQueryCallback } from './DynamicTree';\nimport { FixtureProxy } from \"../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n * objects and query them on update.\n */\nexport class BroadPhase {\n  m_tree: DynamicTree<FixtureProxy> = new DynamicTree<FixtureProxy>();\n  m_proxyCount: number = 0;\n  m_moveBuffer: number[] = [];\n\n  m_callback: (userDataA: any, userDataB: any) => void;\n  m_queryProxyId: number;\n\n  /**\n   * Get user data from a proxy. Returns null if the id is invalid.\n   */\n  getUserData(proxyId: number): FixtureProxy {\n    return this.m_tree.getUserData(proxyId);\n  }\n\n  /**\n   * Test overlap of fat AABBs.\n   */\n  testOverlap(proxyIdA: number, proxyIdB: number): boolean {\n    const aabbA = this.m_tree.getFatAABB(proxyIdA);\n    const aabbB = this.m_tree.getFatAABB(proxyIdB);\n    return AABB.testOverlap(aabbA, aabbB);\n  }\n\n  /**\n   * Get the fat AABB for a proxy.\n   */\n  getFatAABB(proxyId: number): AABB {\n    return this.m_tree.getFatAABB(proxyId);\n  }\n\n  /**\n   * Get the number of proxies.\n   */\n  getProxyCount(): number {\n    return this.m_proxyCount;\n  }\n\n  /**\n   * Get the height of the embedded tree.\n   */\n  getTreeHeight(): number {\n    return this.m_tree.getHeight();\n  }\n\n  /**\n   * Get the balance (integer) of the embedded tree.\n   */\n  getTreeBalance(): number {\n    return this.m_tree.getMaxBalance();\n  }\n\n  /**\n   * Get the quality metric of the embedded tree.\n   */\n  getTreeQuality(): number {\n    return this.m_tree.getAreaRatio();\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query = (aabb: AABB, queryCallback: DynamicTreeQueryCallback): void => {\n    this.m_tree.query(aabb, queryCallback);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    this.m_tree.rayCast(input, rayCastCallback);\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_tree.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n   * is called.\n   */\n  createProxy(aabb: AABB, userData: FixtureProxy): number {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    const proxyId = this.m_tree.createProxy(aabb, userData);\n    this.m_proxyCount++;\n    this.bufferMove(proxyId);\n    return proxyId;\n  }\n\n  /**\n   * Destroy a proxy. It is up to the client to remove any pairs.\n   */\n  destroyProxy(proxyId: number): void {\n    this.unbufferMove(proxyId);\n    this.m_proxyCount--;\n    this.m_tree.destroyProxy(proxyId);\n  }\n\n  /**\n   * Call moveProxy as many times as you like, then when you are done call\n   * UpdatePairs to finalized the proxy pairs (for your time step).\n   */\n  moveProxy(proxyId: number, aabb: AABB, displacement: Vec2): void {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    const changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n    if (changed) {\n      this.bufferMove(proxyId);\n    }\n  }\n\n  /**\n   * Call to trigger a re-processing of it's pairs on the next call to\n   * UpdatePairs.\n   */\n  touchProxy(proxyId: number): void {\n    this.bufferMove(proxyId);\n  }\n\n  bufferMove(proxyId: number): void {\n    this.m_moveBuffer.push(proxyId);\n  }\n\n  unbufferMove(proxyId: number): void {\n    for (let i = 0; i < this.m_moveBuffer.length; ++i) {\n      if (this.m_moveBuffer[i] === proxyId) {\n        this.m_moveBuffer[i] = null;\n      }\n    }\n  }\n\n  /**\n   * Update the pairs. This results in pair callbacks. This can only add pairs.\n   */\n  updatePairs(addPairCallback: (userDataA: FixtureProxy, userDataB: FixtureProxy) => void): void {\n    _ASSERT && common.assert(typeof addPairCallback === 'function');\n    this.m_callback = addPairCallback;\n\n    // Perform tree queries for all moving proxies.\n    while (this.m_moveBuffer.length > 0) {\n      this.m_queryProxyId = this.m_moveBuffer.pop();\n      if (this.m_queryProxyId === null) {\n        continue;\n      }\n\n      // We have to query the tree with the fat AABB so that\n      // we don't fail to create a pair that may touch later.\n      const fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n\n      // Query tree, create pairs and add them pair buffer.\n      this.m_tree.query(fatAABB, this.queryCallback);\n    }\n\n    // Try to keep the tree balanced.\n    // this.m_tree.rebalance(4);\n  }\n\n  queryCallback = (proxyId: number): boolean => {\n    // A proxy cannot form a pair with itself.\n    if (proxyId === this.m_queryProxyId) {\n      return true;\n    }\n\n    const proxyIdA = Math.min(proxyId, this.m_queryProxyId);\n    const proxyIdB = Math.max(proxyId, this.m_queryProxyId);\n\n    // TODO: Skip any duplicate pairs.\n\n    const userDataA = this.m_tree.getUserData(proxyIdA);\n    const userDataB = this.m_tree.getUserData(proxyIdB);\n\n    // Send the pairs back to the client.\n    this.m_callback(userDataA, userDataB);\n\n    return true;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Vec2 } from './Vec2';\nimport { Math } from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class Rot {\n  s: number;\n  c: number;\n\n  /** Initialize from an angle in radians. */\n  constructor(angle?: number | Rot) {\n    if (!(this instanceof Rot)) {\n      return new Rot(angle);\n    }\n    if (typeof angle === 'number') {\n      this.setAngle(angle);\n    } else if (typeof angle === 'object') {\n      this.setRot(angle);\n    } else {\n      this.setIdentity();\n    }\n  }\n\n  /** @internal */\n  static neo(angle: number): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.setAngle(angle);\n    return obj;\n  }\n\n  static clone(rot: Rot): Rot {\n    _ASSERT && Rot.assert(rot);\n    const obj = Object.create(Rot.prototype);\n    obj.s = rot.s;\n    obj.c = rot.c;\n    return obj;\n  }\n\n  static identity(): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.s = 0.0;\n    obj.c = 1.0;\n    return obj;\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.s) && Math.isFinite(obj.c);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Rot.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Rot!');\n    }\n  }\n\n  /** Set to the identity rotation. */\n  setIdentity(): void {\n    this.s = 0.0;\n    this.c = 1.0;\n  }\n\n  set(angle: number | Rot): void {\n    if (typeof angle === 'object') {\n      _ASSERT && Rot.assert(angle);\n      this.s = angle.s;\n      this.c = angle.c;\n\n    } else {\n      _ASSERT && Math.assert(angle);\n      // TODO_ERIN optimize\n      this.s = Math.sin(angle);\n      this.c = Math.cos(angle);\n    }\n  }\n\n  setRot(angle: Rot): void {\n    _ASSERT && Rot.assert(angle);\n    this.s = angle.s;\n    this.c = angle.c;\n  }\n\n  /** Set using an angle in radians. */\n  setAngle(angle: number): void {\n    _ASSERT && Math.assert(angle);\n    // TODO_ERIN optimize\n    this.s = Math.sin(angle);\n    this.c = Math.cos(angle);\n  }\n\n  /** Get the angle in radians. */\n  getAngle(): number {\n    return Math.atan2(this.s, this.c);\n  }\n\n  /** Get the x-axis. */\n  getXAxis(): Vec2 {\n    return Vec2.neo(this.c, this.s);\n  }\n\n  /** Get the u-axis. */\n  getYAxis(): Vec2 {\n    return Vec2.neo(-this.s, this.c);\n  }\n\n  /** Multiply two rotations: q * r */\n  static mul(rot: Rot, m: Rot): Rot;\n  /** Rotate a vector */\n  static mul(rot: Rot, m: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(rot, m) {\n    _ASSERT && Rot.assert(rot);\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n      // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n      // s = qs * rc + qc * rs\n      // c = qc * rc - qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Multiply two rotations: q * r */\n  static mulRot(rot: Rot, m: Rot): Rot {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Rot.assert(m);\n    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n    // s = qs * rc + qc * rs\n    // c = qc * rc - qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.s * m.c + rot.c * m.s;\n    qr.c = rot.c * m.c - rot.s * m.s;\n    return qr;\n  }\n\n  /** Rotate a vector */\n  static mulVec2(rot: Rot, m: Vec2): Vec2 {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n  }\n\n  static mulSub(rot: Rot, v: Vec2, w: Vec2): Vec2 {\n    const x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n    const y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n    return Vec2.neo(x, y);\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulT(rot: Rot, m: Rot): Rot;\n  /** Inverse rotate a vector */\n  static mulT(rot: Rot, m: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(rot, m) {\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n      // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n      // s = qc * rs - qs * rc\n      // c = qc * rc + qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulTRot(rot: Rot, m: Rot): Rot {\n    _ASSERT && Rot.assert(m);\n    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n    // s = qc * rs - qs * rc\n    // c = qc * rc + qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.c * m.s - rot.s * m.c;\n    qr.c = rot.c * m.c + rot.s * m.s;\n    return qr;\n  }\n\n  /** Inverse rotate a vector */\n  static mulTVec2(rot: Rot, m: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Vec2 } from './Vec2';\nimport { Rot } from './Rot';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A transform contains translation and rotation. It is used to represent the\n * position and orientation of rigid frames. Initialize using a position vector\n * and a rotation.\n */\nexport class Transform {\n  /** position */\n  p: Vec2;\n\n  /** rotation */\n  q: Rot;\n\n  constructor(position?: Vec2, rotation?: number) {\n    if (!(this instanceof Transform)) {\n      return new Transform(position, rotation);\n    }\n    this.p = Vec2.zero();\n    this.q = Rot.identity();\n    if (typeof position !== 'undefined') {\n      this.p.setVec2(position);\n    }\n    if (typeof rotation !== 'undefined') {\n      this.q.setAngle(rotation);\n    }\n  }\n\n  static clone(xf: Transform): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(xf.p);\n    obj.q = Rot.clone(xf.q);\n    return obj;\n  }\n\n  /** @internal */\n  static neo(position: Vec2, rotation: Rot): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(position);\n    obj.q = Rot.clone(rotation);\n    return obj;\n  }\n\n  static identity(): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.zero();\n    obj.q = Rot.identity();\n    return obj;\n  }\n\n  /**\n   * Set this to the identity transform.\n   */\n  setIdentity(): void {\n    this.p.setZero();\n    this.q.setIdentity();\n  }\n\n  set(position: Vec2, rotation: number): void;\n  set(xf: Transform): void;\n  /**\n   * Set this based on the position and angle.\n   */\n  // tslint:disable-next-line:typedef\n  set(a, b?) {\n    if (typeof b === 'undefined') {\n      this.p.set(a.p);\n      this.q.set(a.q);\n    } else {\n      this.p.set(a);\n      this.q.set(b);\n    }\n  }\n\n  /**\n   * Set this based on the position and angle.\n   */\n  setNum(position: Vec2, rotation: number) {\n    this.p.setVec2(position);\n    this.q.setAngle(rotation);\n  }\n\n  setTransform(xf: Transform): void {\n    this.p.setVec2(xf.p);\n    this.q.setRot(xf.q);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Transform.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Transform!');\n    }\n  }\n\n  static mul(a: Transform, b: Vec2): Vec2;\n  static mul(a: Transform, b: Transform): Transform;\n  // static mul(a: Transform, b: Vec2[]): Vec2[];\n  // static mul(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (Array.isArray(b)) {\n      _ASSERT && Transform.assert(a);\n      const arr = [];\n      for (let i = 0; i < b.length; i++) {\n        arr[i] = Transform.mul(a, b[i]);\n      }\n      return arr;\n\n    } else if ('x' in b && 'y' in b) {\n      return Transform.mulVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulXf(a, b);\n    }\n  }\n\n  static mulAll(a: Transform, b: Vec2[]): Vec2[];\n  static mulAll(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mulAll(a: Transform, b) {\n    _ASSERT && Transform.assert(a);\n    const arr = [];\n    for (let i = 0; i < b.length; i++) {\n      arr[i] = Transform.mul(a, b[i]);\n    }\n    return arr;\n  }\n\n  /** @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static mulFn(a: Transform) {\n    _ASSERT && Transform.assert(a);\n    return function(b: Vec2): Vec2 {\n      return Transform.mul(a, b);\n    };\n  }\n\n  static mulVec2(a: Transform, b: Vec2): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n    const y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulXf(a: Transform, b: Transform): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n    const xf = Transform.identity();\n    xf.q = Rot.mulRot(a.q, b.q);\n    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n    return xf;\n  }\n\n  static mulT(a: Transform, b: Vec2): Vec2;\n  static mulT(a: Transform, b: Transform): Transform;\n  // tslint:disable-next-line:typedef\n  static mulT(a, b) {\n    if ('x' in b && 'y' in b) {\n      return Transform.mulTVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulTXf(a, b);\n    }\n  }\n\n  static mulTVec2(a: Transform, b: Vec2): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const px = b.x - a.p.x;\n    const py = b.y - a.p.y;\n    const x = (a.q.c * px + a.q.s * py);\n    const y = (-a.q.s * px + a.q.c * py);\n    return Vec2.neo(x, y);\n  }\n\n  static mulTXf(a: Transform, b: Transform): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q' * (B.q * v1 + B.p - A.p)\n    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n    const xf = Transform.identity();\n    xf.q.setRot(Rot.mulTRot(a.q, b.q));\n    xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Math } from './Math';\nimport { Vec2 } from './Vec2';\nimport { Rot } from './Rot';\nimport { Transform } from './Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * This describes the motion of a body/shape for TOI computation. Shapes are\n * defined with respect to the body origin, which may not coincide with the\n * center of mass. However, to support dynamics we must interpolate the center\n * of mass position.\n */\nexport class Sweep {\n  /** Local center of mass position */\n  localCenter: Vec2;\n\n  /** World center position */\n  c: Vec2;\n\n  /** World angle */\n  a: number;\n\n  /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */\n  alpha0: number;\n\n  c0: Vec2;\n  a0: number;\n\n  constructor(c?: Vec2, a?: number) {\n    _ASSERT && common.assert(typeof c === 'undefined');\n    _ASSERT && common.assert(typeof a === 'undefined');\n    this.localCenter = Vec2.zero();\n    this.c = Vec2.zero();\n    this.a = 0;\n    this.alpha0 = 0;\n    this.c0 = Vec2.zero();\n    this.a0 = 0;\n  }\n\n  setTransform(xf: Transform): void {\n    const c = Transform.mulVec2(xf, this.localCenter);\n    this.c.setVec2(c);\n    this.c0.setVec2(c);\n\n    this.a = xf.q.getAngle();\n    this.a0 = xf.q.getAngle();\n  }\n\n  setLocalCenter(localCenter: Vec2, xf: Transform): void {\n    this.localCenter.setVec2(localCenter);\n\n    const c = Transform.mulVec2(xf, this.localCenter);\n    this.c.setVec2(c);\n    this.c0.setVec2(c);\n  }\n\n  /**\n   * Get the interpolated transform at a specific time.\n   *\n   * @param xf\n   * @param beta A factor in [0,1], where 0 indicates alpha0\n   */\n  getTransform(xf: Transform, beta: number = 0): void {\n    xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);\n    xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);\n\n    // shift to origin\n    xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));\n  }\n\n  /**\n   * Advance the sweep forward, yielding a new initial state.\n   *\n   * @param alpha The new initial time\n   */\n  advance(alpha: number): void {\n    _ASSERT && common.assert(this.alpha0 < 1.0);\n    const beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n    this.c0.setCombine(beta, this.c, 1 - beta, this.c0);\n    this.a0 = beta * this.a + (1 - beta) * this.a0;\n    this.alpha0 = alpha;\n  }\n\n  forward(): void {\n    this.a0 = this.a;\n    this.c0.setVec2(this.c);\n  }\n\n  /**\n   * normalize the angles in radians to be between -pi and pi.\n   */\n  normalize(): void {\n    const a0 = Math.mod(this.a0, -Math.PI, +Math.PI);\n    this.a -= this.a0 - a0;\n    this.a0 = a0;\n  }\n\n  clone(): Sweep {\n    const clone = new Sweep();\n    clone.localCenter.setVec2(this.localCenter);\n    clone.alpha0 = this.alpha0;\n    clone.a0 = this.a0;\n    clone.a = this.a;\n    clone.c0.setVec2(this.c0);\n    clone.c.setVec2(this.c);\n    return clone;\n  }\n\n  set(that: Sweep): void {\n    this.localCenter.setVec2(that.localCenter);\n    this.alpha0 = that.alpha0;\n    this.a0 = that.a0;\n    this.a = that.a;\n    this.c0.setVec2(that.c0);\n    this.c.setVec2(that.c);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\n\nexport class Velocity {\n  /** linear */\n  v: Vec2;\n\n  /** angular */\n  w: number;\n\n  constructor() {\n    this.v = Vec2.zero();\n    this.w = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Transform } from '../common/Transform';\n\n\nexport class Position {\n  /** location */\n  c: Vec2;\n\n  /** angle */\n  a: number;\n\n  constructor() {\n    this.c = Vec2.zero();\n    this.a = 0;\n  }\n\n  getTransform(xf: Transform, p: Vec2): Transform {\n    xf.q.setAngle(this.a);\n    xf.p.setVec2(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../dynamics/Body';\nimport { AABB, RayCastOutput, RayCastInput } from './AABB';\nimport { DistanceProxy } from './Distance';\nimport type { Transform }  from '../common/Transform';\nimport type { Vec2 }  from '../common/Vec2';\n\n\n/**\n * A shape is used for collision detection. You can create a shape however you\n * like. Shapes used for simulation in World are created automatically when a\n * Fixture is created. Shapes may encapsulate one or more child shapes.\n */\nexport abstract class Shape {\n  m_type: ShapeType;\n  m_radius: number;\n\n  /** @internal */\n  _reset(): void {\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * Get the type of this shape. You can use this to down cast to the concrete\n   * shape.\n   *\n   * @return the shape type.\n   */\n  getType(): ShapeType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  abstract _clone(): Shape;\n\n  /**\n   * Get the number of child primitives.\n   */\n  abstract getChildCount(): number;\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  abstract testPoint(xf: Transform, p: Vec2): boolean;\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  abstract rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  abstract computeAABB(aabb: AABB, xf: Transform, childIndex: number): void;\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  abstract computeMass(massData: MassData, density?: number): void;\n\n  abstract computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void;\n\n}\n\nexport type ShapeType = \"circle\" | \"edge\" | \"polygon\" | \"chain\";\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { options } from '../util/options';\nimport { Math } from '../common/Math';\nimport { Vec2 } from '../common/Vec2';\nimport { AABB, RayCastInput, RayCastOutput } from '../collision/AABB';\nimport { Shape, ShapeType } from '../collision/Shape';\nimport { Body, MassData } from \"./Body\";\nimport { BroadPhase } from \"../collision/BroadPhase\";\nimport { Transform } from \"../common/Transform\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A fixture definition is used to create a fixture. This class defines an\n * abstract fixture definition. You can reuse fixture definitions safely.\n */\nexport interface FixtureOpt {\n  userData?: unknown;\n  /**\n   * The friction coefficient, usually in the range [0,1]\n   */\n  friction?: number;\n  /**\n   * The restitution (elasticity) usually in the range [0,1]\n   */\n  restitution?: number;\n  /**\n   * The density, usually in kg/m^2\n   */\n  density?: number;\n  /**\n   * A sensor shape collects contact information but never generates a collision response.\n   */\n  isSensor?: boolean;\n  /**\n   * Zero, positive or negative collision group.\n   * Fixtures with same positive groupIndex always collide and fixtures with same negative groupIndex never collide.\n   */\n  filterGroupIndex?: number;\n  /**\n   * Collision category bit or bits that this fixture belongs to.\n   * If groupIndex is zero or not matching, then at least one bit in this fixture categoryBits should match other fixture maskBits and vice versa.\n   */\n  filterCategoryBits?: number;\n  /**\n   * Collision category bit or bits that this fixture accept for collision.\n   */\n  filterMaskBits?: number;\n}\n\nexport interface FixtureDef extends FixtureOpt {\n  shape: Shape;\n}\n\nconst FixtureDefDefault: FixtureOpt = {\n  userData : null,\n  friction : 0.2,\n  restitution : 0.0,\n  density : 0.0,\n  isSensor : false,\n\n  filterGroupIndex : 0,\n  filterCategoryBits : 0x0001,\n  filterMaskBits : 0xFFFF\n};\n\n/**\n * This proxy is used internally to connect shape children to the broad-phase.\n */\nexport class FixtureProxy {\n  aabb: AABB;\n  fixture: Fixture;\n  childIndex: number;\n  proxyId: number;\n  constructor(fixture: Fixture, childIndex: number) {\n    this.aabb = new AABB();\n    this.fixture = fixture;\n    this.childIndex = childIndex;\n    this.proxyId;\n  }\n}\n\n/**\n * A fixture is used to attach a shape to a body for collision detection. A\n * fixture inherits its transform from its parent. Fixtures hold additional\n * non-geometric data such as friction, collision filters, etc.\n *\n * To create a new Fixture use {@link Body.createFixture}.\n */\nexport class Fixture {\n  /** @internal */ m_body: Body;\n  /** @internal */ m_friction: number;\n  /** @internal */ m_restitution: number;\n  /** @internal */ m_density: number;\n  /** @internal */ m_isSensor: boolean;\n  /** @internal */ m_filterGroupIndex: number;\n  /** @internal */ m_filterCategoryBits: number;\n  /** @internal */ m_filterMaskBits: number;\n  /** @internal */ m_shape: Shape;\n  /** @internal */ m_next: Fixture | null;\n  /** @internal */ m_proxies: FixtureProxy[];\n  /** @internal */ m_proxyCount: number;\n  /** @internal */ m_userData: unknown;\n\n  constructor(body: Body, def: FixtureDef);\n  constructor(body: Body, shape: Shape, def?: FixtureOpt);\n  constructor(body: Body, shape: Shape, density?: number);\n  // tslint:disable-next-line:typedef\n  /** @internal */ constructor(body: Body, shape?, def?) {\n    if (shape.shape) {\n      def = shape;\n      shape = shape.shape;\n\n    } else if (typeof def === 'number') {\n      def = {density : def};\n    }\n\n    def = options(def, FixtureDefDefault);\n\n    this.m_body = body;\n\n    this.m_friction = def.friction;\n    this.m_restitution = def.restitution;\n    this.m_density = def.density;\n    this.m_isSensor = def.isSensor;\n\n    this.m_filterGroupIndex = def.filterGroupIndex;\n    this.m_filterCategoryBits = def.filterCategoryBits;\n    this.m_filterMaskBits = def.filterMaskBits;\n\n    // TODO validate shape\n    this.m_shape = shape; // .clone();\n\n    this.m_next = null;\n\n    this.m_proxies = [];\n    this.m_proxyCount = 0;\n\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Re-setup fixture.\n   * @internal\n   */\n  _reset(): void {\n    const body = this.getBody();\n    const broadPhase = body.m_world.m_broadPhase;\n    this.destroyProxies(broadPhase);\n    if (this.m_shape._reset) {\n      this.m_shape._reset();\n    }\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n    this.createProxies(broadPhase, body.m_xf);\n    body.resetMassData();\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      friction: this.m_friction,\n      restitution: this.m_restitution,\n      density: this.m_density,\n      isSensor: this.m_isSensor,\n\n      filterGroupIndex: this.m_filterGroupIndex,\n      filterCategoryBits: this.m_filterCategoryBits,\n      filterMaskBits: this.m_filterMaskBits,\n\n      shape: this.m_shape,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, body: any, restore: any): Fixture {\n    const shape = restore(Shape, data.shape);\n    const fixture = shape && new Fixture(body, shape, data);\n    return fixture;\n  }\n\n  /**\n   * Get the type of the child shape. You can use this to down cast to the\n   * concrete shape.\n   */\n  getType(): ShapeType {\n    return this.m_shape.getType();\n  }\n\n  /**\n   * Get the child shape. You can modify the child shape, however you should not\n   * change the number of vertices because this will crash some collision caching\n   * mechanisms. Manipulating the shape may lead to non-physical behavior.\n   */\n  getShape(): Shape {\n    return this.m_shape;\n  }\n\n  /**\n   * A sensor shape collects contact information but never generates a collision\n   * response.\n   */\n  isSensor(): boolean {\n    return this.m_isSensor;\n  }\n\n  /**\n   * Set if this fixture is a sensor.\n   */\n  setSensor(sensor: boolean): void {\n    if (sensor != this.m_isSensor) {\n      this.m_body.setAwake(true);\n      this.m_isSensor = sensor;\n    }\n  }\n\n  // /**\n  //  * Get the contact filtering data.\n  //  */\n  // getFilterData() {\n  //   return this.m_filter;\n  // }\n\n  /**\n   * Get the user data that was assigned in the fixture definition. Use this to\n   * store your application specific data.\n   */\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  /**\n   * Set the user data. Use this to store your application specific data.\n   */\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get the parent body of this fixture. This is null if the fixture is not\n   * attached.\n   */\n  getBody(): Body {\n    return this.m_body;\n  }\n\n  /**\n   * Get the next fixture in the parent body's fixture list.\n   */\n  getNext(): Fixture | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get the density of this fixture.\n   */\n  getDensity(): number {\n    return this.m_density;\n  }\n\n  /**\n   * Set the density of this fixture. This will _not_ automatically adjust the\n   * mass of the body. You must call Body.resetMassData to update the body's mass.\n   */\n  setDensity(density: number): void {\n    _ASSERT && common.assert(Math.isFinite(density) && density >= 0.0);\n    this.m_density = density;\n  }\n\n  /**\n   * Get the coefficient of friction, usually in the range [0,1].\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Set the coefficient of friction. This will not change the friction of\n   * existing contacts.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the coefficient of restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Set the coefficient of restitution. This will not change the restitution of\n   * existing contacts.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Test a point in world coordinates for containment in this fixture.\n   */\n  testPoint(p: Vec2): boolean {\n    return this.m_shape.testPoint(this.m_body.getTransform(), p);\n  }\n\n  /**\n   * Cast a ray against this shape.\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, childIndex: number): boolean {\n    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n  }\n\n  /**\n   * Get the mass data for this fixture. The mass data is based on the density and\n   * the shape. The rotational inertia is about the shape's origin. This operation\n   * may be expensive.\n   */\n  getMassData(massData: MassData): void {\n    this.m_shape.computeMass(massData, this.m_density);\n  }\n\n  /**\n   * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n   * more accurate AABB, compute it using the shape and the body transform.\n   */\n  getAABB(childIndex: number): AABB {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_proxyCount);\n    return this.m_proxies[childIndex].aabb;\n  }\n\n  /**\n   * These support body activation/deactivation.\n   */\n  createProxies(broadPhase: BroadPhase, xf: Transform): void {\n    _ASSERT && common.assert(this.m_proxyCount == 0);\n\n    // Create proxies in the broad-phase.\n    this.m_proxyCount = this.m_shape.getChildCount();\n\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      this.m_shape.computeAABB(proxy.aabb, xf, i);\n      proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n    }\n  }\n\n  destroyProxies(broadPhase: BroadPhase): void {\n    // Destroy proxies in the broad-phase.\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      broadPhase.destroyProxy(proxy.proxyId);\n      proxy.proxyId = null;\n    }\n\n    this.m_proxyCount = 0;\n  }\n\n  /**\n   * Updates this fixture proxy in broad-phase (with combined AABB of current and\n   * next transformation).\n   */\n  synchronize(broadPhase: BroadPhase, xf1: Transform, xf2: Transform): void {\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      // Compute an AABB that covers the swept shape (may miss some rotation\n      // effect).\n      const aabb1 = new AABB();\n      const aabb2 = new AABB();\n      this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);\n      this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);\n\n      proxy.aabb.combine(aabb1, aabb2);\n\n      const displacement = Vec2.sub(xf2.p, xf1.p);\n\n      broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n    }\n  }\n\n  /**\n   * Set the contact filtering data. This will not update contacts until the next\n   * time step when either parent body is active and awake. This automatically\n   * calls refilter.\n   */\n  setFilterData(filter: { groupIndex: number, categoryBits: number, maskBits: number }): void {\n    this.m_filterGroupIndex = filter.groupIndex;\n    this.m_filterCategoryBits = filter.categoryBits;\n    this.m_filterMaskBits = filter.maskBits;\n    this.refilter();\n  }\n\n  getFilterGroupIndex(): number {\n    return this.m_filterGroupIndex;\n  }\n\n  setFilterGroupIndex(groupIndex: number): void {\n    this.m_filterGroupIndex = groupIndex;\n  }\n\n  getFilterCategoryBits(): number {\n    return this.m_filterCategoryBits;\n  }\n\n  setFilterCategoryBits(categoryBits: number): void {\n    this.m_filterCategoryBits = categoryBits;\n  }\n\n  getFilterMaskBits(): number {\n    return this.m_filterMaskBits;\n  }\n\n  setFilterMaskBits(maskBits: number): void {\n    this.m_filterMaskBits = maskBits;\n  }\n\n  /**\n   * Call this if you want to establish collision that was previously disabled by\n   * ContactFilter.\n   */\n  refilter(): void {\n    if (this.m_body == null) {\n      return;\n    }\n\n    // Flag associated contacts for filtering.\n    let edge = this.m_body.getContactList();\n    while (edge) {\n      const contact = edge.contact;\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      if (fixtureA == this || fixtureB == this) {\n        contact.flagForFiltering();\n      }\n\n      edge = edge.next;\n    }\n\n    const world = this.m_body.getWorld();\n\n    if (world == null) {\n      return;\n    }\n\n    // Touch each proxy so that new pairs may be created\n    const broadPhase = world.m_broadPhase;\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      broadPhase.touchProxy(this.m_proxies[i].proxyId);\n    }\n  }\n\n  /**\n   * Implement this method to provide collision filtering, if you want finer\n   * control over contact creation.\n   *\n   * Return true if contact calculations should be performed between these two\n   * fixtures.\n   *\n   * Warning: for performance reasons this is only called when the AABBs begin to\n   * overlap.\n   */\n  shouldCollide(that: Fixture): boolean {\n\n    if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n      return that.m_filterGroupIndex > 0;\n    }\n\n    const collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n    const collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n    const collide = collideA && collideB;\n    return collide;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport common from '../util/common';\nimport { options } from '../util/options';\nimport { Vec2 } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Math } from '../common/Math';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Velocity } from './Velocity';\nimport { Position } from './Position';\nimport { Fixture, FixtureDef, FixtureOpt } from './Fixture';\nimport { Shape } from '../collision/Shape';\nimport { JointEdge } from \"./Joint\";\nimport { World } from \"./World\";\nimport { ContactEdge } from \"./Contact\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport type BodyType = 'static' | 'kinematic' | 'dynamic';\n\nconst STATIC = 'static';\nconst KINEMATIC = 'kinematic';\nconst DYNAMIC = 'dynamic';\n\nexport interface BodyDef {\n  /**\n   * Body types are static, kinematic, or dynamic. Note: if a dynamic\n   * body would have zero mass, the mass is set to one.\n   */\n  type?: BodyType;\n  /**\n   * The world position of the body. Avoid creating bodies at the\n   * origin since this can lead to many overlapping shapes.\n   */\n  position?: Vec2;\n  /**\n   * The world angle of the body in radians.\n   */\n  angle?: number;\n  /**\n   * The linear velocity of the body's origin in world co-ordinates.\n   */\n  linearVelocity?: Vec2;\n  angularVelocity?: number;\n  /**\n   * Linear damping is use to reduce the linear velocity. The\n   * damping parameter can be larger than 1.0 but the damping effect becomes\n   * sensitive to the time step when the damping parameter is large.\n   */\n  linearDamping?: number;\n  /**\n   * Angular damping is use to reduce the angular velocity.\n   * The damping parameter can be larger than 1.0 but the damping effect\n   * becomes sensitive to the time step when the damping parameter is large.\n   */\n  angularDamping?: number;\n  /**\n   * Should this body be prevented from rotating? Useful for characters.\n   */\n  fixedRotation?: boolean;\n  /**\n   * Is this a fast moving body that should be prevented from\n   * tunneling through other moving bodies? Note that all bodies are\n   * prevented from tunneling through kinematic and static bodies. This\n   * setting is only considered on dynamic bodies. Warning: You should use\n   * this flag sparingly since it increases processing time.\n   */\n  bullet?: boolean;\n  gravityScale?: number;\n  /**\n   * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.\n   */\n  allowSleep?: boolean;\n  /**\n   * Is this body initially awake or sleeping?\n   */\n  awake?: boolean;\n  /**\n   * Does this body start out active?\n   */\n  active?: boolean;\n  userData?: any;\n}\n\nconst BodyDefDefault: BodyDef = {\n  type : STATIC,\n  position : Vec2.zero(),\n  angle : 0.0,\n\n  linearVelocity : Vec2.zero(),\n  angularVelocity : 0.0,\n\n  linearDamping : 0.0,\n  angularDamping : 0.0,\n\n  fixedRotation : false,\n  bullet : false,\n  gravityScale : 1.0,\n\n  allowSleep : true,\n  awake : true,\n  active : true,\n\n  userData : null\n};\n\n/**\n * MassData This holds the mass data computed for a shape.\n */\nexport class MassData {\n  /** The mass of the shape, usually in kilograms. */\n  mass: number = 0;\n  /** The position of the shape's centroid relative to the shape's origin. */\n  center: Vec2 = Vec2.zero();\n  /** The rotational inertia of the shape about the local origin. */\n  I: number = 0;\n}\n\n/**\n * A rigid body composed of one or more fixtures.\n *\n * To create a new Body use {@link World.createBody}.\n */\nexport class Body {\n  /**\n   * A static body does not move under simulation and behaves as if it has infinite mass.\n   * Internally, zero is stored for the mass and the inverse mass.\n   * Static bodies can be moved manually by the user.\n   * A static body has zero velocity.\n   * Static bodies do not collide with other static or kinematic bodies.\n   */\n  static readonly STATIC: BodyType = 'static';\n  /**\n   * A kinematic body moves under simulation according to its velocity.\n   * Kinematic bodies do not respond to forces.\n   * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n   * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n   * Kinematic bodies do not collide with other kinematic or static bodies.\n   */\n  static readonly KINEMATIC: BodyType = 'kinematic';\n\n  /**\n   * A dynamic body is fully simulated.\n   * They can be moved manually by the user, but normally they move according to forces.\n   * A dynamic body can collide with all body types.\n   * A dynamic body always has finite, non-zero mass.\n   * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n   */\n  static readonly DYNAMIC: BodyType = 'dynamic';\n\n  /** @internal */ m_world: World;\n  /** @internal */ m_awakeFlag: boolean;\n  /** @internal */ m_autoSleepFlag: boolean;\n  /** @internal */ m_bulletFlag: boolean;\n  /** @internal */ m_fixedRotationFlag: boolean;\n  /** @internal */ m_activeFlag: boolean;\n  /** @internal */ m_islandFlag: boolean;\n  /** @internal */ m_toiFlag: boolean;\n  /** @internal */ m_userData: unknown;\n  /** @internal */ m_type: BodyType;\n  /** @internal */ m_mass: number;\n  /** @internal */ m_invMass: number;\n  /** @internal Rotational inertia about the center of mass. */\n  m_I: number;\n  /** @internal */ m_invI: number;\n  /** @internal the body origin transform */\n  m_xf: Transform;\n  /** @internal the swept motion for CCD */\n  m_sweep: Sweep;\n  // position and velocity correction\n  /** @internal */ c_velocity: Velocity;\n  /** @internal */ c_position: Position;\n  /** @internal */ m_force: Vec2;\n  /** @internal */ m_torque: number;\n  /** @internal */ m_linearVelocity: Vec2;\n  /** @internal */ m_angularVelocity: number;\n  /** @internal */ m_linearDamping: number;\n  /** @internal */ m_angularDamping: number;\n  /** @internal */ m_gravityScale: number;\n  /** @internal */ m_sleepTime: number;\n  /** @internal */ m_jointList: JointEdge | null;\n  /** @internal */ m_contactList: ContactEdge | null;\n  /** @internal */ m_fixtureList: Fixture | null;\n  /** @internal */ m_prev: Body | null;\n  /** @internal */ m_next: Body | null;\n  /** @internal */ m_destroyed: boolean;\n\n  /** @internal */\n  constructor(world: World, def: BodyDef) {\n    def = options(def, BodyDefDefault);\n\n    _ASSERT && common.assert(Vec2.isValid(def.position));\n    _ASSERT && common.assert(Vec2.isValid(def.linearVelocity));\n    _ASSERT && common.assert(Math.isFinite(def.angle));\n    _ASSERT && common.assert(Math.isFinite(def.angularVelocity));\n    _ASSERT && common.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);\n\n    this.m_world = world;\n\n    this.m_awakeFlag = def.awake;\n    this.m_autoSleepFlag = def.allowSleep;\n    this.m_bulletFlag = def.bullet;\n    this.m_fixedRotationFlag = def.fixedRotation;\n    this.m_activeFlag = def.active;\n\n    this.m_islandFlag = false;\n    this.m_toiFlag = false;\n\n    this.m_userData = def.userData;\n    this.m_type = def.type;\n\n    if (this.m_type == DYNAMIC) {\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    } else {\n      this.m_mass = 0.0;\n      this.m_invMass = 0.0;\n    }\n\n    // Rotational inertia about the center of mass.\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    // the body origin transform\n    this.m_xf = Transform.identity();\n    this.m_xf.p = Vec2.clone(def.position);\n    this.m_xf.q.setAngle(def.angle);\n\n    // the swept motion for CCD\n    this.m_sweep = new Sweep();\n    this.m_sweep.setTransform(this.m_xf);\n\n    // position and velocity correction\n    this.c_velocity = new Velocity();\n    this.c_position = new Position();\n\n    this.m_force = Vec2.zero();\n    this.m_torque = 0.0;\n\n    this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n    this.m_angularVelocity = def.angularVelocity;\n\n    this.m_linearDamping = def.linearDamping;\n    this.m_angularDamping = def.angularDamping;\n    this.m_gravityScale = def.gravityScale;\n\n    this.m_sleepTime = 0.0;\n\n    this.m_jointList = null;\n    this.m_contactList = null;\n    this.m_fixtureList = null;\n\n    this.m_prev = null;\n    this.m_next = null;\n\n    this.m_destroyed = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const fixtures = [];\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      fixtures.push(f);\n    }\n    return {\n      type: this.m_type,\n      bullet: this.m_bulletFlag,\n      position: this.m_xf.p,\n      angle: this.m_xf.q.getAngle(),\n      linearVelocity: this.m_linearVelocity,\n      angularVelocity: this.m_angularVelocity,\n      fixtures,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): Body {\n    const body = new Body(world, data);\n\n    if (data.fixtures) {\n      for (let i = data.fixtures.length - 1; i >= 0; i--) {\n        const fixture = restore(Fixture, data.fixtures[i], body);\n        body._addFixture(fixture);\n      }\n    }\n    return body;\n  }\n\n  isWorldLocked(): boolean {\n    return this.m_world && this.m_world.isLocked() ? true : false;\n  }\n\n  getWorld(): World {\n    return this.m_world;\n  }\n\n  getNext(): Body | null {\n    return this.m_next;\n  }\n\n  setUserData(data: any): void {\n    this.m_userData = data;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  getFixtureList(): Fixture | null {\n    return this.m_fixtureList;\n  }\n\n  getJointList(): JointEdge | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Warning: this list changes during the time step and you may miss some\n   * collisions if you don't use ContactListener.\n   */\n  getContactList(): ContactEdge | null {\n    return this.m_contactList;\n  }\n\n  isStatic(): boolean {\n    return this.m_type == STATIC;\n  }\n\n  isDynamic(): boolean {\n    return this.m_type == DYNAMIC;\n  }\n\n  isKinematic(): boolean {\n    return this.m_type == KINEMATIC;\n  }\n\n  /**\n   * This will alter the mass and velocity.\n   */\n  setStatic(): Body {\n    this.setType(STATIC);\n    return this;\n  }\n\n  setDynamic(): Body {\n    this.setType(DYNAMIC);\n    return this;\n  }\n\n  setKinematic(): Body {\n    this.setType(KINEMATIC);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  getType(): BodyType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   */\n  setType(type: BodyType): void {\n    _ASSERT && common.assert(type === STATIC || type === KINEMATIC || type === DYNAMIC);\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type == type) {\n      return;\n    }\n\n    this.m_type = type;\n\n    this.resetMassData();\n\n    if (this.m_type == STATIC) {\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_sweep.forward();\n      this.synchronizeFixtures();\n    }\n\n    this.setAwake(true);\n\n    this.m_force.setZero();\n    this.m_torque = 0.0;\n\n    // Delete the attached contacts.\n    let ce = this.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n      this.m_world.destroyContact(ce0.contact);\n    }\n    this.m_contactList = null;\n\n    // Touch the proxies so that new contacts will be created (when appropriate)\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      const proxyCount = f.m_proxyCount;\n      for (let i = 0; i < proxyCount; ++i) {\n        broadPhase.touchProxy(f.m_proxies[i].proxyId);\n      }\n    }\n  }\n\n  isBullet(): boolean {\n    return this.m_bulletFlag;\n  }\n\n  /**\n   * Should this body be treated like a bullet for continuous collision detection?\n   */\n  setBullet(flag: boolean): void {\n    this.m_bulletFlag = !!flag;\n  }\n\n  isSleepingAllowed(): boolean {\n    return this.m_autoSleepFlag;\n  }\n\n  setSleepingAllowed(flag: boolean): void {\n    this.m_autoSleepFlag = !!flag;\n    if (this.m_autoSleepFlag == false) {\n      this.setAwake(true);\n    }\n  }\n\n  isAwake(): boolean {\n    return this.m_awakeFlag;\n  }\n\n  /**\n   * Set the sleep state of the body. A sleeping body has very low CPU cost.\n   *\n   * @param flag Set to true to wake the body, false to put it to sleep.\n   */\n  setAwake(flag: boolean): void {\n    if (flag) {\n      if (this.m_awakeFlag == false) {\n        this.m_awakeFlag = true;\n        this.m_sleepTime = 0.0;\n      }\n    } else {\n      this.m_awakeFlag = false;\n      this.m_sleepTime = 0.0;\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_force.setZero();\n      this.m_torque = 0.0;\n    }\n  }\n\n  isActive(): boolean {\n    return this.m_activeFlag;\n  }\n\n  /**\n   * Set the active state of the body. An inactive body is not simulated and\n   * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n   * will be added to the broad-phase. If you pass a flag of false, all fixtures\n   * will be removed from the broad-phase and all contacts will be destroyed.\n   * Fixtures and joints are otherwise unaffected.\n   *\n   * You may continue to create/destroy fixtures and joints on inactive bodies.\n   * Fixtures on an inactive body are implicitly inactive and will not participate\n   * in collisions, ray-casts, or queries. Joints connected to an inactive body\n   * are implicitly inactive. An inactive body is still owned by a World object\n   * and remains\n   */\n  setActive(flag: boolean): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (flag == this.m_activeFlag) {\n      return;\n    }\n\n    this.m_activeFlag = !!flag;\n\n    if (this.m_activeFlag) {\n      // Create all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.createProxies(broadPhase, this.m_xf);\n      }\n      // Contacts are created the next time step.\n\n    } else {\n      // Destroy all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.destroyProxies(broadPhase);\n      }\n\n      // Destroy the attached contacts.\n      let ce = this.m_contactList;\n      while (ce) {\n        const ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n    }\n  }\n\n  isFixedRotation(): boolean {\n    return this.m_fixedRotationFlag;\n  }\n\n  /**\n   * Set this body to have fixed rotation. This causes the mass to be reset.\n   */\n  setFixedRotation(flag: boolean): void {\n    if (this.m_fixedRotationFlag == flag) {\n      return;\n    }\n\n    this.m_fixedRotationFlag = !!flag;\n\n    this.m_angularVelocity = 0.0;\n\n    this.resetMassData();\n  }\n\n  /**\n   * Get the world transform for the body's origin.\n   */\n  getTransform(): Transform {\n    return this.m_xf;\n  }\n\n  /**\n   * Set the position of the body's origin and rotation. Manipulating a body's\n   * transform may cause non-physical behavior. Note: contacts are updated on the\n   * next call to World.step.\n   *\n   * @param position The world position of the body's local origin.\n   * @param angle The world rotation in radians.\n   */\n  setTransform(position: Vec2, angle: number): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    this.m_xf.setNum(position, angle);\n    this.m_sweep.setTransform(this.m_xf);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, this.m_xf, this.m_xf);\n    }\n  }\n\n  synchronizeTransform(): void {\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Update fixtures in broad-phase.\n   */\n  synchronizeFixtures(): void {\n    const xf = Transform.identity();\n\n    this.m_sweep.getTransform(xf, 0);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, xf, this.m_xf);\n    }\n  }\n\n  /**\n   * Used in TOI.\n   */\n  advance(alpha: number): void {\n    // Advance to the new safe time. This doesn't sync the broad-phase.\n    this.m_sweep.advance(alpha);\n    this.m_sweep.c.setVec2(this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Get the world position for the body's origin.\n   */\n  getPosition(): Vec2 {\n    return this.m_xf.p;\n  }\n\n  setPosition(p: Vec2): void {\n    this.setTransform(p, this.m_sweep.a);\n  }\n\n  /**\n   * Get the current world rotation angle in radians.\n   */\n  getAngle(): number {\n    return this.m_sweep.a;\n  }\n\n  setAngle(angle: number): void {\n    this.setTransform(this.m_xf.p, angle);\n  }\n\n  /**\n   * Get the world position of the center of mass.\n   */\n  getWorldCenter(): Vec2 {\n    return this.m_sweep.c;\n  }\n\n  /**\n   * Get the local position of the center of mass.\n   */\n  getLocalCenter(): Vec2 {\n    return this.m_sweep.localCenter;\n  }\n\n  /**\n   * Get the linear velocity of the center of mass.\n   *\n   * @return the linear velocity of the center of mass.\n   */\n  getLinearVelocity(): Vec2 {\n    return this.m_linearVelocity;\n  }\n\n  /**\n   * Get the world linear velocity of a world point attached to this body.\n   *\n   * @param worldPoint A point in world coordinates.\n   */\n  getLinearVelocityFromWorldPoint(worldPoint: Vec2): Vec2 {\n    const localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n    return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity,\n      localCenter));\n  }\n\n  /**\n   * Get the world velocity of a local point.\n   *\n   * @param localPoint A point in local coordinates.\n   */\n  getLinearVelocityFromLocalPoint(localPoint: Vec2): Vec2 {\n    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n  }\n\n  /**\n   * Set the linear velocity of the center of mass.\n   *\n   * @param v The new linear velocity of the center of mass.\n   */\n  setLinearVelocity(v: Vec2): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (Vec2.dot(v, v) > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_linearVelocity.setVec2(v);\n  }\n\n  /**\n   * Get the angular velocity.\n   *\n   * @returns the angular velocity in radians/second.\n   */\n  getAngularVelocity(): number {\n    return this.m_angularVelocity;\n  }\n\n  /**\n   * Set the angular velocity.\n   *\n   * @param omega The new angular velocity in radians/second.\n   */\n  setAngularVelocity(w: number): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (w * w > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_angularVelocity = w;\n  }\n\n  getLinearDamping(): number {\n    return this.m_linearDamping;\n  }\n\n  setLinearDamping(linearDamping: number): void {\n    this.m_linearDamping = linearDamping;\n  }\n\n  getAngularDamping(): number {\n    return this.m_angularDamping;\n  }\n\n  setAngularDamping(angularDamping: number): void {\n    this.m_angularDamping = angularDamping;\n  }\n\n  getGravityScale(): number {\n    return this.m_gravityScale;\n  }\n\n  /**\n   * Scale the gravity applied to this body.\n   */\n  setGravityScale(scale: number): void {\n    this.m_gravityScale = scale;\n  }\n\n  /**\n   * Get the total mass of the body.\n   *\n   * @returns The mass, usually in kilograms (kg).\n   */\n  getMass(): number {\n    return this.m_mass;\n  }\n\n  /**\n   * Get the rotational inertia of the body about the local origin.\n   *\n   * @return the rotational inertia, usually in kg-m^2.\n   */\n  getInertia(): number {\n    return this.m_I + this.m_mass\n      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n  }\n\n  /**\n   * Copy the mass data of the body to data.\n   */\n  getMassData(data: MassData): void {\n    data.mass = this.m_mass;\n    data.I = this.getInertia();\n    data.center.setVec2(this.m_sweep.localCenter);\n  }\n\n  /**\n   * This resets the mass properties to the sum of the mass properties of the\n   * fixtures. This normally does not need to be called unless you called\n   * SetMassData to override the mass and you later want to reset the mass.\n   */\n  resetMassData(): void {\n    // Compute mass data from shapes. Each shape has its own density.\n    this.m_mass = 0.0;\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n    this.m_sweep.localCenter.setZero();\n\n    // Static and kinematic bodies have zero mass.\n    if (this.isStatic() || this.isKinematic()) {\n      this.m_sweep.c0.setVec2(this.m_xf.p);\n      this.m_sweep.c.setVec2(this.m_xf.p);\n      this.m_sweep.a0 = this.m_sweep.a;\n      return;\n    }\n\n    _ASSERT && common.assert(this.isDynamic());\n\n    // Accumulate mass over all fixtures.\n    const localCenter = Vec2.zero();\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      if (f.m_density == 0.0) {\n        continue;\n      }\n\n      const massData = new MassData();\n      f.getMassData(massData);\n      this.m_mass += massData.mass;\n      localCenter.addMul(massData.mass, massData.center);\n      this.m_I += massData.I;\n    }\n\n    // Compute center of mass.\n    if (this.m_mass > 0.0) {\n      this.m_invMass = 1.0 / this.m_mass;\n      localCenter.mul(this.m_invMass);\n\n    } else {\n      // Force all dynamic bodies to have a positive mass.\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    }\n\n    if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n      // Center the inertia about the center of mass.\n      this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);\n      _ASSERT && common.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n\n    } else {\n      this.m_I = 0.0;\n      this.m_invI = 0.0;\n    }\n\n    // Move center of mass.\n    const oldCenter = Vec2.clone(this.m_sweep.c);\n    this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n\n    // Update center of mass velocity.\n    this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(\n      this.m_sweep.c, oldCenter)));\n  }\n\n  /**\n   * Set the mass properties to override the mass properties of the fixtures. Note\n   * that this changes the center of mass position. Note that creating or\n   * destroying fixtures can also alter the mass. This function has no effect if\n   * the body isn't dynamic.\n   *\n   * @param massData The mass properties.\n   */\n  setMassData(massData: MassData): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    this.m_mass = massData.mass;\n    if (this.m_mass <= 0.0) {\n      this.m_mass = 1.0;\n    }\n\n    this.m_invMass = 1.0 / this.m_mass;\n\n    if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n      this.m_I = massData.I - this.m_mass\n        * Vec2.dot(massData.center, massData.center);\n      _ASSERT && common.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n    }\n\n    // Move center of mass.\n    const oldCenter = Vec2.clone(this.m_sweep.c);\n    this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n\n    // Update center of mass velocity.\n    this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(\n      this.m_sweep.c, oldCenter)));\n  }\n\n  /**\n   * Apply a force at a world point. If the force is not applied at the center of\n   * mass, it will generate a torque and affect the angular velocity. This wakes\n   * up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyForce(force: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping.\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n      this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n    }\n  }\n\n  /**\n   * Apply a force to the center of mass. This wakes up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param wake Also wake up the body\n   */\n  applyForceToCenter(force: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n    }\n  }\n\n  /**\n   * Apply a torque. This affects the angular velocity without affecting the\n   * linear velocity of the center of mass. This wakes up the body.\n   *\n   * @param torque About the z-axis (out of the screen), usually in N-m.\n   * @param wake Also wake up the body\n   */\n  applyTorque(torque: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_torque += torque;\n    }\n  }\n\n  /**\n   * Apply an impulse at a point. This immediately modifies the velocity. It also\n   * modifies the angular velocity if the point of application is not at the\n   * center of mass. This wakes up the body.\n   *\n   * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyLinearImpulse(impulse: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_linearVelocity.addMul(this.m_invMass, impulse);\n      this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n    }\n  }\n\n  /**\n   * Apply an angular impulse.\n   *\n   * @param impulse The angular impulse in units of kg*m*m/s\n   * @param wake Also wake up the body\n   */\n  applyAngularImpulse(impulse: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_angularVelocity += this.m_invI * impulse;\n    }\n  }\n\n  /**\n   * This is used to prevent connected bodies (by joints) from colliding,\n   * depending on the joint's collideConnected flag.\n   */\n  shouldCollide(that: Body): boolean {\n    // At least one body should be dynamic.\n    if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n      return false;\n    }\n    // Does a joint prevent collision?\n    for (let jn = this.m_jointList; jn; jn = jn.next) {\n      if (jn.other == that) {\n        if (jn.joint.m_collideConnected == false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addFixture(fixture: Fixture): Fixture {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.createProxies(broadPhase, this.m_xf);\n    }\n\n    fixture.m_next = this.m_fixtureList;\n    this.m_fixtureList = fixture;\n\n    // Adjust mass properties if needed.\n    if (fixture.m_density > 0.0) {\n      this.resetMassData();\n    }\n\n    // Let the world know we have a new fixture. This will cause new contacts\n    // to be created at the beginning of the next time step.\n    this.m_world.m_newFixture = true;\n\n    return fixture;\n  }\n\n  /**\n   * Creates a fixture and attach it to this body.\n   *\n   * If the density is non-zero, this function automatically updates the mass of\n   * the body.\n   *\n   * Contacts are not created until the next time step.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createFixture(def: FixtureDef): Fixture;\n  createFixture(shape: Shape, opt?: FixtureOpt): Fixture;\n  createFixture(shape: Shape, density?: number): Fixture;\n  // tslint:disable-next-line:typedef\n  createFixture(shape, fixdef?) {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    const fixture = new Fixture(this, shape, fixdef);\n    this._addFixture(fixture);\n    return fixture;\n  }\n\n  /**\n   * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n   * all contacts associated with this fixture. This will automatically adjust the\n   * mass of the body if the body is dynamic and the fixture has positive density.\n   * All fixtures attached to a body are implicitly destroyed when the body is\n   * destroyed.\n   *\n   * Warning: This function is locked during callbacks.\n   *\n   * @param fixture The fixture to be removed.\n   */\n  destroyFixture(fixture: Fixture): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    _ASSERT && common.assert(fixture.m_body == this);\n\n    // Remove the fixture from this body's singly linked list.\n    let found = false;\n    if (this.m_fixtureList === fixture) {\n      this.m_fixtureList = fixture.m_next;\n      found = true;\n\n    } else {\n      let node = this.m_fixtureList;\n      while (node != null) {\n        if (node.m_next === fixture) {\n          node.m_next = fixture.m_next;\n          found = true;\n          break;\n        }\n        node = node.m_next;\n      }\n    }\n\n    // You tried to remove a shape that is not attached to this body.\n    _ASSERT && common.assert(found);\n\n    // Destroy any contacts associated with the fixture.\n    let edge = this.m_contactList;\n    while (edge) {\n      const c = edge.contact;\n      edge = edge.next;\n\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n\n      if (fixture == fixtureA || fixture == fixtureB) {\n        // This destroys the contact and removes it from\n        // this body's contact list.\n        this.m_world.destroyContact(c);\n      }\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.destroyProxies(broadPhase);\n    }\n\n    fixture.m_body = null;\n    fixture.m_next = null;\n\n    this.m_world.publish('remove-fixture', fixture);\n\n    // Reset the mass data.\n    this.resetMassData();\n  }\n\n  /**\n   * Get the corresponding world point of a local point.\n   */\n  getWorldPoint(localPoint: Vec2): Vec2 {\n    return Transform.mulVec2(this.m_xf, localPoint);\n  }\n\n  /**\n   * Get the corresponding world vector of a local vector.\n   */\n  getWorldVector(localVector: Vec2): Vec2 {\n    return Rot.mulVec2(this.m_xf.q, localVector);\n  }\n\n  /**\n   * Gets the corresponding local point of a world point.\n   */\n  getLocalPoint(worldPoint: Vec2): Vec2 {\n    return Transform.mulTVec2(this.m_xf, worldPoint);\n  }\n\n  /**\n   * Gets the corresponding local vector of a world vector.\n   */\n  getLocalVector(worldVector: Vec2): Vec2 {\n    return Rot.mulTVec2(this.m_xf.q, worldVector);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport type { Vec2 }  from '../common/Vec2';\nimport type { Body }  from './Body';\nimport { TimeStep } from \"./Solver\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * A joint edge is used to connect bodies and joints together in a joint graph\n * where each body is a node and each joint is an edge. A joint edge belongs to\n * a doubly linked list maintained in each attached body. Each joint has two\n * joint nodes, one for each attached body.\n */\nexport class JointEdge {\n  /**\n   * provides quick access to the other body attached.\n   */\n  other: Body | null = null;\n  /**\n   * the joint\n   */\n  joint: Joint | null = null;\n  /**\n   * prev the previous joint edge in the body's joint list\n   */\n  prev: JointEdge | null = null;\n  /**\n   * the next joint edge in the body's joint list\n   */\n  next: JointEdge | null = null;\n}\n\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointOpt {\n  /**\n   * Use this to attach application specific data to your joints.\n   */\n  userData?: any;\n  /**\n   * Set this flag to true if the attached bodies\n   * should collide.\n   */\n  collideConnected?: boolean;\n}\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointDef extends JointOpt {\n  /**\n   * The first attached body.\n   */\n  bodyA: Body;\n  /**\n   * The second attached body.\n   */\n  bodyB: Body;\n}\n\nconst DEFAULTS = {\n  userData : null,\n  collideConnected : false\n};\n\n/**\n * The base joint class. Joints are used to constraint two bodies together in\n * various fashions. Some joints also feature limits and motors.\n */\nexport abstract class Joint {\n\n  /** @internal */ m_type: string = 'unknown-joint';\n\n  /** @internal */ m_bodyA: Body;\n  /** @internal */ m_bodyB: Body;\n\n  /** @internal */ m_collideConnected: boolean;\n\n  /** @internal */ m_prev: Joint | null = null;\n  /** @internal */ m_next: Joint | null = null;\n\n  /** @internal */ m_edgeA: JointEdge = new JointEdge();\n  /** @internal */ m_edgeB: JointEdge = new JointEdge();\n\n  /** @internal */ m_islandFlag: boolean = false;\n  /** @internal */ m_userData: unknown;\n\n  constructor(def: JointDef);\n  constructor(def: JointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: JointDef | JointOpt, bodyA?: Body, bodyB?: Body) {\n    bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n    bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n\n    _ASSERT && common.assert(!!bodyA);\n    _ASSERT && common.assert(!!bodyB);\n    _ASSERT && common.assert(bodyA != bodyB);\n\n    this.m_bodyA = bodyA!;\n    this.m_bodyB = bodyB!;\n\n    this.m_collideConnected = !!def.collideConnected;\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Short-cut function to determine if either body is inactive.\n   */\n  isActive(): boolean {\n    return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n  }\n\n  /**\n   * Get the type of the concrete joint.\n   */\n  getType(): string {\n    return this.m_type;\n  }\n\n  /**\n   * Get the first body attached to this joint.\n   */\n  getBodyA(): Body {\n    return this.m_bodyA;\n  }\n\n  /**\n   * Get the second body attached to this joint.\n   */\n  getBodyB(): Body {\n    return this.m_bodyB;\n  }\n\n  /**\n   * Get the next joint the world joint list.\n   */\n  getNext(): Joint {\n    return this.m_next;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get collide connected. Note: modifying the collide connect flag won't work\n   * correctly because the flag is only checked when fixture AABBs begin to\n   * overlap.\n   */\n  getCollideConnected(): boolean {\n    return this.m_collideConnected;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  abstract getAnchorA(): Vec2;\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  abstract getAnchorB(): Vec2;\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  abstract getReactionForce(inv_dt: number): Vec2;\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  abstract getReactionTorque(inv_dt: number): number;\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {}\n\n  abstract initVelocityConstraints(step: TimeStep): void;\n\n  abstract solveVelocityConstraints(step: TimeStep): void;\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  abstract solvePositionConstraints(step: TimeStep): boolean;\n\n}\n","export const stats = {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n\n  toString(newline?: string): string {\n    newline = typeof newline === 'string' ? newline : '\\n';\n    let string = \"\";\n    // tslint:disable-next-line:no-for-in\n    for (const name in this) {\n      if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {\n        string += name + ': ' + this[name] + newline;\n      }\n    }\n    return string;\n  }\n};\n","export const now = function(): number {\n  return Date.now();\n};\n\nexport const diff = function(time: number): number {\n  return Date.now() - time;\n};\n\nexport default {\n  now,\n  diff,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport common from '../util/common';\n\nimport { Shape } from './Shape';\nimport { Math } from '../common/Math';\nimport { Vec2 } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Transform } from '../common/Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n */\n\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\n\n/**\n * Input for Distance. You have to option to use the shape radii in the\n * computation. Even\n */\nexport class DistanceInput {\n  proxyA: DistanceProxy = new DistanceProxy();\n  proxyB: DistanceProxy = new DistanceProxy();\n  transformA: Transform | null = null;\n  transformB: Transform | null = null;\n  useRadii: boolean = false;\n}\n\n/**\n * Output for Distance.\n *\n * @prop {Vec2} pointA closest point on shapeA\n * @prop {Vec2} pointB closest point on shapeB\n * @prop distance\n * @prop iterations number of GJK iterations used\n */\nexport class DistanceOutput {\n  pointA: Vec2 = Vec2.zero();\n  pointB: Vec2 = Vec2.zero();\n  distance: number;\n  iterations: number;\n}\n\n/**\n * Used to warm start Distance. Set count to zero on first call.\n *\n * @prop {number} metric length or area\n * @prop {array} indexA vertices on shape A\n * @prop {array} indexB vertices on shape B\n * @prop {number} count\n */\nexport class SimplexCache {\n  metric: number = 0;\n  indexA: number[] = [];\n  indexB: number[] = [];\n  count: number = 0;\n}\n\n/**\n * Compute the closest points between two shapes. Supports any combination of:\n * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n * the first call set SimplexCache.count to zero.\n */\nexport function Distance(output: DistanceOutput, cache: SimplexCache, input: DistanceInput): void {\n  ++stats.gjkCalls;\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  // Initialize the simplex.\n  const simplex = new Simplex();\n  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n  const k_maxIters = Settings.maxDistnceIterations;\n\n  // These store the vertices of the last simplex so that we\n  // can check for duplicates and prevent cycling.\n  const saveA = [];\n  const saveB = []; // int[3]\n  let saveCount = 0;\n\n  let distanceSqr1 = Infinity;\n  let distanceSqr2 = Infinity;\n\n  // Main iteration loop.\n  let iter = 0;\n  while (iter < k_maxIters) {\n    // Copy simplex so we can identify duplicates.\n    saveCount = simplex.m_count;\n    for (let i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n\n    simplex.solve();\n\n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count === 3) {\n      break;\n    }\n\n    // Compute closest point.\n    const p = simplex.getClosestPoint();\n    distanceSqr2 = p.lengthSquared();\n\n    // Ensure progress\n    if (distanceSqr2 >= distanceSqr1) {\n      // break;\n    }\n    distanceSqr1 = distanceSqr2;\n\n    // Get search direction.\n    const d = simplex.getSearchDirection();\n\n    // Ensure the search direction is numerically fit.\n    if (d.lengthSquared() < Math.EPSILON * Math.EPSILON) {\n      // The origin is probably contained by a line segment\n      // or triangle. Thus the shapes are overlapped.\n\n      // We can't return zero here even though there may be overlap.\n      // In case the simplex is a point, segment, or triangle it is difficult\n      // to determine if the origin is contained in the CSO or very close to it.\n      break;\n    }\n\n    // Compute a tentative new simplex vertex using support points.\n    const vertex = vertices[simplex.m_count]; // SimplexVertex\n\n    vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));\n    vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));\n\n    vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));\n    vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));\n\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n    ++stats.gjkIters;\n\n    // Check for duplicate support points. This is the main termination\n    // criteria.\n    let duplicate = false;\n    for (let i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n\n    // If we found a duplicate support point we must exit to avoid cycling.\n    if (duplicate) {\n      break;\n    }\n\n    // New vertex is ok and needed.\n    ++simplex.m_count;\n  }\n\n  stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);\n\n  // Prepare output.\n  simplex.getWitnessPoints(output.pointA, output.pointB);\n  output.distance = Vec2.distance(output.pointA, output.pointB);\n  output.iterations = iter;\n\n  // Cache the simplex.\n  simplex.writeCache(cache);\n\n  // Apply radii if requested.\n  if (input.useRadii) {\n    const rA = proxyA.m_radius;\n    const rB = proxyB.m_radius;\n\n    if (output.distance > rA + rB && output.distance > Math.EPSILON) {\n      // Shapes are still no overlapped.\n      // Move the witness points to the outer surface.\n      output.distance -= rA + rB;\n      const normal = Vec2.sub(output.pointB, output.pointA);\n      normal.normalize();\n      output.pointA.addMul(rA, normal);\n      output.pointB.subMul(rB, normal);\n    } else {\n      // Shapes are overlapped when radii are considered.\n      // Move the witness points to the middle.\n      const p = Vec2.mid(output.pointA, output.pointB);\n      output.pointA.setVec2(p);\n      output.pointB.setVec2(p);\n      output.distance = 0.0;\n    }\n  }\n}\n\n/**\n * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n */\nexport class DistanceProxy {\n  /** internal */ m_buffer: Vec2[];\n  /** internal */ m_vertices: Vec2[];\n  /** internal */ m_count: number;\n  /** internal */ m_radius: number;\n\n\n  constructor() {\n    this.m_buffer = []; // Vec2[2]\n    this.m_vertices = []; // Vec2[]\n    this.m_count = 0;\n    this.m_radius = 0;\n  }\n\n  /**\n   * Get the vertex count.\n   */\n  getVertexCount(): number {\n    return this.m_count;\n  }\n\n  /**\n   * Get a vertex by index. Used by Distance.\n   */\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * Get the supporting vertex index in the given direction.\n   */\n  getSupport(d: Vec2): number {\n    let bestIndex = 0;\n    let bestValue = Vec2.dot(this.m_vertices[0], d);\n    for (let i = 0; i < this.m_count; ++i) {\n      const value = Vec2.dot(this.m_vertices[i], d);\n      if (value > bestValue) {\n        bestIndex = i;\n        bestValue = value;\n      }\n    }\n    return bestIndex;\n  }\n\n  /**\n   * Get the supporting vertex in the given direction.\n   */\n  getSupportVertex(d: Vec2): Vec2 {\n    return this.m_vertices[this.getSupport(d)];\n  }\n\n  /**\n   * Initialize the proxy using the given shape. The shape must remain in scope\n   * while the proxy is in use.\n   */\n  set(shape: Shape, index: number): void {\n    // TODO remove, use shape instead\n    _ASSERT && common.assert(typeof shape.computeDistanceProxy === 'function');\n    shape.computeDistanceProxy(this, index);\n  }\n}\n\nclass SimplexVertex {\n  /** support point in proxyA */\n  wA: Vec2 = Vec2.zero();\n  /** wA index */\n  indexA: number;\n\n  /** support point in proxyB */\n  wB: Vec2 = Vec2.zero();\n  /** wB index */\n  indexB: number;\n\n  /** wB - wA; */\n  w: Vec2 = Vec2.zero();\n  /** barycentric coordinate for closest point */\n  a: number;\n\n  set(v: SimplexVertex): void {\n    this.indexA = v.indexA;\n    this.indexB = v.indexB;\n    this.wA = Vec2.clone(v.wA);\n    this.wB = Vec2.clone(v.wB);\n    this.w = Vec2.clone(v.w);\n    this.a = v.a;\n  }\n}\n\nclass Simplex {\n  m_v1: SimplexVertex;\n  m_v2: SimplexVertex;\n  m_v3: SimplexVertex;\n  m_v: SimplexVertex[];\n  m_count: number;\n\n  constructor() {\n    this.m_v1 = new SimplexVertex();\n    this.m_v2 = new SimplexVertex();\n    this.m_v3 = new SimplexVertex();\n    this.m_v = [ this.m_v1, this.m_v2, this.m_v3 ];\n    this.m_count;\n  }\n\n  /** @internal */\n  toString(): string {\n    if (this.m_count === 3) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n        this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n      ].toString();\n\n    } else if (this.m_count === 2) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n      ].toString();\n\n    } else if (this.m_count === 1) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n      ].toString();\n\n    } else {\n      return \"+\" + this.m_count;\n    }\n  }\n\n  readCache(cache: SimplexCache, proxyA: DistanceProxy, transformA: Transform, proxyB: DistanceProxy, transformB: Transform): void {\n    _ASSERT && common.assert(cache.count <= 3);\n\n    // Copy data from cache.\n    this.m_count = cache.count;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = this.m_v[i];\n      v.indexA = cache.indexA[i];\n      v.indexB = cache.indexB[i];\n      const wALocal = proxyA.getVertex(v.indexA);\n      const wBLocal = proxyB.getVertex(v.indexB);\n      v.wA = Transform.mulVec2(transformA, wALocal);\n      v.wB = Transform.mulVec2(transformB, wBLocal);\n      v.w = Vec2.sub(v.wB, v.wA);\n      v.a = 0.0;\n    }\n\n    // Compute the new simplex metric, if it is substantially different than\n    // old metric then flush the simplex.\n    if (this.m_count > 1) {\n      const metric1 = cache.metric;\n      const metric2 = this.getMetric();\n      if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2\n        || metric2 < Math.EPSILON) {\n        // Reset the simplex.\n        this.m_count = 0;\n      }\n    }\n\n    // If the cache is empty or invalid...\n    if (this.m_count === 0) {\n      const v = this.m_v[0];\n      v.indexA = 0;\n      v.indexB = 0;\n      const wALocal = proxyA.getVertex(0);\n      const wBLocal = proxyB.getVertex(0);\n      v.wA = Transform.mulVec2(transformA, wALocal);\n      v.wB = Transform.mulVec2(transformB, wBLocal);\n      v.w = Vec2.sub(v.wB, v.wA);\n      v.a = 1.0;\n      this.m_count = 1;\n    }\n  }\n\n  writeCache(cache: SimplexCache): void {\n    cache.metric = this.getMetric();\n    cache.count = this.m_count;\n    for (let i = 0; i < this.m_count; ++i) {\n      cache.indexA[i] = this.m_v[i].indexA;\n      cache.indexB[i] = this.m_v[i].indexB;\n    }\n  }\n\n  getSearchDirection(): Vec2 {\n    switch (this.m_count) {\n      case 1:\n        return Vec2.neg(this.m_v1.w);\n\n      case 2: {\n        const e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);\n        const sgn = Vec2.crossVec2Vec2(e12, Vec2.neg(this.m_v1.w));\n        if (sgn > 0.0) {\n          // Origin is left of e12.\n          return Vec2.crossNumVec2(1.0, e12);\n        } else {\n          // Origin is right of e12.\n          return Vec2.crossVec2Num(e12, 1.0);\n        }\n      }\n\n      default:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n    }\n  }\n\n  getClosestPoint(): Vec2 {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n\n      case 1:\n        return Vec2.clone(this.m_v1.w);\n\n      case 2:\n        return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);\n\n      case 3:\n        return Vec2.zero();\n\n      default:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n    }\n  }\n\n  getWitnessPoints(pA: Vec2, pB: Vec2): void {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        break;\n\n      case 1:\n        pA.setVec2(this.m_v1.wA);\n        pB.setVec2(this.m_v1.wB);\n        break;\n\n      case 2:\n        pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n        pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);\n        break;\n\n      case 3:\n        pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n        pA.addMul(this.m_v3.a, this.m_v3.wA);\n        pB.setVec2(pA);\n        break;\n\n      default:\n        _ASSERT && common.assert(false);\n        break;\n    }\n  }\n\n  getMetric(): number {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        return 0.0;\n\n      case 1:\n        return 0.0;\n\n      case 2:\n        return Vec2.distance(this.m_v1.w, this.m_v2.w);\n\n      case 3:\n        return Vec2.crossVec2Vec2(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w,\n          this.m_v1.w));\n\n      default:\n        _ASSERT && common.assert(false);\n        return 0.0;\n    }\n  }\n\n  solve(): void {\n    switch (this.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        this.solve2();\n        break;\n\n      case 3:\n        this.solve3();\n        break;\n\n      default:\n        _ASSERT && common.assert(false);\n    }\n  }\n\n// Solve a line segment using barycentric coordinates.\n//\n// p = a1 * w1 + a2 * w2\n// a1 + a2 = 1\n//\n// The vector from the origin to the closest point on the line is\n// perpendicular to the line.\n// e12 = w2 - w1\n// dot(p, e) = 0\n// a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n//\n// 2-by-2 linear system\n// [1 1 ][a1] = [1]\n// [w1.e12 w2.e12][a2] = [0]\n//\n// Define\n// d12_1 = dot(w2, e12)\n// d12_2 = -dot(w1, e12)\n// d12 = d12_1 + d12_2\n//\n// Solution\n// a1 = d12_1 / d12\n// a2 = d12_2 / d12\n  solve2(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const e12 = Vec2.sub(w2, w1);\n\n    // w1 region\n    const d12_2 = -Vec2.dot(w1, e12);\n    if (d12_2 <= 0.0) {\n      // a2 <= 0, so we clamp it to 0\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // w2 region\n    const d12_1 = Vec2.dot(w2, e12);\n    if (d12_1 <= 0.0) {\n      // a1 <= 0, so we clamp it to 0\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // Must be in e12 region.\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\n    this.m_v1.a = d12_1 * inv_d12;\n    this.m_v2.a = d12_2 * inv_d12;\n    this.m_count = 2;\n  }\n\n// Possible regions:\n// - points[2]\n// - edge points[0]-points[2]\n// - edge points[1]-points[2]\n// - inside the triangle\n  solve3(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const w3 = this.m_v3.w;\n\n    // Edge12\n    // [1 1 ][a1] = [1]\n    // [w1.e12 w2.e12][a2] = [0]\n    // a3 = 0\n    const e12 = Vec2.sub(w2, w1);\n    const w1e12 = Vec2.dot(w1, e12);\n    const w2e12 = Vec2.dot(w2, e12);\n    const d12_1 = w2e12;\n    const d12_2 = -w1e12;\n\n    // Edge13\n    // [1 1 ][a1] = [1]\n    // [w1.e13 w3.e13][a3] = [0]\n    // a2 = 0\n    const e13 = Vec2.sub(w3, w1);\n    const w1e13 = Vec2.dot(w1, e13);\n    const w3e13 = Vec2.dot(w3, e13);\n    const d13_1 = w3e13;\n    const d13_2 = -w1e13;\n\n    // Edge23\n    // [1 1 ][a2] = [1]\n    // [w2.e23 w3.e23][a3] = [0]\n    // a1 = 0\n    const e23 = Vec2.sub(w3, w2);\n    const w2e23 = Vec2.dot(w2, e23);\n    const w3e23 = Vec2.dot(w3, e23);\n    const d23_1 = w3e23;\n    const d23_2 = -w2e23;\n\n    // Triangle123\n    const n123 = Vec2.crossVec2Vec2(e12, e13);\n\n    const d123_1 = n123 * Vec2.crossVec2Vec2(w2, w3);\n    const d123_2 = n123 * Vec2.crossVec2Vec2(w3, w1);\n    const d123_3 = n123 * Vec2.crossVec2Vec2(w1, w2);\n\n    // w1 region\n    if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // e12\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n      const inv_d12 = 1.0 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n      return;\n    }\n\n    // e13\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n      const inv_d13 = 1.0 / (d13_1 + d13_2);\n      this.m_v1.a = d13_1 * inv_d13;\n      this.m_v3.a = d13_2 * inv_d13;\n      this.m_count = 2;\n      this.m_v2.set(this.m_v3);\n      return;\n    }\n\n    // w2 region\n    if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // w3 region\n    if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n      this.m_v3.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // e23\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n      const inv_d23 = 1.0 / (d23_1 + d23_2);\n      this.m_v2.a = d23_1 * inv_d23;\n      this.m_v3.a = d23_2 * inv_d23;\n      this.m_count = 2;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // Must be in triangle123\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n    this.m_v1.a = d123_1 * inv_d123;\n    this.m_v2.a = d123_2 * inv_d123;\n    this.m_v3.a = d123_3 * inv_d123;\n    this.m_count = 3;\n  }\n}\n\n\n/**\n * Determine if two generic shapes overlap.\n */\nexport function testOverlap(shapeA: Shape, indexA: number, shapeB: Shape, indexB: number, xfA: Transform, xfB: Transform): boolean {\n  const input = new DistanceInput();\n  input.proxyA.set(shapeA, indexA);\n  input.proxyB.set(shapeB, indexB);\n  input.transformA = xfA;\n  input.transformB = xfB;\n  input.useRadii = true;\n\n  const cache = new SimplexCache();\n  const output = new DistanceOutput();\n\n  Distance(output, cache, input);\n\n  return output.distance < 10.0 * Math.EPSILON;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Settings } from '../Settings';\n\nimport common from '../util/common';\nimport { stats } from '../util/stats';\nimport Timer from '../util/Timer';\n\nimport { Math } from '../common/Math';\nimport { Vec2 } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\n\nimport { Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache } from './Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Input parameters for TimeOfImpact.\n */\nexport class TOIInput {\n  proxyA: DistanceProxy = new DistanceProxy();\n  proxyB: DistanceProxy = new DistanceProxy();\n  sweepA: Sweep = new Sweep();\n  sweepB: Sweep = new Sweep();\n  /** defines sweep interval [0, tMax] */\n  tMax: number | undefined;\n}\n\nexport enum TOIOutputState {\n  e_unknown = 0,\n  e_failed = 1,\n  e_overlapped = 2,\n  e_touching = 3,\n  e_separated = 4,\n}\n\n/**\n * Output parameters for TimeOfImpact.\n */\nexport class TOIOutput {\n  state: TOIOutputState | undefined;\n  t: number | undefined;\n}\n\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\n\n/**\n * Compute the upper bound on time before two shapes penetrate. Time is\n * represented as a fraction between [0,tMax]. This uses a swept separating axis\n * and may miss some intermediate, non-tunneling collision. If you change the\n * time interval, you should call this function again.\n *\n * Note: use Distance to compute the contact point and normal at the time of\n * impact.\n *\n * CCD via the local separating axis method. This seeks progression by computing\n * the largest time at which separation is maintained.\n */\nexport function TimeOfImpact(output: TOIOutput, input: TOIInput): void {\n  const timer = Timer.now();\n\n  ++stats.toiCalls;\n\n  output.state = TOIOutputState.e_unknown;\n  output.t = input.tMax;\n\n  const proxyA = input.proxyA; // DistanceProxy\n  const proxyB = input.proxyB; // DistanceProxy\n\n  const sweepA = input.sweepA; // Sweep\n  const sweepB = input.sweepB; // Sweep\n\n  // Large rotations can make the root finder fail, so we normalize the\n  // sweep angles.\n  sweepA.normalize();\n  sweepB.normalize();\n\n  const tMax = input.tMax;\n\n  const totalRadius = proxyA.m_radius + proxyB.m_radius;\n  const target = Math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n  const tolerance = 0.25 * Settings.linearSlop;\n  _ASSERT && common.assert(target > tolerance);\n\n  let t1 = 0.0;\n  const k_maxIterations = Settings.maxTOIIterations;\n  let iter = 0;\n\n  // Prepare input for distance query.\n  const cache = new SimplexCache();\n\n  const distanceInput = new DistanceInput();\n  distanceInput.proxyA = input.proxyA;\n  distanceInput.proxyB = input.proxyB;\n  distanceInput.useRadii = false;\n\n  // The outer loop progressively attempts to compute new separating axes.\n  // This loop terminates when an axis is repeated (no progress is made).\n  while (true) {\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    sweepA.getTransform(xfA, t1);\n    sweepB.getTransform(xfB, t1);\n\n    // Get the distance between shapes. We can also use the results\n    // to get a separating axis.\n    distanceInput.transformA = xfA;\n    distanceInput.transformB = xfB;\n    const distanceOutput = new DistanceOutput();\n    Distance(distanceOutput, cache, distanceInput);\n\n    // If the shapes are overlapped, we give up on continuous collision.\n    if (distanceOutput.distance <= 0.0) {\n      // Failure!\n      output.state = TOIOutputState.e_overlapped;\n      output.t = 0.0;\n      break;\n    }\n\n    if (distanceOutput.distance < target + tolerance) {\n      // Victory!\n      output.state = TOIOutputState.e_touching;\n      output.t = t1;\n      break;\n    }\n\n    // Initialize the separating axis.\n    const fcn = new SeparationFunction();\n    fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n\n    // if (false) {\n    //   // Dump the curve seen by the root finder\n    //   const N = 100;\n    //   const dx = 1.0 / N;\n    //   const xs = []; // [ N + 1 ];\n    //   const fs = []; // [ N + 1 ];\n    //   const x = 0.0;\n    //   for (const i = 0; i <= N; ++i) {\n    //     sweepA.getTransform(xfA, x);\n    //     sweepB.getTransform(xfB, x);\n    //     const f = fcn.evaluate(xfA, xfB) - target;\n    //     printf(\"%g %g\\n\", x, f);\n    //     xs[i] = x;\n    //     fs[i] = f;\n    //     x += dx;\n    //   }\n    // }\n\n    // Compute the TOI on the separating axis. We do this by successively\n    // resolving the deepest point. This loop is bounded by the number of\n    // vertices.\n    let done = false;\n    let t2 = tMax;\n    let pushBackIter = 0;\n    while (true) {\n      // Find the deepest point at t2. Store the witness point indices.\n      let s2 = fcn.findMinSeparation(t2);\n      // const indexA = fcn.indexA;\n      // const indexB = fcn.indexB;\n\n      // Is the final configuration separated?\n      if (s2 > target + tolerance) {\n        // Victory!\n        output.state = TOIOutputState.e_separated;\n        output.t = tMax;\n        done = true;\n        break;\n      }\n\n      // Has the separation reached tolerance?\n      if (s2 > target - tolerance) {\n        // Advance the sweeps\n        t1 = t2;\n        break;\n      }\n\n      // Compute the initial separation of the witness points.\n      let s1 = fcn.evaluate(t1);\n      // const indexA = fcn.indexA;\n      // const indexB = fcn.indexB;\n\n      // Check for initial overlap. This might happen if the root finder\n      // runs out of iterations.\n      if (s1 < target - tolerance) {\n        output.state = TOIOutputState.e_failed;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Check for touching\n      if (s1 <= target + tolerance) {\n        // Victory! t1 should hold the TOI (could be 0.0).\n        output.state = TOIOutputState.e_touching;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Compute 1D root of: f(x) - target = 0\n      let rootIterCount = 0;\n      let a1 = t1;\n      let a2 = t2;\n      while (true) {\n        // Use a mix of the secant rule and bisection.\n        let t;\n        if (rootIterCount & 1) {\n          // Secant rule to improve convergence.\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          // Bisection to guarantee progress.\n          t = 0.5 * (a1 + a2);\n        }\n\n        ++rootIterCount;\n        ++stats.toiRootIters;\n\n        const s = fcn.evaluate(t);\n        const indexA = fcn.indexA;\n        const indexB = fcn.indexB;\n\n        if (Math.abs(s - target) < tolerance) {\n          // t2 holds a tentative value for t1\n          t2 = t;\n          break;\n        }\n\n        // Ensure we continue to bracket the root.\n        if (s > target) {\n          a1 = t;\n          s1 = s;\n        } else {\n          a2 = t;\n          s2 = s;\n        }\n\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n\n      stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);\n\n      ++pushBackIter;\n\n      if (pushBackIter === Settings.maxPolygonVertices) {\n        break;\n      }\n    }\n\n    ++iter;\n    ++stats.toiIters;\n\n    if (done) {\n      break;\n    }\n\n    if (iter === k_maxIterations) {\n      // Root finder got stuck. Semi-victory.\n      output.state = TOIOutputState.e_failed;\n      output.t = t1;\n      break;\n    }\n  }\n\n  stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);\n\n  const time = Timer.diff(timer);\n  stats.toiMaxTime = Math.max(stats.toiMaxTime, time);\n  stats.toiTime += time;\n}\n\nenum SeparationFunctionType {\n  e_points = 1,\n  e_faceA = 2,\n  e_faceB = 3,\n}\n\nclass SeparationFunction {\n  m_proxyA: DistanceProxy = new DistanceProxy();\n  m_proxyB: DistanceProxy = new DistanceProxy();\n  m_sweepA: Sweep;\n  m_sweepB: Sweep;\n  indexA: number;\n  indexB: number;\n  m_type: SeparationFunctionType;\n  m_localPoint: Vec2 = Vec2.zero();\n  m_axis: Vec2 = Vec2.zero();\n\n  // TODO_ERIN might not need to return the separation\n\n  initialize(cache: SimplexCache, proxyA: DistanceProxy, sweepA: Sweep, proxyB: DistanceProxy, sweepB: Sweep, t1: number): number {\n    this.m_proxyA = proxyA;\n    this.m_proxyB = proxyB;\n    const count = cache.count;\n    _ASSERT && common.assert(0 < count && count < 3);\n\n    this.m_sweepA = sweepA;\n    this.m_sweepB = sweepB;\n\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    this.m_sweepA.getTransform(xfA, t1);\n    this.m_sweepB.getTransform(xfB, t1);\n\n    if (count === 1) {\n      this.m_type = SeparationFunctionType.e_points;\n      const localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n      const pointB = Transform.mulVec2(xfB, localPointB);\n      this.m_axis.setCombine(1, pointB, -1, pointA);\n      const s = this.m_axis.normalize();\n      return s;\n\n    } else if (cache.indexA[0] === cache.indexA[1]) {\n      // Two points on B and one on A.\n      this.m_type = SeparationFunctionType.e_faceB;\n      const localPointB1 = proxyB.getVertex(cache.indexB[0]);\n      const localPointB2 = proxyB.getVertex(cache.indexB[1]);\n\n      this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointB2, localPointB1), 1.0);\n      this.m_axis.normalize();\n      const normal = Rot.mulVec2(xfB.q, this.m_axis);\n\n      this.m_localPoint = Vec2.mid(localPointB1, localPointB2);\n      const pointB = Transform.mulVec2(xfB, this.m_localPoint);\n\n      const localPointA = proxyA.getVertex(cache.indexA[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n\n      let s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n      if (s < 0.0) {\n        this.m_axis = Vec2.neg(this.m_axis);\n        s = -s;\n      }\n      return s;\n\n    } else {\n      // Two points on A and one or two points on B.\n      this.m_type = SeparationFunctionType.e_faceA;\n      const localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n\n      this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointA2, localPointA1), 1.0);\n      this.m_axis.normalize();\n      const normal = Rot.mulVec2(xfA.q, this.m_axis);\n\n      this.m_localPoint = Vec2.mid(localPointA1, localPointA2);\n      const pointA = Transform.mulVec2(xfA, this.m_localPoint);\n\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      const pointB = Transform.mulVec2(xfB, localPointB);\n\n      let s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n      if (s < 0.0) {\n        this.m_axis = Vec2.neg(this.m_axis);\n        s = -s;\n      }\n      return s;\n    }\n  }\n\n  compute(find: boolean, t: number): number {\n    // It was findMinSeparation and evaluate\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    this.m_sweepA.getTransform(xfA, t);\n    this.m_sweepB.getTransform(xfB, t);\n\n    switch (this.m_type) {\n      case SeparationFunctionType.e_points: {\n        if (find) {\n          const axisA = Rot.mulTVec2(xfA.q, this.m_axis);\n          const axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));\n\n          this.indexA = this.m_proxyA.getSupport(axisA);\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        const localPointA = this.m_proxyA.getVertex(this.indexA);\n        const localPointB = this.m_proxyB.getVertex(this.indexB);\n\n        const pointA = Transform.mulVec2(xfA, localPointA);\n        const pointB = Transform.mulVec2(xfB, localPointB);\n\n        const sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceA: {\n        const normal = Rot.mulVec2(xfA.q, this.m_axis);\n        const pointA = Transform.mulVec2(xfA, this.m_localPoint);\n\n        if (find) {\n          const axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));\n\n          this.indexA = -1;\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        const localPointB = this.m_proxyB.getVertex(this.indexB);\n        const pointB = Transform.mulVec2(xfB, localPointB);\n\n        const sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceB: {\n        const normal = Rot.mulVec2(xfB.q, this.m_axis);\n        const pointB = Transform.mulVec2(xfB, this.m_localPoint);\n\n        if (find) {\n          const axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));\n\n          this.indexB = -1;\n          this.indexA = this.m_proxyA.getSupport(axisA);\n        }\n\n        const localPointA = this.m_proxyA.getVertex(this.indexA);\n        const pointA = Transform.mulVec2(xfA, localPointA);\n\n        const sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n        return sep;\n      }\n\n      default:\n        _ASSERT && common.assert(false);\n        if (find) {\n          this.indexA = -1;\n          this.indexB = -1;\n        }\n        return 0.0;\n    }\n  }\n\n  findMinSeparation(t: number): number {\n    return this.compute(true, t);\n  }\n\n  evaluate(t: number): number {\n    return this.compute(false, t);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\nimport { Transform } from '../common/Transform';\nimport { Math } from '../common/Math';\nimport { Rot } from '../common/Rot';\n\nexport enum ManifoldType {\n  e_circles = 0,\n  e_faceA = 1,\n  e_faceB = 2\n}\n\nexport enum ContactFeatureType {\n  e_vertex = 0,\n  e_face = 1\n}\n\n/**\n * This is used for determining the state of contact points.\n */\n export enum PointState {\n  /** Point does not exist */\n  nullState = 0,\n  /** Point was added in the update */\n  addState = 1,\n  /** Point persisted across the update */\n  persistState = 2,\n  /** Point was removed in the update */\n  removeState = 3\n}\n\n/**\n * Used for computing contact manifolds.\n */\n export class ClipVertex {\n  v: Vec2 = Vec2.zero();\n  id: ContactID = new ContactID();\n\n  set(o: ClipVertex): void {\n    this.v.setVec2(o.v);\n    this.id.set(o.id);\n  }\n}\n\n/**\n * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n * method of Contact subclasses.\n *\n * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n * with radius and e_circles point versus point with radius.\n *\n * We store contacts in this way so that position correction can account for\n * movement, which is critical for continuous physics. All contact scenarios\n * must be expressed in one of these types. This structure is stored across time\n * steps, so we keep it small.\n *\n * @prop type e_circle, e_faceA, e_faceB\n * @prop localPoint Usage depends on manifold type:<br>\n *       e_circles: the local center of circleA <br>\n *       e_faceA: the center of faceA <br>\n *       e_faceB: the center of faceB\n * @prop localNormal Usage depends on manifold type:<br>\n *       e_circles: not used <br>\n *       e_faceA: the normal on polygonA <br>\n *       e_faceB: the normal on polygonB\n * @prop points The points of contact {ManifoldPoint[]}\n * @prop pointCount The number of manifold points\n */\nexport class Manifold {\n  type: ManifoldType;\n  localNormal: Vec2 = Vec2.zero();\n  localPoint: Vec2 = Vec2.zero();\n  points: ManifoldPoint[] = [ new ManifoldPoint(), new ManifoldPoint() ];\n  pointCount: number = 0;\n\n  /**\n   * Evaluate the manifold with supplied transforms. This assumes modest motion\n   * from the original state. This does not change the point count, impulses, etc.\n   * The radii must come from the shapes that generated the manifold.\n   */\n  getWorldManifold(wm: WorldManifold | undefined, xfA: Transform, radiusA: number, xfB: Transform, radiusB: number): WorldManifold {\n    if (this.pointCount == 0) {\n      return;\n    }\n\n    wm = wm || new WorldManifold();\n\n    let normal = wm.normal;\n    const points = wm.points;\n    const separations = wm.separations;\n\n    // TODO: improve\n    switch (this.type) {\n      case ManifoldType.e_circles: {\n        normal = Vec2.neo(1.0, 0.0);\n        const pointA = Transform.mulVec2(xfA, this.localPoint);\n        const pointB = Transform.mulVec2(xfB, this.points[0].localPoint);\n        const dist = Vec2.sub(pointB, pointA);\n        if (Vec2.lengthSquared(dist) > Math.EPSILON * Math.EPSILON) {\n          normal.setVec2(dist);\n          normal.normalize();\n        }\n        const cA = pointA.clone().addMul(radiusA, normal);\n        const cB = pointB.clone().addMul(-radiusB, normal);\n        points[0] = Vec2.mid(cA, cB);\n        separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);\n        points.length = 1;\n        separations.length = 1;\n        break;\n      }\n\n      case ManifoldType.e_faceA: {\n        normal = Rot.mulVec2(xfA.q, this.localNormal);\n        const planePoint = Transform.mulVec2(xfA, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);\n          const cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n          const cB = Vec2.clone(clipPoint).subMul(radiusB, normal);\n          points[i] = Vec2.mid(cA, cB);\n          separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);\n        }\n        points.length = this.pointCount;\n        separations.length = this.pointCount;\n        break;\n      }\n\n      case ManifoldType.e_faceB: {\n        normal = Rot.mulVec2(xfB.q, this.localNormal);\n        const planePoint = Transform.mulVec2(xfB, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);\n          const cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n          const cA = Vec2.combine(1, clipPoint, -radiusA, normal);\n          points[i] = Vec2.mid(cA, cB);\n          separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);\n        }\n        points.length = this.pointCount;\n        separations.length = this.pointCount;\n        // Ensure normal points from A to B.\n        normal.mul(-1);\n        break;\n      }\n    }\n\n    wm.normal = normal;\n    wm.points = points;\n    wm.separations = separations;\n    return wm;\n  }\n\n  static clipSegmentToLine = clipSegmentToLine;\n  static ClipVertex = ClipVertex;\n  static getPointStates = getPointStates;\n  static PointState = PointState;\n}\n\n/**\n * A manifold point is a contact point belonging to a contact manifold. It holds\n * details related to the geometry and dynamics of the contact points.\n *\n * This structure is stored across time steps, so we keep it small.\n *\n * Note: impulses are used for internal caching and may not provide reliable\n * contact forces, especially for high speed collisions.\n */\nexport class ManifoldPoint {\n  /**\n   * Usage depends on manifold type.\n   *       e_circles: the local center of circleB,\n   *       e_faceA: the local center of cirlceB or the clip point of polygonB,\n   *       e_faceB: the clip point of polygonA.\n   */\n  localPoint: Vec2 = Vec2.zero();\n  /**\n   * The non-penetration impulse\n   */\n  normalImpulse: number = 0;\n  /**\n   * The friction impulse\n   */\n  tangentImpulse: number = 0;\n  /**\n   * Uniquely identifies a contact point between two shapes to facilatate warm starting\n   */\n  id: ContactID = new ContactID();\n}\n\n/**\n * Contact ids to facilitate warm starting.\n */\nexport class ContactID {\n  cf: ContactFeature = new ContactFeature();\n\n  /**\n   * Used to quickly compare contact ids.\n   */\n  get key(): number {\n    return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;\n  }\n\n  set(o: ContactID): void {\n    // this.key = o.key;\n    this.cf.set(o.cf);\n  }\n}\n\n/**\n * The features that intersect to form the contact point.\n */\nexport class ContactFeature {\n  /**\n   * Feature index on shapeA\n   */\n  indexA: number;\n  /**\n   * Feature index on shapeB\n   */\n  indexB: number;\n  /**\n   * The feature type on shapeA\n   */\n  typeA: ContactFeatureType;\n  /**\n   * The feature type on shapeB\n   */\n  typeB: ContactFeatureType;\n  set(o: ContactFeature): void {\n    this.indexA = o.indexA;\n    this.indexB = o.indexB;\n    this.typeA = o.typeA;\n    this.typeB = o.typeB;\n  }\n}\n\n/**\n * This is used to compute the current state of a contact manifold.\n */\nexport class WorldManifold {\n  /**\n   * World vector pointing from A to B\n   */\n  normal: Vec2;\n  /**\n   * World contact point (point of intersection)\n   */\n  points: Vec2[] = []; // [maxManifoldPoints]\n  /**\n   * A negative value indicates overlap, in meters\n   */\n  separations: number[] = []; // [maxManifoldPoints]\n}\n\n/**\n * Compute the point states given two manifolds. The states pertain to the\n * transition from manifold1 to manifold2. So state1 is either persist or remove\n * while state2 is either add or persist.\n */\nexport function getPointStates(\n  state1: PointState[],\n  state2: PointState[],\n  manifold1: Manifold,\n  manifold2: Manifold\n): void {\n  // state1, state2: PointState[Settings.maxManifoldPoints]\n\n  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n  // state1[i] = PointState.nullState;\n  // state2[i] = PointState.nullState;\n  // }\n\n  // Detect persists and removes.\n  for (let i = 0; i < manifold1.pointCount; ++i) {\n    const id = manifold1.points[i].id;\n\n    state1[i] = PointState.removeState;\n\n    for (let j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key == id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n\n  // Detect persists and adds.\n  for (let i = 0; i < manifold2.pointCount; ++i) {\n    const id = manifold2.points[i].id;\n\n    state2[i] = PointState.addState;\n\n    for (let j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key == id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n */\nexport function clipSegmentToLine(\n  vOut: ClipVertex[],\n  vIn: ClipVertex[],\n  normal: Vec2,\n  offset: number,\n  vertexIndexA: number\n): number {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = Vec2.dot(normal, vIn[0].v) - offset;\n  const distance1 = Vec2.dot(normal, vIn[1].v) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0.0)\n    vOut[numOut++].set(vIn[1]);\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);\n\n    // VertexA is hitting edgeB.\n    vOut[numOut].id.cf.indexA = vertexIndexA;\n    vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;\n    vOut[numOut].id.cf.typeA = ContactFeatureType.e_vertex;\n    vOut[numOut].id.cf.typeB = ContactFeatureType.e_face;\n    ++numOut;\n  }\n\n  return numOut;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Settings } from '../Settings';\nimport common from '../util/common';\nimport { Vec2 } from '../common/Vec2';\nimport { Math } from '../common/Math';\nimport { Body } from './Body';\nimport type { Contact } from './Contact';\nimport { Joint } from './Joint';\nimport { TimeOfImpact, TOIInput, TOIOutput, TOIOutputState } from '../collision/TimeOfImpact';\nimport { Distance, DistanceInput, DistanceOutput, SimplexCache } from '../collision/Distance';\nimport { World } from \"./World\";\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class TimeStep {\n  /** time step */\n  dt: number = 0;\n  /** inverse time step (0 if dt == 0) */\n  inv_dt: number = 0;\n  velocityIterations: number = 0;\n  positionIterations: number = 0;\n  warmStarting: boolean = false;\n  blockSolve: boolean = true;\n\n  /** timestep ratio for variable timestep */\n  inv_dt0: number = 0.0;\n  /** dt * inv_dt0 */\n  dtRatio: number = 1;\n\n  reset(dt: number): void {\n    if (this.dt > 0.0) {\n      this.inv_dt0 = this.inv_dt;\n    }\n    this.dt = dt;\n    this.inv_dt = dt == 0 ? 0 : 1 / dt;\n    this.dtRatio = dt * this.inv_dt0;\n  }\n}\n\n// reuse\nconst s_subStep = new TimeStep();\n\n/**\n * Contact impulses for reporting. Impulses are used instead of forces because\n * sub-step forces may approach infinity for rigid body collisions. These match\n * up one-to-one with the contact points in Manifold.\n */\nexport class ContactImpulse {\n  // TODO: merge with Contact class?\n\n  private readonly contact: Contact;\n  private readonly normals: number[];\n  private readonly tangents: number[];\n\n  constructor(contact: Contact) {\n    this.contact = contact;\n    this.normals = [];\n    this.tangents = [];\n  }\n\n  get normalImpulses(): number[] {\n    const contact = this.contact;\n    const normals = this.normals;\n    normals.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      normals.push(contact.v_points[p].normalImpulse);\n    }\n    return normals;\n  }\n\n  get tangentImpulses(): number[] {\n    const contact = this.contact;\n    const tangents = this.tangents;\n    tangents.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      tangents.push(contact.v_points[p].tangentImpulse);\n    }\n    return tangents;\n  }\n}\n\n/**\n * Finds and solves islands. An island is a connected subset of the world.\n */\nexport class Solver {\n  m_world: World;\n  m_stack: Body[];\n  m_bodies: Body[];\n  m_contacts: Contact[];\n  m_joints: Joint[];\n\n  constructor(world: World) {\n    this.m_world = world;\n    this.m_stack = [];\n    this.m_bodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n  }\n\n  clear(): void {\n    this.m_stack.length = 0;\n    this.m_bodies.length = 0;\n    this.m_contacts.length = 0;\n    this.m_joints.length = 0;\n  }\n\n  addBody(body: Body): void {\n    _ASSERT && common.assert(body instanceof Body, 'Not a Body!', body);\n    this.m_bodies.push(body);\n    // why?\n    // body.c_position.c.setZero();\n    // body.c_position.a = 0;\n    // body.c_velocity.v.setZero();\n    // body.c_velocity.w = 0;\n  }\n\n  addContact(contact: Contact): void {\n    // _ASSERT && common.assert(contact instanceof Contact, 'Not a Contact!', contact);\n    this.m_contacts.push(contact);\n  }\n\n  addJoint(joint: Joint): void {\n    _ASSERT && common.assert(joint instanceof Joint, 'Not a Joint!', joint);\n    this.m_joints.push(joint);\n  }\n\n  solveWorld(step: TimeStep): void {\n    const world = this.m_world;\n\n    // Clear all the island flags.\n    for (let b = world.m_bodyList; b; b = b.m_next) {\n      b.m_islandFlag = false;\n    }\n    for (let c = world.m_contactList; c; c = c.m_next) {\n      c.m_islandFlag = false;\n    }\n    for (let j = world.m_jointList; j; j = j.m_next) {\n      j.m_islandFlag = false;\n    }\n\n    // Build and simulate all awake islands.\n    const stack = this.m_stack;\n    let loop = -1;\n    for (let seed = world.m_bodyList; seed; seed = seed.m_next) {\n      loop++;\n      if (seed.m_islandFlag) {\n        continue;\n      }\n\n      if (seed.isAwake() == false || seed.isActive() == false) {\n        continue;\n      }\n\n      // The seed can be dynamic or kinematic.\n      if (seed.isStatic()) {\n        continue;\n      }\n\n      // Reset island and stack.\n      this.clear();\n\n      stack.push(seed);\n\n      seed.m_islandFlag = true;\n\n      // Perform a depth first search (DFS) on the constraint graph.\n      while (stack.length > 0) {\n        // Grab the next body off the stack and add it to the island.\n        const b = stack.pop();\n        _ASSERT && common.assert(b.isActive() == true);\n        this.addBody(b);\n\n        // Make sure the body is awake.\n        b.setAwake(true);\n\n        // To keep islands as small as possible, we don't\n        // propagate islands across static bodies.\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Search all contacts connected to this body.\n        for (let ce = b.m_contactList; ce; ce = ce.next) {\n          const contact = ce.contact;\n\n          // Has this contact already been added to an island?\n          if (contact.m_islandFlag) {\n            continue;\n          }\n\n          // Is this contact solid and touching?\n          if (contact.isEnabled() == false || contact.isTouching() == false) {\n            continue;\n          }\n\n          // Skip sensors.\n          const sensorA = contact.m_fixtureA.m_isSensor;\n          const sensorB = contact.m_fixtureB.m_isSensor;\n          if (sensorA || sensorB) {\n            continue;\n          }\n\n          this.addContact(contact);\n          contact.m_islandFlag = true;\n\n          const other = ce.other;\n\n          // Was the other body already added to this island?\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n\n        // Search all joints connect to this body.\n        for (let je = b.m_jointList; je; je = je.next) {\n          if (je.joint.m_islandFlag == true) {\n            continue;\n          }\n\n          const other = je.other;\n\n          // Don't simulate joints connected to inactive bodies.\n          if (other.isActive() == false) {\n            continue;\n          }\n\n          this.addJoint(je.joint);\n          je.joint.m_islandFlag = true;\n\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n      }\n\n      this.solveIsland(step);\n\n      // Post solve cleanup.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        // Allow static bodies to participate in other islands.\n        // TODO: are they added at all?\n        const b = this.m_bodies[i];\n        if (b.isStatic()) {\n          b.m_islandFlag = false;\n        }\n      }\n    }\n  }\n\n  solveIsland(step: TimeStep): void {\n    // B2: Island Solve\n    const world = this.m_world;\n    const gravity = world.m_gravity;\n    const allowSleep = world.m_allowSleep;\n\n    const h = step.dt;\n\n    // Integrate velocities and apply damping. Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.m_sweep.c);\n      const a = body.m_sweep.a;\n      const v = Vec2.clone(body.m_linearVelocity);\n      let w = body.m_angularVelocity;\n\n      // Store positions for continuous collision.\n      body.m_sweep.c0.setVec2(body.m_sweep.c);\n      body.m_sweep.a0 = body.m_sweep.a;\n\n      if (body.isDynamic()) {\n        // Integrate velocities.\n        v.addMul(h * body.m_gravityScale, gravity);\n        v.addMul(h * body.m_invMass, body.m_force);\n        w += h * body.m_invI * body.m_torque;\n        /**\n         * <pre>\n         * Apply damping.\n         * ODE: dv/dt + c * v = 0\n         * Solution: v(t) = v0 * exp(-c * t)\n         * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n         * v2 = exp(-c * dt) * v1\n         * Pade approximation:\n         * v2 = v1 * 1 / (1 + c * dt)\n         * </pre>\n         */\n        v.mul(1.0 / (1.0 + h * body.m_linearDamping));\n        w *= 1.0 / (1.0 + h * body.m_angularDamping);\n      }\n\n      body.c_position.c = c;\n      body.c_position.a = a;\n      body.c_velocity.v = v;\n      body.c_velocity.w = w;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(step);\n    }\n\n    _DEBUG && this.printBodies('M: ');\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(step);\n    }\n\n    _DEBUG && this.printBodies('R: ');\n\n    if (step.warmStarting) {\n      // Warm start.\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const contact = this.m_contacts[i];\n        contact.warmStartConstraint(step);\n      }\n    }\n\n    _DEBUG && this.printBodies('Q: ');\n\n    for (let i = 0; i < this.m_joints.length; ++i) {\n      const joint = this.m_joints[i];\n      joint.initVelocityConstraints(step);\n    }\n\n    _DEBUG && this.printBodies('E: ');\n\n    // Solve velocity constraints\n    for (let i = 0; i < step.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        joint.solveVelocityConstraints(step);\n      }\n\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(step);\n      }\n    }\n\n    _DEBUG && this.printBodies('D: ');\n\n    // Store impulses for warm starting\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.storeConstraintImpulses(step);\n    }\n\n    _DEBUG && this.printBodies('C: ');\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.c_position.c);\n      let a = body.c_position.a;\n      const v = Vec2.clone(body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      const translation = Vec2.mulNumVec2(h, v);\n      if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / translation.length();\n        v.mul(ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      c.addMul(h, v);\n      a += h * w;\n\n      body.c_position.c.setVec2(c);\n      body.c_position.a = a;\n      body.c_velocity.v.setVec2(v);\n      body.c_velocity.w = w;\n    }\n\n    _DEBUG && this.printBodies('B: ');\n\n    // Solve position constraints\n    let positionSolved = false;\n    for (let i = 0; i < step.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraint(step);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n\n      let jointsOkay = true;\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        const jointOkay = joint.solvePositionConstraints(step);\n        jointsOkay = jointsOkay && jointOkay;\n      }\n\n      if (contactsOkay && jointsOkay) {\n        // Exit early if the position errors are small.\n        positionSolved = true;\n        break;\n      }\n    }\n\n    _DEBUG && this.printBodies('L: ');\n\n    // Copy state buffers back to the bodies\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      body.m_sweep.c.setVec2(body.c_position.c);\n      body.m_sweep.a = body.c_position.a;\n      body.m_linearVelocity.setVec2(body.c_velocity.v);\n      body.m_angularVelocity = body.c_velocity.w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n\n    if (allowSleep) {\n      let minSleepTime = Infinity;\n\n      const linTolSqr = Settings.linearSleepToleranceSqr;\n      const angTolSqr = Settings.angularSleepToleranceSqr;\n\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        if (body.isStatic()) {\n          continue;\n        }\n\n        if ((body.m_autoSleepFlag == false)\n          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n          || (Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr)) {\n          body.m_sleepTime = 0.0;\n          minSleepTime = 0.0;\n        } else {\n          body.m_sleepTime += h;\n          minSleepTime = Math.min(minSleepTime, body.m_sleepTime);\n        }\n      }\n\n      if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n        for (let i = 0; i < this.m_bodies.length; ++i) {\n          const body = this.m_bodies[i];\n          body.setAwake(false);\n        }\n      }\n    }\n  }\n\n  /** @internal */\n  printBodies(tag: string): void {\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const b = this.m_bodies[i];\n      common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);\n    }\n  }\n\n  /**\n   * Find TOI contacts and solve them.\n   */\n  solveWorldTOI(step: TimeStep): void {\n    const world = this.m_world;\n\n    if (world.m_stepComplete) {\n      for (let b = world.m_bodyList; b; b = b.m_next) {\n        b.m_islandFlag = false;\n        b.m_sweep.alpha0 = 0.0;\n      }\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Invalidate TOI\n        c.m_toiFlag = false;\n        c.m_islandFlag = false;\n        c.m_toiCount = 0;\n        c.m_toi = 1.0;\n      }\n    }\n\n    // Find TOI events and solve them.\n    while (true) {\n      // Find the first TOI.\n      let minContact = null; // Contact\n      let minAlpha = 1.0;\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Is this contact disabled?\n        if (c.isEnabled() == false) {\n          continue;\n        }\n\n        // Prevent excessive sub-stepping.\n        if (c.m_toiCount > Settings.maxSubSteps) {\n          continue;\n        }\n\n        let alpha = 1.0;\n        if (c.m_toiFlag) {\n          // This contact has a valid cached TOI.\n          alpha = c.m_toi;\n        } else {\n          const fA = c.getFixtureA();\n          const fB = c.getFixtureB();\n\n          // Is there a sensor?\n          if (fA.isSensor() || fB.isSensor()) {\n            continue;\n          }\n\n          const bA = fA.getBody();\n          const bB = fB.getBody();\n\n          _ASSERT && common.assert(bA.isDynamic() || bB.isDynamic());\n\n          const activeA = bA.isAwake() && !bA.isStatic();\n          const activeB = bB.isAwake() && !bB.isStatic();\n\n          // Is at least one body active (awake and dynamic or kinematic)?\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n\n          const collideA = bA.isBullet() || !bA.isDynamic();\n          const collideB = bB.isBullet() || !bB.isDynamic();\n\n          // Are these two non-bullet dynamic bodies?\n          if (collideA == false && collideB == false) {\n            continue;\n          }\n\n          // Compute the TOI for this contact.\n          // Put the sweeps onto the same time interval.\n          let alpha0 = bA.m_sweep.alpha0;\n\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\n            alpha0 = bB.m_sweep.alpha0;\n            bA.m_sweep.advance(alpha0);\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\n            alpha0 = bA.m_sweep.alpha0;\n            bB.m_sweep.advance(alpha0);\n          }\n\n          _ASSERT && common.assert(alpha0 < 1.0);\n\n          const indexA = c.getChildIndexA();\n          const indexB = c.getChildIndexB();\n\n          const sweepA = bA.m_sweep;\n          const sweepB = bB.m_sweep;\n\n          // Compute the time of impact in interval [0, minTOI]\n          const input = new TOIInput(); // TODO: reuse\n          input.proxyA.set(fA.getShape(), indexA);\n          input.proxyB.set(fB.getShape(), indexB);\n          input.sweepA.set(bA.m_sweep);\n          input.sweepB.set(bB.m_sweep);\n          input.tMax = 1.0;\n\n          const output = new TOIOutput(); // TODO: reuse\n          TimeOfImpact(output, input);\n\n          // Beta is the fraction of the remaining portion of the [time?].\n          const beta = output.t;\n          if (output.state == TOIOutputState.e_touching) {\n            alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n          } else {\n            alpha = 1.0;\n          }\n\n          c.m_toi = alpha;\n          c.m_toiFlag = true;\n        }\n\n        if (alpha < minAlpha) {\n          // This is the minimum TOI found so far.\n          minContact = c;\n          minAlpha = alpha;\n        }\n      }\n\n      if (minContact == null || 1.0 - 10.0 * Math.EPSILON < minAlpha) {\n        // No more TOI events. Done!\n        world.m_stepComplete = true;\n        break;\n      }\n\n      // Advance the bodies to the TOI.\n      const fA = minContact.getFixtureA();\n      const fB = minContact.getFixtureB();\n      const bA = fA.getBody();\n      const bB = fB.getBody();\n\n      const backup1 = bA.m_sweep.clone();\n      const backup2 = bB.m_sweep.clone();\n\n      bA.advance(minAlpha);\n      bB.advance(minAlpha);\n\n      // The TOI contact likely has some new contact points.\n      minContact.update(world);\n      minContact.m_toiFlag = false;\n      ++minContact.m_toiCount;\n\n      // Is the contact solid?\n      if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n        // Restore the sweeps.\n        minContact.setEnabled(false);\n        bA.m_sweep.set(backup1);\n        bB.m_sweep.set(backup2);\n        bA.synchronizeTransform();\n        bB.synchronizeTransform();\n        continue;\n      }\n\n      bA.setAwake(true);\n      bB.setAwake(true);\n\n      // Build the island\n      this.clear();\n      this.addBody(bA);\n      this.addBody(bB);\n      this.addContact(minContact);\n\n      bA.m_islandFlag = true;\n      bB.m_islandFlag = true;\n      minContact.m_islandFlag = true;\n\n      // Get contacts on bodyA and bodyB.\n      const bodies = [ bA, bB ];\n      for (let i = 0; i < bodies.length; ++i) {\n        const body = bodies[i];\n        if (body.isDynamic()) {\n          for (let ce = body.m_contactList; ce; ce = ce.next) {\n            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n\n            const contact = ce.contact;\n\n            // Has this contact already been added to the island?\n            if (contact.m_islandFlag) {\n              continue;\n            }\n\n            // Only add if either is static, kinematic or bullet.\n            const other = ce.other;\n            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n              continue;\n            }\n\n            // Skip sensors.\n            const sensorA = contact.m_fixtureA.m_isSensor;\n            const sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n\n            // Tentatively advance the body to the TOI.\n            const backup = other.m_sweep.clone();\n            if (other.m_islandFlag == false) {\n              other.advance(minAlpha);\n            }\n\n            // Update the contact points\n            contact.update(world);\n\n            // Was the contact disabled by the user?\n            // Are there contact points?\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              other.m_sweep.set(backup);\n              other.synchronizeTransform();\n              continue;\n            }\n\n            // Add the contact to the island\n            contact.m_islandFlag = true;\n            this.addContact(contact);\n\n            // Has the other body already been added to the island?\n            if (other.m_islandFlag) {\n              continue;\n            }\n\n            // Add the other body to the island.\n            other.m_islandFlag = true;\n\n            if (!other.isStatic()) {\n              other.setAwake(true);\n            }\n\n            this.addBody(other);\n          }\n        }\n      }\n\n      s_subStep.reset((1.0 - minAlpha) * step.dt);\n      s_subStep.dtRatio = 1.0;\n      s_subStep.positionIterations = 20;\n      s_subStep.velocityIterations = step.velocityIterations;\n      s_subStep.warmStarting = false;\n\n      this.solveIslandTOI(s_subStep, bA, bB);\n\n      // Reset island flags and synchronize broad-phase proxies.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        body.m_islandFlag = false;\n\n        if (!body.isDynamic()) {\n          continue;\n        }\n\n        body.synchronizeFixtures();\n\n        // Invalidate all contact TOIs on this displaced body.\n        for (let ce = body.m_contactList; ce; ce = ce.next) {\n          ce.contact.m_toiFlag = false;\n          ce.contact.m_islandFlag = false;\n        }\n      }\n\n      // Commit fixture proxy movements to the broad-phase so that new contacts\n      // are created.\n      // Also, some contacts can be destroyed.\n      world.findNewContacts();\n\n      if (world.m_subStepping) {\n        world.m_stepComplete = false;\n        break;\n      }\n    }\n\n    if (_DEBUG) for (let b = world.m_bodyList; b; b = b.m_next) {\n      const c = b.m_sweep.c;\n      const a = b.m_sweep.a;\n      const v = b.m_linearVelocity;\n      const w = b.m_angularVelocity;\n    }\n  }\n\n  solveIslandTOI(subStep: TimeStep, toiA: Body, toiB: Body): void {\n    const world = this.m_world;\n\n    // Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n      body.c_position.c.setVec2(body.m_sweep.c);\n      body.c_position.a = body.m_sweep.a;\n      body.c_velocity.v.setVec2(body.m_linearVelocity);\n      body.c_velocity.w = body.m_angularVelocity;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(subStep);\n    }\n\n    // Solve position constraints.\n    for (let i = 0; i < subStep.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n      if (contactsOkay) {\n        break;\n      }\n    }\n\n    if (false) {\n      // Is the new position really safe?\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const c = this.m_contacts[i];\n        const fA = c.getFixtureA();\n        const fB = c.getFixtureB();\n\n        const bA = fA.getBody();\n        const bB = fB.getBody();\n\n        const indexA = c.getChildIndexA();\n        const indexB = c.getChildIndexB();\n\n        const input = new DistanceInput();\n        input.proxyA.set(fA.getShape(), indexA);\n        input.proxyB.set(fB.getShape(), indexB);\n        input.transformA = bA.getTransform();\n        input.transformB = bB.getTransform();\n        input.useRadii = false;\n\n        const output = new DistanceOutput();\n        const cache = new SimplexCache();\n        Distance(output, cache, input);\n\n        if (output.distance == 0 || cache.count == 3) {\n          cache.count += 0;\n        }\n      }\n    }\n\n    // Leap of faith to new safe state.\n    toiA.m_sweep.c0.setVec2(toiA.c_position.c);\n    toiA.m_sweep.a0 = toiA.c_position.a;\n    toiB.m_sweep.c0.setVec2(toiB.c_position.c);\n    toiB.m_sweep.a0 = toiB.c_position.a;\n\n    // No warm starting is needed for TOI events because warm\n    // starting impulses were applied in the discrete solver.\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(subStep);\n    }\n\n    // Solve velocity constraints.\n    for (let i = 0; i < subStep.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(subStep);\n      }\n    }\n\n    // Don't store the TOI contact forces for warm starting\n    // because they can be quite large.\n\n    const h = subStep.dt;\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.c_position.c);\n      let a = body.c_position.a;\n      const v = Vec2.clone(body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      const translation = Vec2.mulNumVec2(h, v);\n      if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / translation.length();\n        v.mul(ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      c.addMul(h, v);\n      a += h * w;\n\n      body.c_position.c = c;\n      body.c_position.a = a;\n      body.c_velocity.v = v;\n      body.c_velocity.w = w;\n\n      // Sync bodies\n      body.m_sweep.c = c;\n      body.m_sweep.a = a;\n      body.m_linearVelocity = v;\n      body.m_angularVelocity = w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n  }\n\n  /** @internal */\n  postSolveIsland(): void {\n    for (let c = 0; c < this.m_contacts.length; ++c) {\n      const contact = this.m_contacts[c];\n      this.m_world.postSolve(contact, contact.m_impulse);\n    }\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Vec2 } from './Vec2';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 2-by-2 matrix. Stored in column-major order.\n */\nexport class Mat22 {\n  ex: Vec2;\n  ey: Vec2;\n\n  constructor(a: number, b: number, c: number, d: number);\n  constructor(a: { x: number; y: number }, b: { x: number; y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(a?, b?, c?, d?) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec2.clone(a);\n      this.ey = Vec2.clone(b);\n    } else if (typeof a === 'number') {\n      this.ex = Vec2.neo(a, c);\n      this.ey = Vec2.neo(b, d);\n    } else {\n      this.ex = Vec2.zero();\n      this.ey = Vec2.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Mat22.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Mat22!');\n    }\n  }\n\n  set(a: Mat22): void;\n  set(a: Vec2, b: Vec2): void;\n  set(a: number, b: number, c: number, d: number): void;\n  // tslint:disable-next-line:typedef\n  set(a, b?, c?, d?): void {\n    if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n      && typeof d === 'number') {\n      this.ex.setNum(a, c);\n      this.ey.setNum(b, d);\n\n    } else if (typeof a === 'object' && typeof b === 'object') {\n      this.ex.setVec2(a);\n      this.ey.setVec2(b);\n\n    } else if (typeof a === 'object') {\n      _ASSERT && Mat22.assert(a);\n      this.ex.setVec2(a.ex);\n      this.ey.setVec2(a.ey);\n\n    } else {\n      _ASSERT && common.assert(false);\n    }\n  }\n\n  setIdentity(): void {\n    this.ex.x = 1.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 1.0;\n  }\n\n  setZero(): void {\n    this.ex.x = 0.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 0.0;\n  }\n\n  getInverse(): Mat22 {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const imx = new Mat22();\n    imx.ex.x = det * d;\n    imx.ey.x = -det * b;\n    imx.ex.y = -det * c;\n    imx.ey.y = det * a;\n    return imx;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const w = Vec2.zero();\n    w.x = det * (d * v.x - b * v.y);\n    w.y = det * (a * v.y - c * v.x);\n    return w;\n  }\n\n  /**\n   * Multiply a matrix times a vector. If a rotation matrix is provided, then this\n   * transforms the vector from one frame to another.\n   */\n  static mul(mx: Mat22, my: Mat22): Mat22;\n  static mul(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(mx, v) {\n    if (v && 'x' in v && 'y' in v) {\n      _ASSERT && Vec2.assert(v);\n      const x = mx.ex.x * v.x + mx.ey.x * v.y;\n      const y = mx.ex.y * v.x + mx.ey.y * v.y;\n      return Vec2.neo(x, y);\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n      const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n      const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n      const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n      const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n      return new Mat22(a, b, c, d);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const x = mx.ex.x * v.x + mx.ey.x * v.y;\n    const y = mx.ex.y * v.x + mx.ey.y * v.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(v);\n    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n    const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n    const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n    const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n    const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n    return new Mat22(a, b, c, d);\n  }\n\n  /**\n   * Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n   * then this transforms the vector from one frame to another (inverse\n   * transform).\n   */\n  static mulT(mx: Mat22, my: Mat22): Mat22;\n  static mulT(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(mx, v) {\n    if (v && 'x' in v && 'y' in v) { // Vec2\n      _ASSERT && Vec2.assert(v);\n      return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n      const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n      return new Mat22(c1, c2);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulTVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n  }\n\n  static mulTMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Mat22.assert(v);\n    const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n    const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n    return new Mat22(c1, c2);\n  }\n\n  static abs(mx: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n  }\n\n  static add(mx1: Mat22, mx2: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx1);\n    _ASSERT && Mat22.assert(mx2);\n    return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { ShapeType } from \"../collision/Shape\";\nimport common from '../util/common';\nimport { Math } from '../common/Math';\nimport { Vec2 } from '../common/Vec2';\nimport { Transform } from '../common/Transform';\nimport { Mat22 } from '../common/Mat22';\nimport { Rot } from '../common/Rot';\nimport { Settings } from '../Settings';\nimport { Manifold, ManifoldType, WorldManifold } from '../collision/Manifold';\nimport { testOverlap } from '../collision/Distance';\nimport { Fixture } from \"./Fixture\";\nimport { Body } from \"./Body\";\nimport { ContactImpulse, TimeStep } from \"./Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst DEBUG_SOLVER = false;\n\n/**\n * A contact edge is used to connect bodies and contacts together in a contact\n * graph where each body is a node and each contact is an edge. A contact edge\n * belongs to a doubly linked list maintained in each attached body. Each\n * contact has two contact nodes, one for each attached body.\n *\n * @prop {Contact} contact The contact\n * @prop {ContactEdge} prev The previous contact edge in the body's contact list\n * @prop {ContactEdge} next The next contact edge in the body's contact list\n * @prop {Body} other Provides quick access to the other body attached.\n */\nexport class ContactEdge {\n  contact: Contact;\n  prev: ContactEdge | undefined;\n  next: ContactEdge | undefined;\n  other: Body | undefined;\n  constructor(contact: Contact) {\n    this.contact = contact;\n  }\n}\n\nexport type EvaluateFunction = (\n  manifold: Manifold,\n  xfA: Transform,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: Transform,\n  fixtureB: Fixture,\n  indexB: number\n) => void;\n\nexport type ContactCallback = (\n  manifold: Manifold,\n  xfA: Transform,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: Transform,\n  fixtureB: Fixture,\n  indexB: number\n) => void /* & { destroyFcn?: (contact: Contact) => void }*/;\n\n\n/**\n * Friction mixing law. The idea is to allow either fixture to drive the\n * restitution to zero. For example, anything slides on ice.\n */\nexport function mixFriction(friction1: number, friction2: number): number {\n  return Math.sqrt(friction1 * friction2);\n}\n\n/**\n * Restitution mixing law. The idea is allow for anything to bounce off an\n * inelastic surface. For example, a superball bounces on anything.\n */\nexport function mixRestitution(restitution1: number, restitution2: number): number {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\n// TODO: move this to Settings?\nconst s_registers = [];\n\n// TODO: merge with ManifoldPoint?\nexport class VelocityConstraintPoint {\n  rA: Vec2 = Vec2.zero();\n  rB: Vec2 = Vec2.zero();\n  normalImpulse: number = 0;\n  tangentImpulse: number = 0;\n  normalMass: number = 0;\n  tangentMass: number = 0;\n  velocityBias: number = 0;\n}\n\n/**\n * The class manages contact between two shapes. A contact exists for each\n * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n * object may exist that has no contact points.\n */\nexport class Contact {\n  /** @internal */\n  m_nodeA: ContactEdge;\n  /** @internal */\n  m_nodeB: ContactEdge;\n  /** @internal */\n  m_fixtureA: Fixture;\n  /** @internal */\n  m_fixtureB: Fixture;\n  /** @internal */\n  m_indexA: number;\n  /** @internal */\n  m_indexB: number;\n  /** @internal */\n  m_evaluateFcn: EvaluateFunction;\n  /** @internal */\n  m_manifold: Manifold = new Manifold();\n  /** @internal */\n  m_prev: Contact | null = null;\n  /** @internal */\n  m_next: Contact | null = null;\n  /** @internal */\n  m_toi: number = 1.0;\n  /** @internal */\n  m_toiCount: number = 0;\n  /** @internal This contact has a valid TOI in m_toi */\n  m_toiFlag: boolean = false;\n  /** @internal */\n  m_friction: number;\n  /** @internal */\n  m_restitution: number;\n  /** @internal */\n  m_tangentSpeed: number = 0.0;\n  /** @internal This contact can be disabled (by user) */\n  m_enabledFlag: boolean = true;\n  /** @internal Used when crawling contact graph when forming islands. */\n  m_islandFlag: boolean = false;\n  /** @internal Set when the shapes are touching. */\n  m_touchingFlag: boolean = false;\n  /** @internal This contact needs filtering because a fixture filter was changed. */\n  m_filterFlag: boolean = false;\n  /** @internal This bullet contact had a TOI event */\n  m_bulletHitFlag: boolean = false;\n\n  /** @internal Contact reporting impulse object cache */\n  m_impulse: ContactImpulse = new ContactImpulse(this);\n\n  // VelocityConstraint\n  /** @internal */ v_points: VelocityConstraintPoint[] = []; // [maxManifoldPoints];\n  /** @internal */ v_normal: Vec2 = Vec2.zero();\n  /** @internal */ v_normalMass: Mat22 = new Mat22();\n  /** @internal */ v_K: Mat22 = new Mat22();\n  /** @internal */ v_pointCount: number;\n  /** @internal */ v_tangentSpeed: number | undefined;\n  /** @internal */ v_friction: number | undefined;\n  /** @internal */ v_restitution: number | undefined;\n  /** @internal */ v_invMassA: number | undefined;\n  /** @internal */ v_invMassB: number | undefined;\n  /** @internal */ v_invIA: number | undefined;\n  /** @internal */ v_invIB: number | undefined;\n\n  // PositionConstraint\n  /** @internal */ p_localPoints: Vec2[] = []; // [maxManifoldPoints];\n  /** @internal */ p_localNormal: Vec2 = Vec2.zero();\n  /** @internal */ p_localPoint: Vec2 = Vec2.zero();\n  /** @internal */ p_localCenterA: Vec2 = Vec2.zero();\n  /** @internal */ p_localCenterB: Vec2 = Vec2.zero();\n  /** @internal */ p_type: ManifoldType | undefined;\n  /** @internal */ p_radiusA: number | undefined;\n  /** @internal */ p_radiusB: number | undefined;\n  /** @internal */ p_pointCount: number | undefined;\n  /** @internal */ p_invMassA: number | undefined;\n  /** @internal */ p_invMassB: number | undefined;\n  /** @internal */ p_invIA: number | undefined;\n  /** @internal */ p_invIB: number | undefined;\n\n  constructor(fA: Fixture, indexA: number, fB: Fixture, indexB: number, evaluateFcn: EvaluateFunction) {\n    // Nodes for connecting bodies.\n    this.m_nodeA = new ContactEdge(this);\n    this.m_nodeB = new ContactEdge(this);\n\n    this.m_fixtureA = fA;\n    this.m_fixtureB = fB;\n\n    this.m_indexA = indexA;\n    this.m_indexB = indexB;\n\n    this.m_evaluateFcn = evaluateFcn;\n\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n  }\n\n  initConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const shapeA = fixtureA.getShape();\n    const shapeB = fixtureB.getShape();\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const manifold = this.getManifold();\n\n    const pointCount = manifold.pointCount;\n    _ASSERT && common.assert(pointCount > 0);\n\n    this.v_invMassA = bodyA.m_invMass;\n    this.v_invMassB = bodyB.m_invMass;\n    this.v_invIA = bodyA.m_invI;\n    this.v_invIB = bodyB.m_invI;\n\n    this.v_friction = this.m_friction;\n    this.v_restitution = this.m_restitution;\n    this.v_tangentSpeed = this.m_tangentSpeed;\n\n    this.v_pointCount = pointCount;\n\n    this.v_K.setZero();\n    this.v_normalMass.setZero();\n\n    this.p_invMassA = bodyA.m_invMass;\n    this.p_invMassB = bodyB.m_invMass;\n    this.p_invIA = bodyA.m_invI;\n    this.p_invIB = bodyB.m_invI;\n    this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);\n    this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);\n\n    this.p_radiusA = shapeA.m_radius;\n    this.p_radiusB = shapeB.m_radius;\n\n    this.p_type = manifold.type;\n    this.p_localNormal = Vec2.clone(manifold.localNormal);\n    this.p_localPoint = Vec2.clone(manifold.localPoint);\n    this.p_pointCount = pointCount;\n\n    for (let j = 0; j < pointCount; ++j) {\n      const cp = manifold.points[j];\n      const vcp = this.v_points[j] = new VelocityConstraintPoint();\n\n      if (step.warmStarting) {\n        vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n        vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n\n      } else {\n        vcp.normalImpulse = 0.0;\n        vcp.tangentImpulse = 0.0;\n      }\n\n      vcp.rA.setZero();\n      vcp.rB.setZero();\n      vcp.normalMass = 0.0;\n      vcp.tangentMass = 0.0;\n      vcp.velocityBias = 0.0;\n\n      this.p_localPoints[j] = Vec2.clone(cp.localPoint);\n\n    }\n  }\n\n  /**\n   * Get the contact manifold. Do not modify the manifold unless you understand\n   * the internals of the library.\n   */\n  getManifold(): Manifold {\n    return this.m_manifold;\n  }\n\n  /**\n   * Get the world manifold.\n   */\n  getWorldManifold(worldManifold: WorldManifold | null | undefined): WorldManifold | undefined {\n    const bodyA = this.m_fixtureA.getBody();\n    const bodyB = this.m_fixtureB.getBody();\n    const shapeA = this.m_fixtureA.getShape();\n    const shapeB = this.m_fixtureB.getShape();\n\n    return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(),\n      shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n  }\n\n  /**\n   * Enable/disable this contact. This can be used inside the pre-solve contact\n   * listener. The contact is only disabled for the current time step (or sub-step\n   * in continuous collisions).\n   */\n  setEnabled(flag: boolean): void {\n    this.m_enabledFlag = !!flag;\n  }\n\n  /**\n   * Has this contact been disabled?\n   */\n  isEnabled(): boolean {\n    return this.m_enabledFlag;\n  }\n\n  /**\n   * Is this contact touching?\n   */\n  isTouching(): boolean {\n    return this.m_touchingFlag;\n  }\n\n  /**\n   * Get the next contact in the world's contact list.\n   */\n  getNext(): Contact | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get fixture A in this contact.\n   */\n  getFixtureA(): Fixture {\n    return this.m_fixtureA;\n  }\n\n  /**\n   * Get fixture B in this contact.\n   */\n  getFixtureB(): Fixture {\n    return this.m_fixtureB;\n  }\n\n  /**\n   * Get the child primitive index for fixture A.\n   */\n  getChildIndexA(): number {\n    return this.m_indexA;\n  }\n\n  /**\n   * Get the child primitive index for fixture B.\n   */\n  getChildIndexB(): number {\n    return this.m_indexB;\n  }\n\n  /**\n   * Flag this contact for filtering. Filtering will occur the next time step.\n   */\n  flagForFiltering(): void {\n    this.m_filterFlag = true;\n  }\n\n  /**\n   * Override the default friction mixture. You can call this in\n   * ContactListener.preSolve. This value persists until set or reset.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the friction.\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Reset the friction mixture to the default value.\n   */\n  resetFriction(): void {\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction,\n      this.m_fixtureB.m_friction);\n  }\n\n  /**\n   * Override the default restitution mixture. You can call this in\n   * ContactListener.preSolve. The value persists until you set or reset.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Get the restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Reset the restitution to the default value.\n   */\n  resetRestitution(): void {\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,\n      this.m_fixtureB.m_restitution);\n  }\n\n  /**\n   * Set the desired tangent speed for a conveyor belt behavior. In meters per\n   * second.\n   */\n  setTangentSpeed(speed: number): void {\n    this.m_tangentSpeed = speed;\n  }\n\n  /**\n   * Get the desired tangent speed. In meters per second.\n   */\n  getTangentSpeed(): number {\n    return this.m_tangentSpeed;\n  }\n\n  /**\n   * Called by Update method, and implemented by subclasses.\n   */\n  evaluate(manifold: Manifold, xfA: Transform, xfB: Transform): void {\n    this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB,\n      this.m_fixtureB, this.m_indexB);\n  }\n\n  /**\n   * Updates the contact manifold and touching status.\n   *\n   * Note: do not assume the fixture AABBs are overlapping or are valid.\n   *\n   * @param listener.beginContact\n   * @param listener.endContact\n   * @param listener.preSolve\n   */\n  update(listener?: {\n    beginContact(contact: Contact): void,\n    endContact(contact: Contact): void,\n    preSolve(contact: Contact, oldManifold: Manifold): void\n  }): void {\n\n    // Re-enable this contact.\n    this.m_enabledFlag = true;\n\n    let touching = false;\n    const wasTouching = this.m_touchingFlag;\n\n    const sensorA = this.m_fixtureA.isSensor();\n    const sensorB = this.m_fixtureB.isSensor();\n    const sensor = sensorA || sensorB;\n\n    const bodyA = this.m_fixtureA.getBody();\n    const bodyB = this.m_fixtureB.getBody();\n    const xfA = bodyA.getTransform();\n    const xfB = bodyB.getTransform();\n\n    let oldManifold;\n\n    // Is this contact a sensor?\n    if (sensor) {\n      const shapeA = this.m_fixtureA.getShape();\n      const shapeB = this.m_fixtureB.getShape();\n      touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n\n      // Sensors don't generate manifolds.\n      this.m_manifold.pointCount = 0;\n    } else {\n\n      // TODO reuse manifold\n      oldManifold = this.m_manifold;\n      this.m_manifold = new Manifold();\n\n      this.evaluate(this.m_manifold, xfA, xfB);\n      touching = this.m_manifold.pointCount > 0;\n\n      // Match old contact ids to new contact ids and copy the\n      // stored impulses to warm start the solver.\n      for (let i = 0; i < this.m_manifold.pointCount; ++i) {\n        const nmp = this.m_manifold.points[i];\n        nmp.normalImpulse = 0.0;\n        nmp.tangentImpulse = 0.0;\n\n        for (let j = 0; j < oldManifold.pointCount; ++j) {\n          const omp = oldManifold.points[j];\n          if (omp.id.key == nmp.id.key) {\n            nmp.normalImpulse = omp.normalImpulse;\n            nmp.tangentImpulse = omp.tangentImpulse;\n            break;\n          }\n        }\n      }\n\n      if (touching != wasTouching) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n    }\n\n    this.m_touchingFlag = touching;\n\n    if (!wasTouching && touching && listener) {\n      listener.beginContact(this);\n    }\n\n    if (wasTouching && !touching && listener) {\n      listener.endContact(this);\n    }\n\n    if (!sensor && touching && listener) {\n      listener.preSolve(this, oldManifold);\n    }\n  }\n\n  solvePositionConstraint(step: TimeStep): number {\n    return this._solvePositionConstraint(step);\n  }\n\n  solvePositionConstraintTOI(step: TimeStep, toiA: Body, toiB: Body): number {\n    return this._solvePositionConstraint(step, toiA, toiB);\n  }\n\n  private _solvePositionConstraint(step: TimeStep, toiA?: Body, toiB?: Body): number {\n    const toi: boolean = !!toiA && !!toiB;\n\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const localCenterA = Vec2.clone(this.p_localCenterA);\n    const localCenterB = Vec2.clone(this.p_localCenterB);\n\n    let mA = 0.0;\n    let iA = 0.0;\n    if (!toi || (bodyA == toiA || bodyA == toiB)) {\n      mA = this.p_invMassA;\n      iA = this.p_invIA;\n    }\n\n    let mB = 0.0;\n    let iB = 0.0;\n    if (!toi || (bodyB == toiA || bodyB == toiB)) {\n      mB = this.p_invMassB;\n      iB = this.p_invIB;\n    }\n\n    const cA = Vec2.clone(positionA.c);\n    let aA = positionA.a;\n\n    const cB = Vec2.clone(positionB.c);\n    let aB = positionB.a;\n\n    let minSeparation = 0.0;\n\n    // Solve normal constraints\n    for (let j = 0; j < this.p_pointCount; ++j) {\n      const xfA = Transform.identity();\n      const xfB = Transform.identity();\n      xfA.q.setAngle(aA);\n      xfB.q.setAngle(aB);\n      xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));\n      xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));\n\n      // PositionSolverManifold\n      let normal;\n      let point;\n      let separation;\n      switch (this.p_type) {\n        case ManifoldType.e_circles: {\n          const pointA = Transform.mulVec2(xfA, this.p_localPoint);\n          const pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);\n          normal = Vec2.sub(pointB, pointA);\n          normal.normalize();\n          point = Vec2.combine(0.5, pointA, 0.5, pointB);\n          separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;\n          break;\n        }\n\n        case ManifoldType.e_faceA: {\n          normal = Rot.mulVec2(xfA.q, this.p_localNormal);\n          const planePoint = Transform.mulVec2(xfA, this.p_localPoint);\n          const clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);\n          separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n          point = clipPoint;\n          break;\n        }\n\n        case ManifoldType.e_faceB: {\n          normal = Rot.mulVec2(xfB.q, this.p_localNormal);\n          const planePoint = Transform.mulVec2(xfB, this.p_localPoint);\n          const clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);\n          separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n          point = clipPoint;\n\n          // Ensure normal points from A to B\n          normal.mul(-1);\n          break;\n        }\n      }\n\n      const rA = Vec2.sub(point, cA);\n      const rB = Vec2.sub(point, cB);\n\n      // Track max constraint error.\n      minSeparation = Math.min(minSeparation, separation);\n\n      const baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n      const linearSlop = Settings.linearSlop;\n      const maxLinearCorrection = Settings.maxLinearCorrection;\n\n      // Prevent large corrections and allow slop.\n      const C = Math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n\n      // Compute the effective mass.\n      const rnA = Vec2.crossVec2Vec2(rA, normal);\n      const rnB = Vec2.crossVec2Vec2(rB, normal);\n      const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      // Compute normal impulse\n      const impulse = K > 0.0 ? -C / K : 0.0;\n\n      const P = Vec2.mulNumVec2(impulse, normal);\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    }\n\n    positionA.c.setVec2(cA);\n    positionA.a = aA;\n\n    positionB.c.setVec2(cB);\n    positionB.a = aB;\n\n    return minSeparation;\n  }\n\n  initVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const radiusA = this.p_radiusA;\n    const radiusB = this.p_radiusB;\n    const manifold = this.getManifold();\n\n    const mA = this.v_invMassA;\n    const mB = this.v_invMassB;\n    const iA = this.v_invIA;\n    const iB = this.v_invIB;\n    const localCenterA = Vec2.clone(this.p_localCenterA);\n    const localCenterB = Vec2.clone(this.p_localCenterB);\n\n    const cA = Vec2.clone(positionA.c);\n    const aA = positionA.a;\n    const vA = Vec2.clone(velocityA.v);\n    const wA = velocityA.w;\n\n    const cB = Vec2.clone(positionB.c);\n    const aB = positionB.a;\n    const vB = Vec2.clone(velocityB.v);\n    const wB = velocityB.w;\n\n    _ASSERT && common.assert(manifold.pointCount > 0);\n\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    xfA.q.setAngle(aA);\n    xfB.q.setAngle(aB);\n    xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));\n    xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));\n\n    const worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);\n\n    this.v_normal.setVec2(worldManifold.normal);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      vcp.rA.setVec2(Vec2.sub(worldManifold.points[j], cA));\n      vcp.rB.setVec2(Vec2.sub(worldManifold.points[j], cB));\n\n      const rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);\n      const rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);\n\n      const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n\n      const tangent = Vec2.crossVec2Num(this.v_normal, 1.0);\n\n      const rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);\n      const rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);\n\n      const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n\n      vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n\n      // Setup a velocity bias for restitution.\n      vcp.velocityBias = 0.0;\n      const vRel = Vec2.dot(this.v_normal, vB)\n        + Vec2.dot(this.v_normal, Vec2.crossNumVec2(wB, vcp.rB))\n        - Vec2.dot(this.v_normal, vA)\n        - Vec2.dot(this.v_normal, Vec2.crossNumVec2(wA, vcp.rA));\n      if (vRel < -Settings.velocityThreshold) {\n        vcp.velocityBias = -this.v_restitution * vRel;\n      }\n    }\n\n    // If we have two points, then prepare the block solver.\n    if (this.v_pointCount == 2 && step.blockSolve) {\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);\n      const rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);\n      const rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);\n      const rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);\n\n      const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n      const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n      const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n\n      // Ensure a reasonable condition number.\n      const k_maxConditionNumber = 1000.0;\n      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n        // K is safe to invert.\n        this.v_K.ex.setNum(k11, k12);\n        this.v_K.ey.setNum(k12, k22);\n        this.v_normalMass.set(this.v_K.getInverse());\n      } else {\n        // The constraints are redundant, just use one.\n        // TODO_ERIN use deepest?\n        this.v_pointCount = 1;\n      }\n    }\n\n    positionA.c.setVec2(cA);\n    positionA.a = aA;\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n\n    positionB.c.setVec2(cB);\n    positionB.a = aB;\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  warmStartConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    const vA = Vec2.clone(velocityA.v);\n    let wA = velocityA.w;\n    const vB = Vec2.clone(velocityB.v);\n    let wB = velocityB.w;\n\n    const normal = this.v_normal;\n    const tangent = Vec2.crossVec2Num(normal, 1.0);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      const P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n      wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n      vA.subMul(mA, P);\n      wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n      vB.addMul(mB, P);\n    }\n\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  storeConstraintImpulses(step: TimeStep): void {\n    const manifold = this.m_manifold;\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n      manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n    }\n  }\n\n  solveVelocityConstraint(step: TimeStep): void {\n    const bodyA = this.m_fixtureA.m_body;\n    const bodyB = this.m_fixtureB.m_body;\n\n    const velocityA = bodyA.c_velocity;\n    const positionA = bodyA.c_position;\n\n    const velocityB = bodyB.c_velocity;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    const vA = Vec2.clone(velocityA.v);\n    let wA = velocityA.w;\n    const vB = Vec2.clone(velocityB.v);\n    let wB = velocityB.w;\n\n    const normal = this.v_normal;\n    const tangent = Vec2.crossVec2Num(normal, 1.0);\n    const friction = this.v_friction;\n\n    _ASSERT && common.assert(this.v_pointCount == 1 || this.v_pointCount == 2);\n\n    // Solve tangent constraints first because non-penetration is more important\n    // than friction.\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      // Relative velocity at contact\n      const dv = Vec2.zero();\n      dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n      dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n\n      // Compute tangent force\n      const vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;\n      let lambda = vcp.tangentMass * (-vt);\n\n      // Clamp the accumulated force\n      const maxFriction = friction * vcp.normalImpulse;\n      const newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n      lambda = newImpulse - vcp.tangentImpulse;\n      vcp.tangentImpulse = newImpulse;\n\n      // Apply contact impulse\n      const P = Vec2.mulNumVec2(lambda, tangent);\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n    }\n\n    // Solve normal constraints\n    if (this.v_pointCount == 1 || step.blockSolve == false) {\n      for (let i = 0; i < this.v_pointCount; ++i) {\n        const vcp = this.v_points[i]; // VelocityConstraintPoint\n\n        // Relative velocity at contact\n        const dv = Vec2.zero();\n        dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n        dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n\n        // Compute normal impulse\n        const vn = Vec2.dot(dv, normal);\n        let lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n\n        // Clamp the accumulated impulse\n        const newImpulse = Math.max(vcp.normalImpulse + lambda, 0.0);\n        lambda = newImpulse - vcp.normalImpulse;\n        vcp.normalImpulse = newImpulse;\n\n        // Apply contact impulse\n        const P = Vec2.mulNumVec2(lambda, normal);\n\n        vA.subMul(mA, P);\n        wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n\n        vB.addMul(mB, P);\n        wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n      }\n    } else {\n      // Block solver developed in collaboration with Dirk Gregorius (back in\n      // 01/07 on Box2D_Lite).\n      // Build the mini LCP for this contact patch\n      //\n      // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =\n      // 1..2\n      //\n      // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n      // b = vn0 - velocityBias\n      //\n      // The system is solved using the \"Total enumeration method\" (s. Murty).\n      // The complementary constraint vn_i * x_i\n      // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n      // So for the 2D contact problem the cases\n      // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n      // vn1 = 0 need to be tested. The first valid\n      // solution that satisfies the problem is chosen.\n      //\n      // In order to account of the accumulated impulse 'a' (because of the\n      // iterative nature of the solver which only requires\n      // that the accumulated impulse is clamped and not the incremental\n      // impulse) we change the impulse variable (x_i).\n      //\n      // Substitute:\n      //\n      // x = a + d\n      //\n      // a := old total impulse\n      // x := new total impulse\n      // d := incremental impulse\n      //\n      // For the current iteration we extend the formula for the incremental\n      // impulse\n      // to compute the new total impulse:\n      //\n      // vn = A * d + b\n      // = A * (x - a) + b\n      // = A * x + b - A * a\n      // = A * x + b'\n      // b' = b - A * a;\n\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);\n      _ASSERT && common.assert(a.x >= 0.0 && a.y >= 0.0);\n\n      // Relative velocity at contact\n      let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n      let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n\n      // Compute normal velocity\n      let vn1 = Vec2.dot(dv1, normal);\n      let vn2 = Vec2.dot(dv2, normal);\n\n      const b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n\n      // Compute b'\n      b.sub(Mat22.mulVec2(this.v_K, a));\n\n      const k_errorTol = 1e-3;\n      // NOT_USED(k_errorTol);\n\n      while (true) {\n        //\n        // Case 1: vn = 0\n        //\n        // 0 = A * x + b'\n        //\n        // Solve for x:\n        //\n        // x = - inv(A) * b'\n        //\n        const x = Mat22.mulVec2(this.v_normalMass, b).neg();\n\n        if (x.x >= 0.0 && x.y >= 0.0) {\n          // Get the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            dv1 = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, vcp1.rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, vcp1.rA)));\n            dv2 = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, vcp2.rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, vcp2.rA)));\n\n            // Compute normal velocity\n            vn1 = Vec2.dot(dv1, normal);\n            vn2 = Vec2.dot(dv2, normal);\n\n            _ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n            _ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 2: vn1 = 0 and x2 = 0\n        //\n        // 0 = a11 * x1 + a12 * 0 + b1'\n        // vn2 = a21 * x1 + a22 * 0 + b2'\n        //\n        x.x = -vcp1.normalMass * b.x;\n        x.y = 0.0;\n        vn1 = 0.0;\n        vn2 = this.v_K.ex.y * x.x + b.y;\n\n        if (x.x >= 0.0 && vn2 >= 0.0) {\n          // Get the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            const dv1B = Vec2.add(vB, Vec2.crossNumVec2(wB, vcp1.rB));\n            const dv1A = Vec2.add(vA, Vec2.crossNumVec2(wA, vcp1.rA));\n            const dv1 = Vec2.sub(dv1B, dv1A);\n\n            // Compute normal velocity\n            vn1 = Vec2.dot(dv1, normal);\n\n            _ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 3: vn2 = 0 and x1 = 0\n        //\n        // vn1 = a11 * 0 + a12 * x2 + b1'\n        // 0 = a21 * 0 + a22 * x2 + b2'\n        //\n        x.x = 0.0;\n        x.y = -vcp2.normalMass * b.y;\n        vn1 = this.v_K.ey.x * x.y + b.x;\n        vn2 = 0.0;\n\n        if (x.y >= 0.0 && vn1 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            const dv2B = Vec2.add(vB, Vec2.crossNumVec2(wB, vcp2.rB));\n            const dv2A = Vec2.add(vA, Vec2.crossNumVec2(wA, vcp2.rA));\n            const dv1 = Vec2.sub(dv2B, dv2A);\n\n            // Compute normal velocity\n            vn2 = Vec2.dot(dv2, normal);\n\n            _ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 4: x1 = 0 and x2 = 0\n        //\n        // vn1 = b1\n        // vn2 = b2;\n        //\n        x.x = 0.0;\n        x.y = 0.0;\n        vn1 = b.x;\n        vn2 = b.y;\n\n        if (vn1 >= 0.0 && vn2 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          break;\n        }\n\n        // No solution, give up. This is hit sometimes, but it doesn't seem to\n        // matter.\n        break;\n      }\n    }\n\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  /**\n   * @internal\n   */\n  static addType(type1: ShapeType, type2: ShapeType, callback: ContactCallback): void {\n    s_registers[type1] = s_registers[type1] || {};\n    s_registers[type1][type2] = callback;\n  }\n\n  /**\n   * @internal\n   */\n  static create(fixtureA: Fixture, indexA: number, fixtureB: Fixture, indexB: number): Contact | null {\n    const typeA = fixtureA.getType();\n    const typeB = fixtureB.getType();\n\n    // TODO: pool contacts\n    let contact;\n    let evaluateFcn;\n    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n      contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n      contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n    } else {\n      return null;\n    }\n\n    // Contact creation may swap fixtures.\n    fixtureA = contact.getFixtureA();\n    fixtureB = contact.getFixtureB();\n    indexA = contact.getChildIndexA();\n    indexB = contact.getChildIndexB();\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Connect to body A\n    contact.m_nodeA.contact = contact;\n    contact.m_nodeA.other = bodyB;\n\n    contact.m_nodeA.prev = null;\n    contact.m_nodeA.next = bodyA.m_contactList;\n    if (bodyA.m_contactList != null) {\n      bodyA.m_contactList.prev = contact.m_nodeA;\n    }\n    bodyA.m_contactList = contact.m_nodeA;\n\n    // Connect to body B\n    contact.m_nodeB.contact = contact;\n    contact.m_nodeB.other = bodyA;\n\n    contact.m_nodeB.prev = null;\n    contact.m_nodeB.next = bodyB.m_contactList;\n    if (bodyB.m_contactList != null) {\n      bodyB.m_contactList.prev = contact.m_nodeB;\n    }\n    bodyB.m_contactList = contact.m_nodeB;\n\n    // Wake up the bodies\n    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    return contact;\n  }\n\n  /**\n   * @internal\n   */\n  static destroy(contact: Contact, listener: { endContact: (contact: Contact) => void }): void {\n    const fixtureA = contact.m_fixtureA;\n    const fixtureB = contact.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    if (contact.isTouching()) {\n      listener.endContact(contact);\n    }\n\n    // Remove from body 1\n    if (contact.m_nodeA.prev) {\n      contact.m_nodeA.prev.next = contact.m_nodeA.next;\n    }\n\n    if (contact.m_nodeA.next) {\n      contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n    }\n\n    if (contact.m_nodeA == bodyA.m_contactList) {\n      bodyA.m_contactList = contact.m_nodeA.next;\n    }\n\n    // Remove from body 2\n    if (contact.m_nodeB.prev) {\n      contact.m_nodeB.prev.next = contact.m_nodeB.next;\n    }\n\n    if (contact.m_nodeB.next) {\n      contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n    }\n\n    if (contact.m_nodeB == bodyB.m_contactList) {\n      bodyB.m_contactList = contact.m_nodeB.next;\n    }\n\n    if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false\n      && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    const typeA = fixtureA.getType();\n    const typeB = fixtureB.getType();\n\n    // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n    // if (typeof destroyFcn === 'function') {\n    //   destroyFcn(contact);\n    // }\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../util/options';\nimport common from '../util/common';\nimport { Vec2 } from '../common/Vec2';\nimport { BroadPhase } from '../collision/BroadPhase';\nimport { Solver, ContactImpulse, TimeStep } from './Solver';\nimport { Body, BodyDef } from './Body';\nimport { Joint } from './Joint';\nimport { Contact } from './Contact';\nimport { AABB, RayCastInput, RayCastOutput } from \"../collision/AABB\";\nimport { Fixture, FixtureProxy } from \"./Fixture\";\nimport { Manifold } from \"../collision/Manifold\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * @prop gravity [{ x : 0, y : 0}]\n * @prop allowSleep [true]\n * @prop warmStarting [true]\n * @prop continuousPhysics [true]\n * @prop subStepping [false]\n * @prop blockSolve [true]\n * @prop velocityIterations [8] For the velocity constraint solver.\n * @prop positionIterations [3] For the position constraint solver.\n */\nexport interface WorldDef {\n  gravity?: Vec2;\n  allowSleep?: boolean;\n  warmStarting?: boolean;\n  continuousPhysics?: boolean;\n  subStepping?: boolean;\n  blockSolve?: boolean;\n  velocityIterations?: number;\n  positionIterations?: number;\n}\n\nconst WorldDefDefault: WorldDef = {\n  gravity : Vec2.zero(),\n  allowSleep : true,\n  warmStarting : true,\n  continuousPhysics : true,\n  subStepping : false,\n  blockSolve : true,\n  velocityIterations : 8,\n  positionIterations : 3\n};\n\n/**\n * Callback function for ray casts, see {@link World.rayCast}.\n *\n * Called for each fixture found in the query. You control how the ray cast\n * proceeds by returning a float: return -1: ignore this fixture and continue\n * return 0: terminate the ray cast return fraction: clip the ray to this point\n * return 1: don't clip the ray and continue\n *\n * @param fixture The fixture hit by the ray\n * @param point The point of initial intersection\n * @param normal The normal vector at the point of intersection\n * @param fraction\n *\n * @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue\n */\nexport type WorldRayCastCallback = (fixture: Fixture, point: Vec2, normal: Vec2, fraction: number) => number;\n\n/**\n * Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n */\nexport type WorldAABBQueryCallback = (fixture: Fixture) => boolean;\n\nexport class World {\n  /** @internal */ m_solver: Solver;\n  /** @internal */ m_broadPhase: BroadPhase;\n  /** @internal */ m_contactList: Contact | null;\n  /** @internal */ m_contactCount: number;\n  /** @internal */ m_bodyList: Body | null;\n  /** @internal */ m_bodyCount: number;\n  /** @internal */ m_jointList: Joint | null;\n  /** @internal */ m_jointCount: number;\n  /** @internal */ m_stepComplete: boolean;\n  /** @internal */ m_allowSleep: boolean;\n  /** @internal */ m_gravity: Vec2;\n  /** @internal */ m_clearForces: boolean;\n  /** @internal */ m_newFixture: boolean;\n  /** @internal */ m_locked: boolean;\n  /** @internal */ m_warmStarting: boolean;\n  /** @internal */ m_continuousPhysics: boolean;\n  /** @internal */ m_subStepping: boolean;\n  /** @internal */ m_blockSolve: boolean;\n  /** @internal */ m_velocityIterations: number;\n  /** @internal */ m_positionIterations: number;\n  /** @internal */ m_t: number;\n\n  // TODO\n  /** @internal */ _listeners: {\n    [key: string]: any[]\n  };\n\n  /**\n   * @param def World definition or gravity vector.\n   */\n  constructor(def?: WorldDef | Vec2 | null) {\n    if (!(this instanceof World)) {\n      return new World(def);\n    }\n\n    this.s_step = new TimeStep();\n\n\n    if (def && Vec2.isValid(def)) {\n      def = { gravity: def as Vec2 };\n    }\n\n    def = options(def, WorldDefDefault) as WorldDef;\n\n    this.m_solver = new Solver(this);\n\n    this.m_broadPhase = new BroadPhase();\n\n    this.m_contactList = null;\n    this.m_contactCount = 0;\n\n    this.m_bodyList = null;\n    this.m_bodyCount = 0;\n\n    this.m_jointList = null;\n    this.m_jointCount = 0;\n\n    this.m_stepComplete = true;\n\n    this.m_allowSleep = def.allowSleep;\n    this.m_gravity = Vec2.clone(def.gravity);\n\n    this.m_clearForces = true;\n    this.m_newFixture = false;\n    this.m_locked = false;\n\n    // These are for debugging the solver.\n    this.m_warmStarting = def.warmStarting;\n    this.m_continuousPhysics = def.continuousPhysics;\n    this.m_subStepping = def.subStepping;\n\n    this.m_blockSolve = def.blockSolve;\n    this.m_velocityIterations = def.velocityIterations;\n    this.m_positionIterations = def.positionIterations;\n\n    this.m_t = 0;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const bodies = [];\n    const joints = [];\n\n    for (let b = this.getBodyList(); b; b = b.getNext()) {\n      bodies.push(b);\n    }\n\n    for (let j = this.getJointList(); j; j = j.getNext()) {\n      // @ts-ignore\n      if (typeof j._serialize === 'function') {\n        joints.push(j);\n      }\n    }\n\n    return {\n      gravity: this.m_gravity,\n      bodies,\n      joints,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, context: any, restore: any): World {\n    if (!data) {\n      return new World();\n    }\n\n    const world = new World(data.gravity);\n\n    if (data.bodies) {\n      for (let i = data.bodies.length - 1; i >= 0; i -= 1) {\n        world._addBody(restore(Body, data.bodies[i], world));\n      }\n    }\n\n    if (data.joints) {\n      for (let i = data.joints.length - 1; i >= 0; i--) {\n        world.createJoint(restore(Joint, data.joints[i], world));\n      }\n    }\n\n    return world;\n  }\n\n  /**\n   * Get the world body list. With the returned body, use Body.getNext to get the\n   * next body in the world list. A null body indicates the end of the list.\n   *\n   * @return the head of the world body list.\n   */\n  getBodyList(): Body | null {\n    return this.m_bodyList;\n  }\n\n  /**\n   * Get the world joint list. With the returned joint, use Joint.getNext to get\n   * the next joint in the world list. A null joint indicates the end of the list.\n   *\n   * @return the head of the world joint list.\n   */\n  getJointList(): Joint | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Get the world contact list. With the returned contact, use Contact.getNext to\n   * get the next contact in the world list. A null contact indicates the end of\n   * the list.\n   *\n   * Warning: contacts are created and destroyed in the middle of a time step.\n   * Use ContactListener to avoid missing contacts.\n   *\n   * @return the head of the world contact list.\n   */\n  getContactList(): Contact | null {\n    return this.m_contactList;\n  }\n\n  getBodyCount(): number {\n    return this.m_bodyCount;\n  }\n\n  getJointCount(): number {\n    return this.m_jointCount;\n  }\n\n  /**\n   * Get the number of contacts (each may have 0 or more contact points).\n   */\n  getContactCount(): number {\n    return this.m_contactCount;\n  }\n\n  /**\n   * Change the global gravity vector.\n   */\n  setGravity(gravity: Vec2): void {\n    this.m_gravity = gravity;\n  }\n\n  /**\n   * Get the global gravity vector.\n   */\n  getGravity(): Vec2 {\n    return this.m_gravity;\n  }\n\n  /**\n   * Is the world locked (in the middle of a time step).\n   */\n  isLocked(): boolean {\n    return this.m_locked;\n  }\n\n  /**\n   * Enable/disable sleep.\n   */\n  setAllowSleeping(flag: boolean): void {\n    if (flag == this.m_allowSleep) {\n      return;\n    }\n\n    this.m_allowSleep = flag;\n    if (this.m_allowSleep == false) {\n      for (let b = this.m_bodyList; b; b = b.m_next) {\n        b.setAwake(true);\n      }\n    }\n  }\n\n  getAllowSleeping(): boolean {\n    return this.m_allowSleep;\n  }\n\n  /**\n   * Enable/disable warm starting. For testing.\n   */\n  setWarmStarting(flag: boolean): void {\n    this.m_warmStarting = flag;\n  }\n\n  getWarmStarting(): boolean {\n    return this.m_warmStarting;\n  }\n\n  /**\n   * Enable/disable continuous physics. For testing.\n   */\n  setContinuousPhysics(flag: boolean): void {\n    this.m_continuousPhysics = flag;\n  }\n\n  getContinuousPhysics(): boolean {\n    return this.m_continuousPhysics;\n  }\n\n  /**\n   * Enable/disable single stepped continuous physics. For testing.\n   */\n  setSubStepping(flag: boolean): void {\n    this.m_subStepping = flag;\n  }\n\n  getSubStepping(): boolean {\n    return this.m_subStepping;\n  }\n\n  /**\n   * Set flag to control automatic clearing of forces after each time step.\n   */\n  setAutoClearForces(flag: boolean): void {\n    this.m_clearForces = flag;\n  }\n\n  /**\n   * Get the flag that controls automatic clearing of forces after each time step.\n   */\n  getAutoClearForces(): boolean {\n    return this.m_clearForces;\n  }\n\n  /**\n   * Manually clear the force buffer on all bodies. By default, forces are cleared\n   * automatically after each call to step. The default behavior is modified by\n   * calling setAutoClearForces. The purpose of this function is to support\n   * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n   * under a variable frame-rate. When you perform sub-stepping you will disable\n   * auto clearing of forces and instead call clearForces after all sub-steps are\n   * complete in one pass of your game loop.\n   *\n   * See {@link World.setAutoClearForces}\n   */\n  clearForces(): void {\n    for (let body = this.m_bodyList; body; body = body.getNext()) {\n      body.m_force.setZero();\n      body.m_torque = 0.0;\n    }\n  }\n\n  /**\n   * Query the world for all fixtures that potentially overlap the provided AABB.\n   *\n   * @param aabb The query box.\n   * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n   */\n  queryAABB(aabb: AABB, callback: WorldAABBQueryCallback): void {\n    _ASSERT && common.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n    this.m_broadPhase.query(aabb, function(proxyId: number): boolean { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      return callback(proxy.fixture);\n    });\n  }\n\n  /**\n   * Ray-cast the world for all fixtures in the path of the ray. Your callback\n   * controls whether you get the closest point, any point, or n-points. The\n   * ray-cast ignores shapes that contain the starting point.\n   *\n   * @param point1 The ray starting point\n   * @param point2 The ray ending point\n   * @param callback A user implemented callback function.\n   */\n  rayCast(point1: Vec2, point2: Vec2, callback: WorldRayCastCallback): void {\n    _ASSERT && common.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n\n    this.m_broadPhase.rayCast({\n      maxFraction : 1.0,\n      p1 : point1,\n      p2 : point2\n    }, function(input: RayCastInput, proxyId: number): number { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      const fixture = proxy.fixture;\n      const index = proxy.childIndex;\n      // @ts-ignore\n      const output: RayCastOutput = {}; // TODO GC\n      const hit = fixture.rayCast(output, input, index);\n      if (hit) {\n        const fraction = output.fraction;\n        const point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n        return callback(fixture, point, output.normal, fraction);\n      }\n      return input.maxFraction;\n    });\n  }\n\n  /**\n   * Get the number of broad-phase proxies.\n   */\n  getProxyCount(): number {\n    return this.m_broadPhase.getProxyCount();\n  }\n\n  /**\n   * Get the height of broad-phase dynamic tree.\n   */\n  getTreeHeight(): number {\n    return this.m_broadPhase.getTreeHeight();\n  }\n\n  /**\n   * Get the balance of broad-phase dynamic tree.\n   */\n  getTreeBalance(): number {\n    return this.m_broadPhase.getTreeBalance();\n  }\n\n  /**\n   * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n   * The minimum is 1.\n   */\n  getTreeQuality(): number {\n    return this.m_broadPhase.getTreeQuality();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The body shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    _ASSERT && common.assert(this.m_locked == false);\n    if (this.m_locked) {\n      return;\n    }\n\n    for (let b = this.m_bodyList; b; b = b.m_next) {\n      b.m_xf.p.sub(newOrigin);\n      b.m_sweep.c0.sub(newOrigin);\n      b.m_sweep.c.sub(newOrigin);\n    }\n\n    for (let j = this.m_jointList; j; j = j.m_next) {\n      j.shiftOrigin(newOrigin);\n    }\n\n    this.m_broadPhase.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addBody(body: Body): void {\n    _ASSERT && common.assert(this.isLocked() === false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Add to world doubly linked list.\n    body.m_prev = null;\n    body.m_next = this.m_bodyList;\n    if (this.m_bodyList) {\n      this.m_bodyList.m_prev = body;\n    }\n    this.m_bodyList = body;\n    ++this.m_bodyCount;\n  }\n\n  /**\n   * Create a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createBody(def?: BodyDef): Body;\n  createBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createBody(arg1?, arg2?) {\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n\n    const body = new Body(this, def);\n    this._addBody(body);\n    return body;\n  }\n\n  createDynamicBody(def?: BodyDef): Body;\n  createDynamicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createDynamicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'dynamic';\n    return this.createBody(def);\n  }\n\n  createKinematicBody(def?: BodyDef): Body;\n  createKinematicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createKinematicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'kinematic';\n    return this.createBody(def);\n  }\n\n  /**\n   * Destroy a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This automatically deletes all associated shapes and joints.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  destroyBody(b: Body): boolean {\n    _ASSERT && common.assert(this.m_bodyCount > 0);\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    if (b.m_destroyed) {\n      return false;\n    }\n\n    // Delete the attached joints.\n    let je = b.m_jointList;\n    while (je) {\n      const je0 = je;\n      je = je.next;\n\n      this.publish('remove-joint', je0.joint);\n      this.destroyJoint(je0.joint);\n\n      b.m_jointList = je;\n    }\n    b.m_jointList = null;\n\n    // Delete the attached contacts.\n    let ce = b.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n\n      this.destroyContact(ce0.contact);\n\n      b.m_contactList = ce;\n    }\n    b.m_contactList = null;\n\n    // Delete the attached fixtures. This destroys broad-phase proxies.\n    let f = b.m_fixtureList;\n    while (f) {\n      const f0 = f;\n      f = f.m_next;\n\n      this.publish('remove-fixture', f0);\n      f0.destroyProxies(this.m_broadPhase);\n\n      b.m_fixtureList = f;\n    }\n    b.m_fixtureList = null;\n\n    // Remove world body list.\n    if (b.m_prev) {\n      b.m_prev.m_next = b.m_next;\n    }\n\n    if (b.m_next) {\n      b.m_next.m_prev = b.m_prev;\n    }\n\n    if (b == this.m_bodyList) {\n      this.m_bodyList = b.m_next;\n    }\n\n    b.m_destroyed = true;\n\n    --this.m_bodyCount;\n\n    this.publish('remove-body', b);\n\n    return true;\n  }\n\n  /**\n   * Create a joint to constrain bodies together. No reference to the definition\n   * is retained. This may cause the connected bodies to cease colliding.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createJoint<T extends Joint>(joint: T): T | null {\n    _ASSERT && common.assert(!!joint.m_bodyA);\n    _ASSERT && common.assert(!!joint.m_bodyB);\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    // Connect to the world list.\n    joint.m_prev = null;\n    joint.m_next = this.m_jointList;\n    if (this.m_jointList) {\n      this.m_jointList.m_prev = joint;\n    }\n    this.m_jointList = joint;\n    ++this.m_jointCount;\n\n    // Connect to the bodies' doubly linked lists.\n    joint.m_edgeA.joint = joint;\n    joint.m_edgeA.other = joint.m_bodyB;\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n    if (joint.m_bodyA.m_jointList)\n      joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n    joint.m_bodyA.m_jointList = joint.m_edgeA;\n\n    joint.m_edgeB.joint = joint;\n    joint.m_edgeB.other = joint.m_bodyA;\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n    if (joint.m_bodyB.m_jointList)\n      joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n    joint.m_bodyB.m_jointList = joint.m_edgeB;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      for (let edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n        if (edge.other == joint.m_bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n      }\n    }\n\n    // Note: creating a joint doesn't wake the bodies.\n\n    return joint;\n  }\n\n  /**\n   * Destroy a joint. This may cause the connected bodies to begin colliding.\n   * Warning: This function is locked during callbacks.\n   */\n  destroyJoint(joint: Joint): void {\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Remove from the doubly linked list.\n    if (joint.m_prev) {\n      joint.m_prev.m_next = joint.m_next;\n    }\n\n    if (joint.m_next) {\n      joint.m_next.m_prev = joint.m_prev;\n    }\n\n    if (joint == this.m_jointList) {\n      this.m_jointList = joint.m_next;\n    }\n\n    // Disconnect from bodies.\n    const bodyA = joint.m_bodyA;\n    const bodyB = joint.m_bodyB;\n\n    // Wake up connected bodies.\n    bodyA.setAwake(true);\n    bodyB.setAwake(true);\n\n    // Remove from body 1.\n    if (joint.m_edgeA.prev) {\n      joint.m_edgeA.prev.next = joint.m_edgeA.next;\n    }\n\n    if (joint.m_edgeA.next) {\n      joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n    }\n\n    if (joint.m_edgeA == bodyA.m_jointList) {\n      bodyA.m_jointList = joint.m_edgeA.next;\n    }\n\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = null;\n\n    // Remove from body 2\n    if (joint.m_edgeB.prev) {\n      joint.m_edgeB.prev.next = joint.m_edgeB.next;\n    }\n\n    if (joint.m_edgeB.next) {\n      joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n    }\n\n    if (joint.m_edgeB == bodyB.m_jointList) {\n      bodyB.m_jointList = joint.m_edgeB.next;\n    }\n\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = null;\n\n    _ASSERT && common.assert(this.m_jointCount > 0);\n    --this.m_jointCount;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      let edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n\n        edge = edge.next;\n      }\n    }\n\n    this.publish('remove-joint', joint);\n  }\n\n  /** @internal */\n  s_step: TimeStep; // reuse\n\n  /**\n   * Take a time step. This performs collision detection, integration, and\n   * constraint solution.\n   *\n   * Broad-phase, narrow-phase, solve and solve time of impacts.\n   *\n   * @param timeStep Time step, this should not vary.\n   */\n  step(timeStep: number, velocityIterations?: number, positionIterations?: number): void {\n    this.publish('pre-step', timeStep);\n\n    if ((velocityIterations | 0) !== velocityIterations) {\n      // TODO: remove this in future\n      velocityIterations = 0;\n    }\n\n    velocityIterations = velocityIterations || this.m_velocityIterations;\n    positionIterations = positionIterations || this.m_positionIterations;\n\n    // If new fixtures were added, we need to find the new contacts.\n    if (this.m_newFixture) {\n      this.findNewContacts();\n      this.m_newFixture = false;\n    }\n\n    this.m_locked = true;\n\n    this.s_step.reset(timeStep);\n    this.s_step.velocityIterations = velocityIterations;\n    this.s_step.positionIterations = positionIterations;\n    this.s_step.warmStarting = this.m_warmStarting;\n    this.s_step.blockSolve = this.m_blockSolve;\n\n    // Update contacts. This is where some contacts are destroyed.\n    this.updateContacts();\n\n    // Integrate velocities, solve velocity constraints, and integrate positions.\n    if (this.m_stepComplete && timeStep > 0.0) {\n      this.m_solver.solveWorld(this.s_step);\n\n      // Synchronize fixtures, check for out of range bodies.\n      for (let b = this.m_bodyList; b; b = b.getNext()) {\n        // If a body was not in an island then it did not move.\n        if (b.m_islandFlag == false) {\n          continue;\n        }\n\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Update fixtures (for broad-phase).\n        b.synchronizeFixtures();\n      }\n      // Look for new contacts.\n      this.findNewContacts();\n    }\n\n    // Handle TOI events.\n    if (this.m_continuousPhysics && timeStep > 0.0) {\n      this.m_solver.solveWorldTOI(this.s_step);\n    }\n\n    if (this.m_clearForces) {\n      this.clearForces();\n    }\n\n    this.m_locked = false;\n\n    this.publish('post-step', timeStep);\n  }\n\n  /**\n   * @internal\n   * Call this method to find new contacts.\n   */\n  findNewContacts(): void {\n    this.m_broadPhase.updatePairs(\n      (proxyA: FixtureProxy, proxyB: FixtureProxy) => this.createContact(proxyA, proxyB)\n    );\n  }\n\n  /**\n   * @internal\n   * Callback for broad-phase.\n   */\n  createContact(proxyA: FixtureProxy, proxyB: FixtureProxy): void {\n    const fixtureA = proxyA.fixture;\n    const fixtureB = proxyB.fixture;\n\n    const indexA = proxyA.childIndex;\n    const indexB = proxyB.childIndex;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Are the fixtures on the same body?\n    if (bodyA == bodyB) {\n      return;\n    }\n\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\n    // bodies have a lot of contacts.\n    // Does a contact already exist?\n    let edge = bodyB.getContactList(); // ContactEdge\n    while (edge) {\n      if (edge.other == bodyA) {\n        const fA = edge.contact.getFixtureA();\n        const fB = edge.contact.getFixtureB();\n        const iA = edge.contact.getChildIndexA();\n        const iB = edge.contact.getChildIndexB();\n\n        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n          // A contact already exists.\n          return;\n        }\n\n        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n          // A contact already exists.\n          return;\n        }\n      }\n\n      edge = edge.next;\n    }\n\n    if (bodyB.shouldCollide(bodyA) == false) {\n      return;\n    }\n    if (fixtureB.shouldCollide(fixtureA) == false) {\n      return;\n    }\n\n    // Call the factory.\n    const contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n    if (contact == null) {\n      return;\n    }\n\n    // Insert into the world.\n    contact.m_prev = null;\n    if (this.m_contactList != null) {\n      contact.m_next = this.m_contactList;\n      this.m_contactList.m_prev = contact;\n    }\n    this.m_contactList = contact;\n\n    ++this.m_contactCount;\n  }\n\n  /**\n   * @internal\n   * Removes old non-overlapping contacts, applies filters and updates contacts.\n   */\n  updateContacts(): void {\n    // Update awake contacts.\n    let c;\n    let next_c = this.m_contactList;\n    while (c = next_c) {\n      next_c = c.getNext();\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n      const indexA = c.getChildIndexA();\n      const indexB = c.getChildIndexB();\n      const bodyA = fixtureA.getBody();\n      const bodyB = fixtureB.getBody();\n\n      // Is this contact flagged for filtering?\n      if (c.m_filterFlag) {\n        if (bodyB.shouldCollide(bodyA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        // Clear the filtering flag.\n        c.m_filterFlag = false;\n      }\n\n      const activeA = bodyA.isAwake() && !bodyA.isStatic();\n      const activeB = bodyB.isAwake() && !bodyB.isStatic();\n\n      // At least one body must be awake and it must be dynamic or kinematic.\n      if (activeA == false && activeB == false) {\n        continue;\n      }\n\n      const proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n      const proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n      const overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n\n      // Here we destroy contacts that cease to overlap in the broad-phase.\n      if (overlap == false) {\n        this.destroyContact(c);\n        continue;\n      }\n\n      // The contact persists.\n      c.update(this);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  destroyContact(contact: Contact): void {\n    Contact.destroy(contact, this);\n\n    // Remove from the world.\n    if (contact.m_prev) {\n      contact.m_prev.m_next = contact.m_next;\n    }\n    if (contact.m_next) {\n      contact.m_next.m_prev = contact.m_prev;\n    }\n    if (contact == this.m_contactList) {\n      this.m_contactList = contact.m_next;\n    }\n\n    --this.m_contactCount;\n  }\n\n\n  /**\n   * Called when two fixtures begin to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  /**\n   * Called when two fixtures cease to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'end-contact', listener: (contact: Contact) => void): World;\n  /**\n   * This is called after a contact is updated. This allows you to inspect a\n   * contact before it goes to the solver. If you are careful, you can modify the\n   * contact manifold (e.g. disable contact). A copy of the old manifold is\n   * provided so that you can detect changes. Note: this is called only for awake\n   * bodies. Note: this is called even when the number of contact points is zero.\n   * Note: this is not called for sensors. Note: if you set the number of contact\n   * points to zero, you will not get an endContact callback. However, you may get\n   * a beginContact callback the next step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  /**\n   * This lets you inspect a contact after the solver is finished. This is useful\n   * for inspecting impulses. Note: the contact manifold does not include time of\n   * impact impulses, which can be arbitrarily large if the sub-step is small.\n   * Hence the impulse is provided explicitly in a separate data structure. Note:\n   * this is only called for contacts that are touching, solid, and awake.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  /** Listener is called whenever a body is removed. */\n  on(name: 'remove-body', listener: (body: Body) => void): World;\n  /** Listener is called whenever a joint is removed implicitly or explicitly. */\n  on(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  /** Listener is called whenever a fixture is removed implicitly or explicitly. */\n  on(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Register an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  on(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    if (!this._listeners) {\n      this._listeners = {};\n    }\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    this._listeners[name].push(listener);\n    return this;\n  }\n\n  off(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  off(name: 'end-contact', listener: (contact: Contact) => void): World;\n  off(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  off(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  off(name: 'remove-body', listener: (body: Body) => void): World;\n  off(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  off(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Remove an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  off(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n    const index = listeners.indexOf(listener);\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n    return this;\n  }\n\n  publish(name: string, arg1?: any, arg2?: any, arg3?: any): number {\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return 0;\n    }\n    for (let l = 0; l < listeners.length; l++) {\n      listeners[l].call(this, arg1, arg2, arg3);\n    }\n    return listeners.length;\n  }\n\n  /**\n   * @internal\n   */\n  beginContact(contact: Contact): void {\n    this.publish('begin-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  endContact(contact: Contact): void {\n    this.publish('end-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  preSolve(contact: Contact, oldManifold: Manifold): void {\n    this.publish('pre-solve', contact, oldManifold);\n  }\n\n  /**\n   * @internal\n   */\n  postSolve(contact: Contact, impulse: ContactImpulse): void {\n    this.publish('post-solve', contact, impulse);\n  }\n\n  /**\n   * Joints and fixtures are destroyed when their associated body is destroyed.\n   * Register a destruction listener so that you may nullify references to these\n   * joints and shapes.\n   *\n   * `function(object)` is called when any joint or fixture is about to\n   * be destroyed due to the destruction of one of its attached or parent bodies.\n   */\n\n  /**\n   * Register a contact filter to provide specific control over collision.\n   * Otherwise the default filter is used (defaultFilter). The listener is owned\n   * by you and must remain in scope.\n   *\n   * Moved to Fixture.\n   */\n}","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Math } from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number);\n  constructor(obj: { x: number, y: number, z: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?, z?) {\n    if (!(this instanceof Vec3)) {\n      return new Vec3(x, y, z);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n      this.z = x.z;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    _ASSERT && Vec3.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    obj.z = data.z;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number, z: number): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = x;\n    obj.y = y;\n    obj.z = z;\n    return obj;\n  }\n\n  static zero(): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    obj.z = 0;\n    return obj;\n  }\n\n  static clone(v: Vec3): Vec3 {\n    _ASSERT && Vec3.assert(v);\n    return Vec3.neo(v.x, v.y, v.z);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y) && Math.isFinite(obj.z);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Vec3.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Vec3!');\n    }\n  }\n\n  setZero(): Vec3 {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  add(w: Vec3): Vec3 {\n    this.x += w.x;\n    this.y += w.y;\n    this.z += w.z;\n    return this;\n  }\n\n  sub(w: Vec3): Vec3 {\n    this.x -= w.x;\n    this.y -= w.y;\n    this.z -= w.z;\n    return this;\n  }\n\n  mul(m: number): Vec3 {\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  static areEqual(v: Vec3, w: Vec3): boolean {\n    _ASSERT && Vec3.assert(v);\n    _ASSERT && Vec3.assert(w);\n    return v === w ||\n      typeof v === 'object' && v !== null &&\n      typeof w === 'object' && w !== null &&\n      v.x === w.x && v.y === w.y && v.z === w.z;\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec3, w: Vec3): number {\n    return v.x * w.x + v.y * w.y + v.z * w.z;\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static cross(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(\n      v.y * w.z - v.z * w.y,\n      v.z * w.x - v.x * w.z,\n      v.x * w.y - v.y * w.x\n    );\n  }\n\n  static add(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n  }\n\n  static sub(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n  }\n\n  static mul(v: Vec3, m: number): Vec3 {\n    return new Vec3(m * v.x, m * v.y, m * v.z);\n  }\n\n  neg(): Vec3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  static neg(v: Vec3): Vec3 {\n    return new Vec3(-v.x, -v.y, -v.z);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Settings } from '../../Settings';\nimport { Shape } from '../Shape';\nimport { Transform } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2 } from '../../common/Vec2';\nimport { AABB, RayCastInput, RayCastOutput } from '../AABB';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n/**\n * A line segment (edge) shape. These can be connected in chains or loops to\n * other edge shapes. The connectivity information is used to ensure correct\n * contact normals.\n */\nexport class EdgeShape extends Shape {\n  static TYPE = 'edge' as const;\n\n  // These are the edge vertices\n  m_vertex1: Vec2;\n  m_vertex2: Vec2;\n\n  // Optional adjacent vertices. These are used for smooth collision.\n  // Used by chain shape.\n  m_vertex0: Vec2;\n  m_vertex3: Vec2;\n  m_hasVertex0: boolean;\n  m_hasVertex3: boolean;\n\n  constructor(v1?: Vec2, v2?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof EdgeShape)) {\n      return new EdgeShape(v1, v2);\n    }\n\n    super();\n\n    this.m_type = EdgeShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n\n\n    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n\n    this.m_vertex0 = Vec2.zero();\n    this.m_vertex3 = Vec2.zero();\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertex1: this.m_vertex1,\n      vertex2: this.m_vertex2,\n\n      vertex0: this.m_vertex0,\n      vertex3: this.m_vertex3,\n      hasVertex0: this.m_hasVertex0,\n      hasVertex3: this.m_hasVertex3,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): EdgeShape {\n    const shape = new EdgeShape(data.vertex1, data.vertex2);\n    if (shape.m_hasVertex0) {\n      shape.setPrevVertex(data.vertex0);\n    }\n    if (shape.m_hasVertex3) {\n      shape.setNextVertex(data.vertex3);\n    }\n    return shape;\n  }\n\n  /** @internal @deprecated */\n  setNext(v?: Vec2): EdgeShape {\n    return this.setNextVertex(v);\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  setNextVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex3.setVec2(v);\n      this.m_hasVertex3 = true;\n    } else {\n      this.m_vertex3.setZero();\n      this.m_hasVertex3 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  getNextVertex(): Vec2 {\n    return this.m_vertex3;\n  }\n\n  /** @internal @deprecated */\n  setPrev(v?: Vec2): EdgeShape {\n    return this.setPrevVertex(v);\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  setPrevVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex0.setVec2(v);\n      this.m_hasVertex0 = true;\n    } else {\n      this.m_vertex0.setZero();\n      this.m_hasVertex0 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  getPrevVertex(): Vec2 {\n    return this.m_vertex0;\n  }\n\n  /**\n   * Set this as an isolated edge.\n   */\n  _set(v1: Vec2, v2: Vec2): EdgeShape {\n    this.m_vertex1.setVec2(v1);\n    this.m_vertex2.setVec2(v2);\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): EdgeShape {\n    const clone = new EdgeShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_vertex1.setVec2(this.m_vertex1);\n    clone.m_vertex2.setVec2(this.m_vertex2);\n    clone.m_vertex0.setVec2(this.m_vertex0);\n    clone.m_vertex3.setVec2(this.m_vertex3);\n    clone.m_hasVertex0 = this.m_hasVertex0;\n    clone.m_hasVertex3 = this.m_hasVertex3;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // p = p1 + t * d\n    // v = v1 + s * e\n    // p1 + t * d = v1 + s * e\n    // s * e - t * d = p1 - v1\n\n    // NOT_USED(childIndex);\n\n    // Put the ray into the edge's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    const v1 = this.m_vertex1;\n    const v2 = this.m_vertex2;\n    const e = Vec2.sub(v2, v1);\n    const normal = Vec2.neo(e.y, -e.x);\n    normal.normalize();\n\n    // q = p1 + t * d\n    // dot(normal, q - v1) = 0\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n    const numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n    const denominator = Vec2.dot(normal, d);\n\n    if (denominator == 0.0) {\n      return false;\n    }\n\n    const t = numerator / denominator;\n    if (t < 0.0 || input.maxFraction < t) {\n      return false;\n    }\n\n    const q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n\n    // q = v1 + s * r\n    // s = dot(q - v1, r) / dot(r, r)\n    const r = Vec2.sub(v2, v1);\n    const rr = Vec2.dot(r, r);\n    if (rr == 0.0) {\n      return false;\n    }\n\n    const s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n    if (s < 0.0 || 1.0 < s) {\n      return false;\n    }\n\n    output.fraction = t;\n    if (numerator > 0.0) {\n      output.normal = Rot.mulVec2(xf.q, normal).neg();\n    } else {\n      output.normal = Rot.mulVec2(xf.q, normal);\n    }\n    return true;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    const v1 = Transform.mulVec2(xf, this.m_vertex1);\n    const v2 = Transform.mulVec2(xf, this.m_vertex2);\n\n    aabb.combinePoints(v1, v2);\n    aabb.extend(this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices.push(this.m_vertex1);\n    proxy.m_vertices.push(this.m_vertex2);\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n\n}\n\nexport { EdgeShape as Edge };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../../dynamics/Body';\nimport { AABB, RayCastOutput, RayCastInput } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport * as common from '../../util/common';\nimport { Transform } from '../../common/Transform';\nimport { Vec2 } from '../../common/Vec2';\nimport { Settings } from '../../Settings';\nimport { Shape } from '../Shape';\nimport { EdgeShape } from './EdgeShape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A chain shape is a free form sequence of line segments. The chain has\n * two-sided collision, so you can use inside and outside collision. Therefore,\n * you may use any winding order. Connectivity information is used to create\n * smooth collisions.\n *\n * WARNING: The chain will not collide properly if there are self-intersections.\n */\nexport class ChainShape extends Shape {\n  static TYPE = 'chain' as const;\n\n  m_vertices: Vec2[];\n  m_count: number;\n  m_prevVertex: Vec2 | null;\n  m_nextVertex: Vec2 | null;\n  m_hasPrevVertex: boolean;\n  m_hasNextVertex: boolean;\n\n  m_isLoop: boolean;\n\n  constructor(vertices?: Vec2[], loop?: boolean) {\n    // @ts-ignore\n    if (!(this instanceof ChainShape)) {\n      return new ChainShape(vertices, loop);\n    }\n\n    super();\n\n    this.m_type = ChainShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_vertices = [];\n    this.m_count = 0;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n\n    this.m_isLoop = !!loop;\n\n    if (vertices && vertices.length) {\n      if (loop) {\n        this._createLoop(vertices);\n      } else {\n        this._createChain(vertices);\n      }\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const data = {\n      type: this.m_type,\n      vertices: this.m_vertices,\n      isLoop: this.m_isLoop,\n      hasPrevVertex: this.m_hasPrevVertex,\n      hasNextVertex: this.m_hasNextVertex,\n      prevVertex: null as Vec2 | null,\n      nextVertex: null as Vec2 | null,\n    };\n    if (this.m_prevVertex) {\n      data.prevVertex = this.m_prevVertex;\n    }\n    if (this.m_nextVertex) {\n      data.nextVertex = this.m_nextVertex;\n    }\n    return data;\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): ChainShape {\n    const vertices = [] as Vec2[];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n    const shape = new ChainShape(vertices, data.isLoop);\n    if (data.prevVertex) {\n      shape.setPrevVertex(data.prevVertex);\n    }\n    if (data.nextVertex) {\n      shape.setNextVertex(data.nextVertex);\n    }\n    return shape;\n  }\n\n  // clear() {\n  //   this.m_vertices.length = 0;\n  //   this.m_count = 0;\n  // }\n\n  /**\n   * @internal\n   * Create a loop. This automatically adjusts connectivity.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createLoop(vertices: Vec2[]): ChainShape {\n    _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && common.assert(vertices.length >= 3);\n    for (let i = 1; i < vertices.length; ++i) {\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      // If the code crashes here, it means your vertices are too close together.\n      _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_vertices = [];\n    this.m_count = vertices.length + 1;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n    this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n\n    this.m_prevVertex = this.m_vertices[this.m_count - 2];\n    this.m_nextVertex = this.m_vertices[1];\n    this.m_hasPrevVertex = true;\n    this.m_hasNextVertex = true;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Create a chain with isolated end vertices.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createChain(vertices: Vec2[]): ChainShape {\n    _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && common.assert(vertices.length >= 2);\n    for (let i = 1; i < vertices.length; ++i) {\n      // If the code crashes here, it means your vertices are too close together.\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_count = vertices.length;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    return this;\n  }\n\n  /** @internal */\n  _reset(): void {\n    if (this.m_isLoop) {\n      this._createLoop(this.m_vertices);\n    } else {\n      this._createChain(this.m_vertices);\n    }\n  }\n\n  /**\n   * Establish connectivity to a vertex that precedes the first vertex. Don't call\n   * this for loops.\n   */\n  setPrevVertex(prevVertex: Vec2): void {\n    this.m_prevVertex = prevVertex;\n    this.m_hasPrevVertex = true;\n  }\n\n  getPrevVertex(): Vec2 {\n    return this.m_prevVertex;\n  }\n\n  /**\n   * Establish connectivity to a vertex that follows the last vertex. Don't call\n   * this for loops.\n   */\n  setNextVertex(nextVertex: Vec2): void {\n    this.m_nextVertex = nextVertex;\n    this.m_hasNextVertex = true;\n  }\n\n  getNextVertex(): Vec2 {\n    return this.m_nextVertex;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): ChainShape {\n    const clone = new ChainShape();\n    clone._createChain(this.m_vertices);\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_prevVertex = this.m_prevVertex;\n    clone.m_nextVertex = this.m_nextVertex;\n    clone.m_hasPrevVertex = this.m_hasPrevVertex;\n    clone.m_hasNextVertex = this.m_hasNextVertex;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): number {\n    // edge count = vertex count - 1\n    return this.m_count - 1;\n  }\n\n  // Get a child edge.\n  getChildEdge(edge: EdgeShape, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count - 1);\n    edge.m_type = EdgeShape.TYPE;\n    edge.m_radius = this.m_radius;\n\n    edge.m_vertex1 = this.m_vertices[childIndex];\n    edge.m_vertex2 = this.m_vertices[childIndex + 1];\n\n    if (childIndex > 0) {\n      edge.m_vertex0 = this.m_vertices[childIndex - 1];\n      edge.m_hasVertex0 = true;\n    } else {\n      edge.m_vertex0 = this.m_prevVertex;\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\n    }\n\n    if (childIndex < this.m_count - 2) {\n      edge.m_vertex3 = this.m_vertices[childIndex + 2];\n      edge.m_hasVertex3 = true;\n    } else {\n      edge.m_vertex3 = this.m_nextVertex;\n      edge.m_hasVertex3 = this.m_hasNextVertex;\n    }\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index <= this.m_count);\n    if (index < this.m_count) {\n      return this.m_vertices[index];\n    } else {\n      return this.m_vertices[0];\n    }\n  }\n\n  isLoop(): boolean {\n    return this.m_isLoop;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * This always return false.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n    return edgeShape.rayCast(output, input, xf, 0);\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const v1 = Transform.mulVec2(xf, this.getVertex(childIndex));\n    const v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));\n\n    aabb.combinePoints(v1, v2);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * Chains have zero mass.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    massData.center = Vec2.zero();\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n    proxy.m_buffer[0] = this.getVertex(childIndex);\n    proxy.m_buffer[1] = this.getVertex(childIndex + 1);\n    proxy.m_vertices = proxy.m_buffer;\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport { ChainShape as Chain };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../../dynamics/Body';\nimport { AABB, RayCastOutput, RayCastInput } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport common from '../../util/common';\nimport { Math } from '../../common/Math';\nimport { Transform } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2 } from '../../common/Vec2';\nimport { Settings } from '../../Settings';\nimport { Shape } from '../Shape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A convex polygon. It is assumed that the interior of the polygon is to the\n * left of each edge. Polygons have a maximum number of vertices equal to\n * Settings.maxPolygonVertices. In most cases you should not need many vertices\n * for a convex polygon. extends Shape\n */\nexport class PolygonShape extends Shape {\n  static TYPE = 'polygon' as const;\n\n  m_centroid: Vec2;\n  m_vertices: Vec2[]; // [Settings.maxPolygonVertices]\n  m_normals: Vec2[]; // [Settings.maxPolygonVertices]\n  m_count: number;\n\n  // @ts-ignore\n  constructor(vertices?: Vec2[]) {\n    // @ts-ignore\n    if (!(this instanceof PolygonShape)) {\n      return new PolygonShape(vertices);\n    }\n\n    super();\n\n    this.m_type = PolygonShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_centroid = Vec2.zero();\n    this.m_vertices = [];\n    this.m_normals = [];\n    this.m_count = 0;\n\n    if (vertices && vertices.length) {\n      this._set(vertices);\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertices: this.m_vertices,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): PolygonShape {\n    const vertices = [] as Vec2[];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n\n    const shape = new PolygonShape(vertices);\n    return shape;\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): PolygonShape {\n    const clone = new PolygonShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_count = this.m_count;\n    clone.m_centroid.setVec2(this.m_centroid);\n    for (let i = 0; i < this.m_count; i++) {\n      clone.m_vertices.push(this.m_vertices[i].clone());\n    }\n    for (let i = 0; i < this.m_normals.length; i++) {\n      clone.m_normals.push(this.m_normals[i].clone());\n    }\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /** @internal */\n  _reset(): void {\n    this._set(this.m_vertices);\n  }\n\n  /**\n   * @internal\n   *\n   * Create a convex hull from the given array of local points. The count must be\n   * in the range [3, Settings.maxPolygonVertices].\n   *\n   * Warning: the points may be re-ordered, even if they form a convex polygon\n   * Warning: collinear points are handled but not removed. Collinear points may\n   * lead to poor stacking behavior.\n   */\n  _set(vertices: Vec2[]): void {\n    _ASSERT && common.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);\n    if (vertices.length < 3) {\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    let n = Math.min(vertices.length, Settings.maxPolygonVertices);\n\n    // Perform welding and copy vertices into local buffer.\n    const ps = [] as Vec2[]; // [Settings.maxPolygonVertices];\n    for (let i = 0; i < n; ++i) {\n      const v = vertices[i];\n\n      let unique = true;\n      for (let j = 0; j < ps.length; ++j) {\n        if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n          unique = false;\n          break;\n        }\n      }\n\n      if (unique) {\n        ps.push(v);\n      }\n    }\n\n    n = ps.length;\n    if (n < 3) {\n      // Polygon is degenerate.\n      _ASSERT && common.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    // Create the convex hull using the Gift wrapping algorithm\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n\n    // Find the right most point on the hull (in case of multiple points bottom most is used)\n    let i0 = 0;\n    let x0 = ps[0].x;\n    for (let i = 1; i < n; ++i) {\n      const x = ps[i].x;\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n        i0 = i;\n        x0 = x;\n      }\n    }\n\n    const hull = [] as number[]; // [Settings.maxPolygonVertices];\n    let m = 0;\n    let ih = i0;\n\n    while (true) {\n      hull[m] = ih;\n\n      let ie = 0;\n      for (let j = 1; j < n; ++j) {\n        if (ie === ih) {\n          ie = j;\n          continue;\n        }\n\n        const r = Vec2.sub(ps[ie], ps[hull[m]]);\n        const v = Vec2.sub(ps[j], ps[hull[m]]);\n        const c = Vec2.crossVec2Vec2(r, v);\n        // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n        if (c < 0.0) {\n          ie = j;\n        }\n\n        // Collinearity check\n        if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n          ie = j;\n        }\n      }\n\n      ++m;\n      ih = ie;\n\n      if (ie === i0) {\n        break;\n      }\n    }\n\n    if (m < 3) {\n      // Polygon is degenerate.\n      _ASSERT && common.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    this.m_count = m;\n\n    // Copy vertices.\n    this.m_vertices = [];\n    for (let i = 0; i < m; ++i) {\n      this.m_vertices[i] = ps[hull[i]];\n    }\n\n    // Compute normals. Ensure the edges have non-zero length.\n    for (let i = 0; i < m; ++i) {\n      const i1 = i;\n      const i2 = i + 1 < m ? i + 1 : 0;\n      const edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n      _ASSERT && common.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);\n      this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n      this.m_normals[i].normalize();\n    }\n\n    // Compute the polygon centroid.\n    this.m_centroid = ComputeCentroid(this.m_vertices, m);\n  }\n\n  /** @internal */\n  _setAsBox(hx: number, hy: number, center?: Vec2, angle?: number): void {\n    // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n    this.m_vertices[0] = Vec2.neo(hx, -hy);\n    this.m_vertices[1] = Vec2.neo(hx, hy);\n    this.m_vertices[2] = Vec2.neo(-hx, hy);\n    this.m_vertices[3] = Vec2.neo(-hx, -hy);\n\n    this.m_normals[0] = Vec2.neo(1.0, 0.0);\n    this.m_normals[1] = Vec2.neo(0.0, 1.0);\n    this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n    this.m_normals[3] = Vec2.neo(0.0, -1.0);\n\n    this.m_count = 4;\n\n    if (Vec2.isValid(center)) {\n      angle = angle || 0;\n\n      this.m_centroid.setVec2(center);\n\n      const xf = Transform.identity();\n      xf.p.setVec2(center);\n      xf.q.setAngle(angle);\n\n      // Transform vertices and normals.\n      for (let i = 0; i < this.m_count; ++i) {\n        this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n        this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n      }\n    }\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): boolean {\n    const pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));\n\n    for (let i = 0; i < this.m_count; ++i) {\n      const dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));\n      if (dot > 0.0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n\n    // Put the ray into the polygon's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    let lower = 0.0;\n    let upper = input.maxFraction;\n\n    let index = -1;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // p = p1 + a * d\n      // dot(normal, p - v) = 0\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\n      const numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n      const denominator = Vec2.dot(this.m_normals[i], d);\n\n      if (denominator == 0.0) {\n        if (numerator < 0.0) {\n          return false;\n        }\n      } else {\n        // Note: we want this predicate without division:\n        // lower < numerator / denominator, where denominator < 0\n        // Since denominator < 0, we have to flip the inequality:\n        // lower < numerator / denominator <==> denominator * lower > numerator.\n        if (denominator < 0.0 && numerator < lower * denominator) {\n          // Increase lower.\n          // The segment enters this half-space.\n          lower = numerator / denominator;\n          index = i;\n        } else if (denominator > 0.0 && numerator < upper * denominator) {\n          // Decrease upper.\n          // The segment exits this half-space.\n          upper = numerator / denominator;\n        }\n      }\n\n      // The use of epsilon here causes the assert on lower to trip\n      // in some cases. Apparently the use of epsilon was to make edge\n      // shapes work, but now those are handled separately.\n      // if (upper < lower - Math.EPSILON)\n      if (upper < lower) {\n        return false;\n      }\n    }\n\n    _ASSERT && common.assert(0.0 <= lower && lower <= input.maxFraction);\n\n    if (index >= 0) {\n      output.fraction = lower;\n      output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = Transform.mulVec2(xf, this.m_vertices[i]);\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, v.y);\n      maxY = Math.max(maxY, v.y);\n    }\n\n    aabb.lowerBound.setNum(minX, minY);\n    aabb.upperBound.setNum(maxX, maxY);\n    aabb.extend(this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    // Polygon mass, centroid, and inertia.\n    // Let rho be the polygon density in mass per unit area.\n    // Then:\n    // mass = rho * int(dA)\n    // centroid.x = (1/mass) * rho * int(x * dA)\n    // centroid.y = (1/mass) * rho * int(y * dA)\n    // I = rho * int((x*x + y*y) * dA)\n    //\n    // We can compute these integrals by summing all the integrals\n    // for each triangle of the polygon. To evaluate the integral\n    // for a single triangle, we make a change of variables to\n    // the (u,v) coordinates of the triangle:\n    // x = x0 + e1x * u + e2x * v\n    // y = y0 + e1y * u + e2y * v\n    // where 0 <= u && 0 <= v && u + v <= 1.\n    //\n    // We integrate u from [0,1-v] and then v from [0,1].\n    // We also need to use the Jacobian of the transformation:\n    // D = cross(e1, e2)\n    //\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\n    //\n    // The rest of the derivation is handled by computer algebra.\n\n    _ASSERT && common.assert(this.m_count >= 3);\n\n    const center = Vec2.zero();\n    let area = 0.0;\n    let I = 0.0;\n\n    // s is the reference point for forming triangles.\n    // It's location doesn't change the result (except for rounding error).\n    const s = Vec2.zero();\n\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < this.m_count; ++i) {\n      s.add(this.m_vertices[i]);\n    }\n    s.mul(1.0 / this.m_count);\n\n    const k_inv3 = 1.0 / 3.0;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // Triangle vertices.\n      const e1 = Vec2.sub(this.m_vertices[i], s);\n      const e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2 .sub(this.m_vertices[0], s);\n\n      const D = Vec2.crossVec2Vec2(e1, e2);\n\n      const triangleArea = 0.5 * D;\n      area += triangleArea;\n\n      // Area weighted centroid\n      center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);\n\n      const ex1 = e1.x;\n      const ey1 = e1.y;\n      const ex2 = e2.x;\n      const ey2 = e2.y;\n\n      const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n      const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n    }\n\n    // Total mass\n    massData.mass = density * area;\n\n    // Center of mass\n    _ASSERT && common.assert(area > Math.EPSILON);\n    center.mul(1.0 / area);\n    massData.center.setCombine(1, center, 1, s);\n\n    // Inertia tensor relative to the local origin (point s).\n    massData.I = density * I;\n\n    // Shift to center of mass then to original body origin.\n    massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));\n  }\n\n  /**\n   * Validate convexity. This is a very time consuming operation.\n   * @returns true if valid\n   */\n  validate(): boolean {\n    for (let i = 0; i < this.m_count; ++i) {\n      const i1 = i;\n      const i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n      const p = this.m_vertices[i1];\n      const e = Vec2.sub(this.m_vertices[i2], p);\n\n      for (let j = 0; j < this.m_count; ++j) {\n        if (j == i1 || j == i2) {\n          continue;\n        }\n\n        const v = Vec2.sub(this.m_vertices[j], p);\n        const c = Vec2.crossVec2Vec2(e, v);\n        if (c < 0.0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices = this.m_vertices;\n    proxy.m_count = this.m_count;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nfunction ComputeCentroid(vs: Vec2[], count: number): Vec2 {\n  _ASSERT && common.assert(count >= 3);\n\n  const c = Vec2.zero();\n  let area = 0.0;\n\n  // pRef is the reference point for forming triangles.\n  // It's location doesn't change the result (except for rounding error).\n  const pRef = Vec2.zero();\n  if (false) {\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < count; ++i) {\n      pRef.add(vs[i]);\n    }\n    pRef.mul(1.0 / count);\n  }\n\n  const inv3 = 1.0 / 3.0;\n\n  for (let i = 0; i < count; ++i) {\n    // Triangle vertices.\n    const p1 = pRef;\n    const p2 = vs[i];\n    const p3 = i + 1 < count ? vs[i + 1] : vs[0];\n\n    const e1 = Vec2.sub(p2, p1);\n    const e2 = Vec2.sub(p3, p1);\n\n    const D = Vec2.crossVec2Vec2(e1, e2);\n\n    const triangleArea = 0.5 * D;\n    area += triangleArea;\n\n    // Area weighted centroid\n    c.addMul(triangleArea * inv3, p1);\n    c.addMul(triangleArea * inv3, p2);\n    c.addMul(triangleArea * inv3, p3);\n  }\n\n  // Centroid\n  _ASSERT && common.assert(area > Math.EPSILON);\n  c.mul(1.0 / area);\n  return c;\n}\n\nexport { PolygonShape as Polygon };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2 } from '../../common/Vec2';\nimport { PolygonShape } from './PolygonShape';\n\n/**\n * A rectangle polygon which extend PolygonShape.\n */\nexport class BoxShape extends PolygonShape {\n  static TYPE = 'polygon' as const;\n\n  constructor(hx: number, hy: number, center?: Vec2, angle?: number) {\n    // @ts-ignore\n    if (!(this instanceof BoxShape)) {\n      return new BoxShape(hx, hy, center, angle);\n    }\n\n    super();\n\n    this._setAsBox(hx, hy, center, angle);\n  }\n}\n\nexport { BoxShape as Box };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { Math } from '../../common/Math';\nimport { Rot } from '../../common/Rot';\nimport { Vec2 } from '../../common/Vec2';\nimport { Shape } from '../Shape';\nimport { AABB, RayCastInput, RayCastOutput } from '../AABB';\nimport { Transform } from '../../common/Transform';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class CircleShape extends Shape {\n  static TYPE = 'circle' as const;\n\n  m_p: Vec2;\n\n  constructor(position: Vec2, radius?: number);\n  constructor(radius?: number);\n  // tslint:disable-next-line:typedef\n  constructor(a, b?) {\n    // @ts-ignore\n    if (!(this instanceof CircleShape)) {\n      return new CircleShape(a, b);\n    }\n\n    super();\n\n    this.m_type = CircleShape.TYPE;\n    this.m_p = Vec2.zero();\n    this.m_radius = 1;\n\n    if (typeof a === 'object' && Vec2.isValid(a)) {\n      this.m_p.setVec2(a);\n\n      if (typeof b === 'number') {\n        this.m_radius = b;\n      }\n\n    } else if (typeof a === 'number') {\n      this.m_radius = a;\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      p: this.m_p,\n      radius: this.m_radius,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): CircleShape {\n    return new CircleShape(data.p, data.radius);\n  }\n\n  // TODO: already defined in Shape\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getCenter(): Vec2 {\n    return this.m_p;\n  }\n\n  getVertex(index: 0): Vec2 {\n    _ASSERT && common.assert(index == 0);\n    return this.m_p;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): CircleShape {\n    const clone = new CircleShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_p = this.m_p.clone();\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): boolean {\n    const center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const d = Vec2.sub(p, center);\n    return Vec2.dot(d, d) <= this.m_radius * this.m_radius;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n    // From Section 3.1.2\n    // x = s + a * r\n    // norm(x) = radius\n\n    const position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const s = Vec2.sub(input.p1, position);\n    const b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n\n    // Solve quadratic equation.\n    const r = Vec2.sub(input.p2, input.p1);\n    const c = Vec2.dot(s, r);\n    const rr = Vec2.dot(r, r);\n    const sigma = c * c - rr * b;\n\n    // Check for negative discriminant and short segment.\n    if (sigma < 0.0 || rr < Math.EPSILON) {\n      return false;\n    }\n\n    // Find the point of intersection of the line with the circle.\n    let a = -(c + Math.sqrt(sigma));\n\n    // Is the intersection point on the segment?\n    if (0.0 <= a && a <= input.maxFraction * rr) {\n      a /= rr;\n      output.fraction = a;\n      output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n      output.normal.normalize();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    const p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    aabb.lowerBound.setNum(p.x - this.m_radius, p.y - this.m_radius);\n    aabb.upperBound.setNum(p.x + this.m_radius, p.y + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    massData.mass = density * Math.PI * this.m_radius * this.m_radius;\n    massData.center = this.m_p;\n    // inertia about the local origin\n    massData.I = massData.mass\n        * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices.push(this.m_p);\n    proxy.m_count = 1;\n    proxy.m_radius = this.m_radius;\n  }\n\n}\n\nexport { CircleShape as Circle };\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. A value of 0 disables softness.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * Distance length.\n   */\n  length?: number;\n}\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointDef extends JointDef, DistanceJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0\n};\n\n/**\n * A distance joint constrains two points on two bodies to remain at a fixed\n * distance from each other. You can view this as a massless, rigid rod.\n *\n * @param anchorA Anchor A in global coordination.\n * @param anchorB Anchor B in global coordination.\n */\nexport class DistanceJoint extends Joint {\n  static TYPE = 'distance-joint' as const;\n\n  // Solver shared\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_length: number;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_gamma: number;\n  /** @internal */ m_bias: number;\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: DistanceJointDef);\n  constructor(def: DistanceJointOpt, bodyA: Body, bodyB: Body, anchorA: Vec2, anchorB: Vec2);\n  constructor(def: DistanceJointDef, bodyA?: Body, bodyB?: Body, anchorA?: Vec2, anchorB?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof DistanceJoint)) {\n      return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n    }\n\n    // order of constructor arguments is changed in v0.2\n    if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n      const temp = bodyB;\n      bodyB = anchorA as any as Body;\n      anchorA = temp as any as Vec2;\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = DistanceJoint.TYPE;\n\n    // Solver shared\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n    this.m_length = Math.isFinite(def.length) ? def.length :\n      Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n    this.m_impulse = 0.0;\n    this.m_gamma = 0.0;\n    this.m_bias = 0.0;\n\n    // 1-D constrained system\n    // m (v2 - v1) = lambda\n    // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n    // x2 = x1 + h * v2\n\n    // 1-D mass-damper-spring system\n    // m (v2 - v1) + h * d * v2 + h * k *\n\n    // C = norm(p2 - p1) - L\n    // u = (p2 - p1) / norm(p2 - p1)\n    // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n    // J = [-u -cross(r1, u) u cross(r2, u)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      length: this.m_length,\n\n      impulse: this.m_impulse,\n      gamma: this.m_gamma,\n      bias: this.m_bias,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): DistanceJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new DistanceJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    length?: number,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.length > 0) {\n      this.m_length = +def.length;\n    } else if (def.length < 0) { // don't change length\n    } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n      this.m_length = Vec2.distance(\n          this.m_bodyA.getWorldPoint(this.m_localAnchorA),\n          this.m_bodyB.getWorldPoint(this.m_localAnchorB)\n      );\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the natural length. Manipulating the length can lead to non-physical\n   * behavior when the frequency is zero.\n   */\n  setLength(length: number): void {\n    this.m_length = length;\n  }\n\n  /**\n   * Get the natural length.\n   */\n  getLength(): number {\n    return this.m_length;\n  }\n\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n\n    // Handle singularity.\n    const length = this.m_u.length();\n    if (length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / length);\n    } else {\n      this.m_u.setNum(0.0, 0.0);\n    }\n\n    const crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n        + this.m_invIB * crBu * crBu;\n\n    // Compute the effective mass matrix.\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C = length - this.m_length;\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = this.m_mass * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invMass += this.m_gamma;\n      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n    } else {\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n    const Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n\n    const impulse = -this.m_mass\n        * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += impulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    if (this.m_frequencyHz > 0.0) {\n      // There is no position correction for soft distance constraints.\n      return true;\n    }\n\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const length = u.normalize();\n    let C = length - this.m_length;\n    C = Math\n        .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointOpt extends JointOpt {\n  /**\n   * The maximum friction force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum friction torque in N-m.\n   */\n  maxTorque?: number;\n}\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointDef extends JointDef, FrictionJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  maxTorque : 0.0,\n};\n\n/**\n * Friction joint. This is used for top-down friction. It provides 2D\n * translational friction and angular friction.\n *\n * @param anchor Anchor in global coordination.\n */\nexport class FrictionJoint extends Joint {\n  static TYPE = 'friction-joint' as const;\n\n  /** @internal */ m_type: 'friction-joint';\n\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  // Solver shared\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: FrictionJointDef);\n  constructor(def: FrictionJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: FrictionJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof FrictionJoint)) {\n      return new FrictionJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = FrictionJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    // Solver shared\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): FrictionJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new FrictionJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n        * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n        * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt; // float\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA; // float\n      let impulse = -this.m_angularMass * Cdot; // float\n\n      const oldImpulse = this.m_angularImpulse; // float\n      const maxImpulse = h * this.m_maxTorque; // float\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA,\n          Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n      const oldImpulse = this.m_linearImpulse; // Vec2\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce; // float\n\n      if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n        this.m_linearImpulse.normalize();\n        this.m_linearImpulse.mul(maxImpulse);\n      }\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport { Vec2 } from './Vec2';\nimport { Vec3 } from './Vec3';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 3-by-3 matrix. Stored in column-major order.\n */\nexport class Mat33 {\n  ex: Vec3;\n  ey: Vec3;\n  ez: Vec3;\n\n  constructor(a: Vec3, b: Vec3, c: Vec3);\n  constructor();\n  constructor(a?: Vec3, b?: Vec3, c?: Vec3) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec3.clone(a);\n      this.ey = Vec3.clone(b);\n      this.ez = Vec3.clone(c);\n    } else {\n      this.ex = Vec3.zero();\n      this.ey = Vec3.zero();\n      this.ez = Vec3.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Mat33.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Mat33!');\n    }\n  }\n\n  /**\n   * Set this matrix to all zeros.\n   */\n  setZero(): Mat33 {\n    this.ex.setZero();\n    this.ey.setZero();\n    this.ez.setZero();\n    return this;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve33(v: Vec3): Vec3 {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = new Vec3();\n    r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));\n    r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));\n    r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));\n    return r;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n   * equation.\n   */\n  solve22(v: Vec2): Vec2 {\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a21 = this.ex.y;\n    const a22 = this.ey.y;\n    let det = a11 * a22 - a12 * a21;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = Vec2.zero();\n    r.x = det * (a22 * v.x - a12 * v.y);\n    r.y = det * (a11 * v.y - a21 * v.x);\n    return r;\n  }\n\n  /**\n   * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n   * singular.\n   */\n  getInverse22(M: Mat33): void {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    M.ex.x = det * d;\n    M.ey.x = -det * b;\n    M.ex.z = 0.0;\n    M.ex.y = -det * c;\n    M.ey.y = det * a;\n    M.ey.z = 0.0;\n    M.ez.x = 0.0;\n    M.ez.y = 0.0;\n    M.ez.z = 0.0;\n  }\n\n  /**\n   * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n   * if singular.\n   */\n  getSymInverse33(M: Mat33): void {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a13 = this.ez.x;\n    const a22 = this.ey.y;\n    const a23 = this.ez.y;\n    const a33 = this.ez.z;\n\n    M.ex.x = det * (a22 * a33 - a23 * a23);\n    M.ex.y = det * (a13 * a23 - a12 * a33);\n    M.ex.z = det * (a12 * a23 - a13 * a22);\n\n    M.ey.x = M.ex.y;\n    M.ey.y = det * (a11 * a33 - a13 * a13);\n    M.ey.z = det * (a13 * a12 - a11 * a23);\n\n    M.ez.x = M.ex.z;\n    M.ez.y = M.ey.z;\n    M.ez.z = det * (a11 * a22 - a12 * a12);\n  }\n\n  /**\n   * Multiply a matrix times a vector.\n   */\n  static mul(a: Mat33, b: Vec2): Vec2;\n  static mul(a: Mat33, b: Vec3): Vec3;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    _ASSERT && Mat33.assert(a);\n    if (b && 'z' in b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec3.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n      const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n      const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n      return new Vec3(x, y, z);\n\n    } else if (b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec2.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y;\n      const y = a.ex.y * b.x + a.ey.y * b.y;\n      return Vec2.neo(x, y);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulVec3(a: Mat33, b: Vec3): Vec3 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec3.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n    const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n    const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n    return new Vec3(x, y, z);\n  }\n\n  static mulVec2(a: Mat33, b: Vec2): Vec2 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y;\n    const y = a.ex.y * b.x + a.ey.y * b.y;\n    return Vec2.neo(x, y);\n  }\n\n  static add(a: Mat33, b: Mat33): Mat33 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Mat33.assert(b);\n    return new Mat33(\n      Vec3.add(a.ex, b.ex),\n      Vec3.add(a.ey, b.ey),\n      Vec3.add(a.ez, b.ez)\n    );\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointOpt extends JointOpt {\n  /**\n   * The lower angle for the joint limit (radians).\n   */\n  lowerAngle?: number;\n  /**\n   * The upper angle for the joint limit (radians).\n   */\n  upperAngle?: number;\n  /**\n   * The maximum motor torque used to achieve the desired motor speed. Usually\n   * in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed. Usually in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * A flag to enable joint limits.\n   */\n  enableLimit?: boolean;\n  /**\n   * A flag to enable the joint motor.\n   */\n  enableMotor?: boolean;\n}\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointDef extends JointDef, RevoluteJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  lowerAngle : 0.0,\n  upperAngle : 0.0,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  enableLimit : false,\n  enableMotor : false\n};\n\n/**\n * A revolute joint constrains two bodies to share a common point while they are\n * free to rotate about the point. The relative rotation about the shared point\n * is the joint angle. You can limit the relative rotation with a joint limit\n * that specifies a lower and upper angle. You can use a motor to drive the\n * relative rotation about the shared point. A maximum motor torque is provided\n * so that infinite forces are not generated.\n */\nexport class RevoluteJoint extends Joint {\n  static TYPE = 'revolute-joint' as const;\n\n  /** @internal */ m_type: 'revolute-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerAngle: number;\n  /** @internal */ m_upperAngle: number;\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  // effective mass for point-to-point constraint.\n  /** @internal */ m_mass: Mat33 = new Mat33();\n  // effective mass for motor/limit angular constraint.\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_limitState: number = inactiveLimit; // TODO enum\n\n  constructor(def: RevoluteJointDef);\n  constructor(def: RevoluteJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  // @ts-ignore\n  constructor(def: RevoluteJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof RevoluteJoint)) {\n      return new RevoluteJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RevoluteJoint.TYPE;\n\n    this.m_localAnchorA =  Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB =  Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerAngle = def.lowerAngle;\n    this.m_upperAngle = def.upperAngle;\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Motor constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerAngle: this.m_lowerAngle,\n      upperAngle: this.m_upperAngle,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any):RevoluteJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RevoluteJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle in radians.\n   */\n  getJointAngle(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle speed in radians per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_angularVelocity - bA.m_angularVelocity;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step. Unit is N*m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set the motor speed in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set the maximum motor torque, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit in radians.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerAngle;\n  }\n\n  /**\n   * Get the upper joint limit in radians.\n   */\n  getUpperLimit(): number {\n    return this.m_upperAngle;\n  }\n\n  /**\n   * Set the joint limits in radians.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && common.assert(lower <= upper);\n\n    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_impulse.z = 0.0;\n      this.m_lowerAngle = lower;\n      this.m_upperAngle = upper;\n    }\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force given the inverse time step. Unit is N.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque due to the joint limit given the inverse time step.\n   * Unit is N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n        * this.m_rB.y * iB;\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n        * this.m_rB.x * iB;\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    this.m_mass.ex.y = this.m_mass.ey.x;\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n        * this.m_rB.x * iB;\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    this.m_mass.ex.z = this.m_mass.ez.x;\n    this.m_mass.ey.z = this.m_mass.ez.y;\n    this.m_mass.ez.z = iA + iB;\n\n    this.m_motorMass = iA + iB;\n    if (this.m_motorMass > 0.0) {\n      this.m_motorMass = 1.0 / this.m_motorMass;\n    }\n\n    if (this.m_enableMotor == false || fixedRotation) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (this.m_enableLimit && fixedRotation == false) {\n      const jointAngle = aB - aA - this.m_referenceAngle; // float\n\n      if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointAngle <= this.m_lowerAngle) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atLowerLimit;\n\n      } else if (jointAngle >= this.m_upperAngle) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atUpperLimit;\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    // Solve motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits\n        && fixedRotation == false) {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n\n      if (this.m_limitState == equalLimits) {\n        this.m_impulse.add(impulse);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse < 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n\n      } else if (this.m_limitState == atUpperLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse > 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n\n    } else {\n      // Solve point-to-point constraint\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n\n      this.m_impulse.x += impulse.x;\n      this.m_impulse.y += impulse.y;\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    let angularError = 0.0; // float\n    let positionError = 0.0; // float\n\n    const fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n\n    // Solve angular limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const angle = aB - aA - this.m_referenceAngle; // float\n      let limitImpulse = 0.0; // float\n\n      if (this.m_limitState == equalLimits) {\n        // Prevent large angular corrections\n        const C = Math.clamp(angle - this.m_lowerAngle,\n            -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n        limitImpulse = -this.m_motorMass * C;\n        angularError = Math.abs(C);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        let C = angle - this.m_lowerAngle; // float\n        angularError = -C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection,\n            0.0);\n        limitImpulse = -this.m_motorMass * C;\n\n      } else if (this.m_limitState == atUpperLimit) {\n        let C = angle - this.m_upperAngle; // float\n        angularError = C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C - Settings.angularSlop, 0.0,\n            Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n      }\n\n      aA -= this.m_invIA * limitImpulse;\n      aB += this.m_invIB * limitImpulse;\n    }\n\n    // Solve point-to-point constraint.\n    {\n      qA.setAngle(aA);\n      qB.setAngle(aB);\n      const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n      const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n\n      const C = Vec2.zero();\n      C.addCombine(1, cB, 1, rB);\n      C.subCombine(1, cA, 1, rA);\n      positionError = C.length();\n\n      const mA = this.m_invMassA;\n      const mB = this.m_invMassB; // float\n      const iA = this.m_invIA;\n      const iB = this.m_invIB; // float\n\n      const K = new Mat22();\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n\n      const impulse = Vec2.neg(K.solve(C)); // Vec2\n\n      cA.subMul(mA, impulse);\n      aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n\n      cB.addMul(mB, impulse);\n      aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n    }\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit?: boolean;\n  /**\n   * The lower translation limit, usually in meters.\n   */\n  lowerTranslation?: number;\n  /**\n   * The upper translation limit, usually in meters.\n   */\n  upperTranslation?: number;\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorForce?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n}\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointDef extends JointDef, PrismaticJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation unit axis in bodyA.\n   */\n  localAxisA: Vec2;\n  /**\n   * referenceAngle The constrained angle between the bodies:\n   * bodyB_angle - bodyA_angle.\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  enableLimit : false,\n  lowerTranslation : 0.0,\n  upperTranslation : 0.0,\n  enableMotor : false,\n  maxMotorForce : 0.0,\n  motorSpeed : 0.0\n};\n\n/**\n * A prismatic joint. This joint provides one degree of freedom: translation\n * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n * joint limit to restrict the range of motion and a joint motor to drive the\n * motion or to model joint friction.\n */\nexport class PrismaticJoint extends Joint {\n  static TYPE = 'prismatic-joint' as const;\n\n  /** @internal */ m_type: 'prismatic-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerTranslation: number;\n  /** @internal */ m_upperTranslation: number;\n  /** @internal */ m_maxMotorForce: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n  /** @internal */ m_limitState: number; // TODO enum\n  /** @internal */ m_axis: Vec2;\n  /** @internal */ m_perp: Vec2;\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_s1: number;\n  /** @internal */ m_s2: number;\n  /** @internal */ m_a1: number;\n  /** @internal */ m_a2: number;\n  /** @internal */ m_K: Mat33;\n\n  constructor(def: PrismaticJointDef);\n  constructor(def: PrismaticJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  constructor(def: PrismaticJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof PrismaticJoint)) {\n      return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PrismaticJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n    this.m_localXAxisA.normalize();\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerTranslation = def.lowerTranslation;\n    this.m_upperTranslation = def.upperTranslation;\n    this.m_maxMotorForce = def.maxMotorForce;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n    this.m_limitState = inactiveLimit;\n\n    this.m_axis = Vec2.zero();\n    this.m_perp = Vec2.zero();\n\n    this.m_K = new Mat33();\n\n    // Linear constraint (point-to-line)\n    // d = p2 - p1 = x2 + r2 - x1 - r1\n    // C = dot(perp, d)\n    // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n    // cross(w1, r1))\n    // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n    // dot(cross(r2, perp), v2)\n    // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n    //\n    // Angular constraint\n    // C = a2 - a1 + a_initial\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    //\n    // K = J * invM * JT\n    //\n    // J = [-a -s1 a s2]\n    // [0 -1 0 1]\n    // a = perp\n    // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n    // s2 = cross(r2, a) = cross(p2 - x2, a)\n\n    // Motor/Limit linear constraint\n    // C = dot(ax1, d)\n    // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n    // dot(cross(r2, ax1), v2)\n    // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n\n    // Block Solver\n    // We develop a block solver that includes the joint limit. This makes the\n    // limit stiff (inelastic) even\n    // when the mass has poor distribution (leading to large torques about the\n    // joint anchor points).\n    //\n    // The Jacobian has 3 rows:\n    // J = [-uT -s1 uT s2] // linear\n    // [0 -1 0 1] // angular\n    // [-vT -a1 vT a2] // limit\n    //\n    // u = perp\n    // v = axis\n    // s1 = cross(d + r1, u), s2 = cross(r2, u)\n    // a1 = cross(d + r1, v), a2 = cross(r2, v)\n\n    // M * (v2 - v1) = JT * df\n    // J * v2 = bias\n    //\n    // v2 = v1 + invM * JT * df\n    // J * (v1 + invM * JT * df) = bias\n    // K * df = bias - J * v1 = -Cdot\n    // K = J * invM * JT\n    // Cdot = J * v1 - bias\n    //\n    // Now solve for f2.\n    // df = f2 - f1\n    // K * (f2 - f1) = -Cdot\n    // f2 = invK * (-Cdot) + f1\n    //\n    // Clamp accumulated limit impulse.\n    // lower: f2(3) = max(f2(3), 0)\n    // upper: f2(3) = min(f2(3), 0)\n    //\n    // Solve for correct f2(1:2)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n    // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n    // K(1:2,1:2) * f1(1:2)\n    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n    // f1(1:2)\n    //\n    // Now compute impulse to be applied:\n    // df = f2 - f1\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerTranslation: this.m_lowerTranslation,\n      upperTranslation: this.m_upperTranslation,\n      maxMotorForce: this.m_maxMotorForce,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PrismaticJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.localAxisA = Vec2.clone(data.localAxisA);\n    const joint = new PrismaticJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n    const rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n    const p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n    const p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n    const d = Vec2.sub(p2, p1); // Vec2\n    const axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n\n    const vA = bA.m_linearVelocity; // Vec2\n    const vB = bB.m_linearVelocity; // Vec2\n    const wA = bA.m_angularVelocity; // float\n    const wB = bB.m_angularVelocity; // float\n\n    const speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n        + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n    return speed;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit, usually in meters.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerTranslation;\n  }\n\n  /**\n   * Get the upper joint limit, usually in meters.\n   */\n  getUpperLimit(): number {\n    return this.m_upperTranslation;\n  }\n\n  /**\n   * Set the joint limits, usually in meters.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && common.assert(lower <= upper);\n    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_lowerTranslation = lower;\n      this.m_upperTranslation = upper;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in meters per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Set the maximum motor force, usually in N.\n   */\n  setMaxMotorForce(force: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorForce = force;\n  }\n\n  getMaxMotorForce(): number {\n    return this.m_maxMotorForce;\n  }\n\n  /**\n   * Get the motor speed, usually in meters per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Get the current motor force given the inverse time step, usually in N.\n   */\n  getMotorForce(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.y;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute motor Jacobian and effective mass.\n    {\n      this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n      this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n          * this.m_a2;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    }\n\n    // Prismatic constraint.\n    {\n      this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n      this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n      this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n\n      const s1test = Vec2.crossVec2Vec2(rA, this.m_perp);\n\n      const k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n      const k12 = iA * this.m_s1 + iB * this.m_s2;\n      const k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For bodies with fixed rotation.\n        k22 = 1.0;\n      }\n      const k23 = iA * this.m_a1 + iB * this.m_a2;\n      const k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n\n      this.m_K.ex.set(k11, k12, k13);\n      this.m_K.ey.set(k12, k22, k23);\n      this.m_K.ez.set(k13, k23, k33);\n    }\n\n    // Compute motor and limit terms.\n    if (this.m_enableLimit) {\n\n      const jointTranslation = Vec2.dot(this.m_axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointTranslation <= this.m_lowerTranslation) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_limitState = atLowerLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else if (jointTranslation >= this.m_upperTranslation) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_limitState = atUpperLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n      this.m_impulse.z = 0.0;\n    }\n\n    if (this.m_enableMotor == false) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n          + this.m_impulse.z, this.m_axis);\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Solve linear motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits) {\n      const Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n          - this.m_a1 * wA;\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorForce;\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_axis);\n      const LA = impulse * this.m_a1;\n      const LB = impulse * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    const Cdot1 = Vec2.zero();\n    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n    Cdot1.y = wB - wA;\n\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {\n      // Solve prismatic and limit constraint in block form.\n      let Cdot2 = 0;\n      Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n      Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const f1 = Vec3.clone(this.m_impulse);\n      let df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n      this.m_impulse.add(df);\n\n      if (this.m_limitState == atLowerLimit) {\n        this.m_impulse.z = Math.max(this.m_impulse.z, 0.0);\n      } else if (this.m_limitState == atUpperLimit) {\n        this.m_impulse.z = Math.min(this.m_impulse.z, 0.0);\n      }\n\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n      // f1(1:2)\n      const b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n      const f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n      this.m_impulse.x = f2r.x;\n      this.m_impulse.y = f2r.y;\n\n      df = Vec3.sub(this.m_impulse, f1);\n\n      const P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n      const LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n      const LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      // Limit is inactive, just solve the prismatic constraint in block form.\n      const df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n      this.m_impulse.x += df.x;\n      this.m_impulse.y += df.y;\n\n      const P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n      const LA = df.x * this.m_s1 + df.y; // float\n      const LB = df.x * this.m_s2 + df.y; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute fresh Jacobians\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n    const d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n\n    const axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n    const a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n    const a2 = Vec2.crossVec2Vec2(rB, axis); // float\n    const perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n\n    const s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n    const s2 = Vec2.crossVec2Vec2(rB, perp); // float\n\n    let impulse = new Vec3();\n    const C1 = Vec2.zero(); // Vec2\n    C1.x = Vec2.dot(perp, d);\n    C1.y = aB - aA - this.m_referenceAngle;\n\n    let linearError = Math.abs(C1.x); // float\n    const angularError = Math.abs(C1.y); // float\n\n    const linearSlop = Settings.linearSlop;\n    const maxLinearCorrection = Settings.maxLinearCorrection;\n\n    let active = false; // bool\n    let C2 = 0.0; // float\n    if (this.m_enableLimit) {\n\n      const translation = Vec2.dot(axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n        // Prevent large angular corrections\n        C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n        linearError = Math.max(linearError, Math.abs(translation));\n        active = true;\n\n      } else if (translation <= this.m_lowerTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop,\n            -maxLinearCorrection, 0.0);\n        linearError = Math\n            .max(linearError, this.m_lowerTranslation - translation);\n        active = true;\n\n      } else if (translation >= this.m_upperTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,\n            maxLinearCorrection);\n        linearError = Math\n            .max(linearError, translation - this.m_upperTranslation);\n        active = true;\n      }\n    }\n\n    if (active) {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      const k13 = iA * s1 * a1 + iB * s2 * a2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        // For fixed rotation\n        k22 = 1.0;\n      }\n      const k23 = iA * a1 + iB * a2; // float\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n\n      const K = new Mat33();\n      K.ex.set(k11, k12, k13);\n      K.ey.set(k12, k22, k23);\n      K.ez.set(k13, k23, k33);\n\n      const C = new Vec3();\n      C.x = C1.x;\n      C.y = C1.y;\n      C.z = C2;\n\n      impulse = K.solve33(Vec3.neg(C));\n    } else {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        k22 = 1.0;\n      }\n\n      const K = new Mat22();\n      K.ex.setNum(k11, k12);\n      K.ey.setNum(k12, k22);\n\n      const impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n      impulse.x = impulse1.x;\n      impulse.y = impulse1.y;\n      impulse.z = 0.0;\n    }\n\n    const P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n\n    cA.subMul(mA, P);\n    aA -= iA * LA;\n    cB.addMul(mB, P);\n    aB += iB * LB;\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { RevoluteJoint } from './RevoluteJoint';\nimport { PrismaticJoint } from './PrismaticJoint';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Gear joint definition.\n */\nexport interface GearJointOpt extends JointOpt {\n  /**\n   * The gear ratio. See {@link GearJoint} for explanation.\n   */\n  ratio?: number;\n}\n/**\n * Gear joint definition.\n */\nexport interface GearJointDef extends JointDef, GearJointOpt {\n  /**\n   * The first revolute/prismatic joint attached to the gear joint.\n   */\n  joint1: RevoluteJoint | PrismaticJoint;\n  /**\n   * The second prismatic/revolute joint attached to the gear joint.\n   */\n  joint2: RevoluteJoint | PrismaticJoint;\n}\n\nconst DEFAULTS = {\n  ratio : 1.0\n};\n\n/**\n * A gear joint is used to connect two joints together. Either joint can be a\n * revolute or prismatic joint. You specify a gear ratio to bind the motions\n * together: coordinate1 + ratio * coordinate2 = constant\n *\n * The ratio can be negative or positive. If one joint is a revolute joint and\n * the other joint is a prismatic joint, then the ratio will have units of\n * length or units of 1/length. Warning: You have to manually destroy the gear\n * joint if joint1 or joint2 is destroyed.\n *\n * This definition requires two existing revolute or prismatic joints (any\n * combination will work).\n */\nexport class GearJoint extends Joint {\n  static TYPE = 'gear-joint' as const;\n\n  /** @internal */ m_type: 'gear-joint';\n  /** @internal */ m_joint1: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_joint2: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_type1: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_type2: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_bodyC: Body;\n  /** @internal */ m_localAnchorC: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_referenceAngleA: number;\n  /** @internal */ m_localAxisC: Vec2;\n  /** @internal */ m_bodyD: Body;\n  /** @internal */ m_localAnchorD: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngleB: number;\n  /** @internal */ m_localAxisD: Vec2;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_lcA: Vec2;\n  /** @internal */ m_lcB: Vec2;\n  /** @internal */ m_lcC: Vec2;\n  /** @internal */ m_lcD: Vec2;\n  /** @internal */ m_mA: number;\n  /** @internal */ m_mB: number;\n  /** @internal */ m_mC: number;\n  /** @internal */ m_mD: number;\n  /** @internal */ m_iA: number;\n  /** @internal */ m_iB: number;\n  /** @internal */ m_iC: number;\n  /** @internal */ m_iD: number;\n  /** @internal */ m_JvAC: Vec2;\n  /** @internal */ m_JvBD: Vec2;\n  /** @internal */ m_JwA: number;\n  /** @internal */ m_JwB: number;\n  /** @internal */ m_JwC: number;\n  /** @internal */ m_JwD: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: GearJointDef);\n  constructor(def: GearJointOpt, bodyA: Body, bodyB: Body, joint1: RevoluteJoint | PrismaticJoint, joint2: RevoluteJoint | PrismaticJoint, ratio?: number);\n  constructor(def: GearJointDef, bodyA?: Body, bodyB?: Body, joint1?: RevoluteJoint | PrismaticJoint, joint2?: RevoluteJoint | PrismaticJoint, ratio?: number) {\n    // @ts-ignore\n    if (!(this instanceof GearJoint)) {\n      return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = GearJoint.TYPE;\n\n    _ASSERT && common.assert(joint1.m_type === RevoluteJoint.TYPE\n        || joint1.m_type === PrismaticJoint.TYPE);\n    _ASSERT && common.assert(joint2.m_type === RevoluteJoint.TYPE\n        || joint2.m_type === PrismaticJoint.TYPE);\n\n    this.m_joint1 = joint1 ? joint1 : def.joint1;\n    this.m_joint2 = joint2 ? joint2 : def.joint2;\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    this.m_type1 = this.m_joint1.getType() as 'revolute-joint' | 'prismatic-joint';\n    this.m_type2 = this.m_joint2.getType() as 'revolute-joint' | 'prismatic-joint';\n\n    // joint1 connects body A to body C\n    // joint2 connects body B to body D\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    // TODO_ERIN there might be some problem with the joint edges in Joint.\n\n    this.m_bodyC = this.m_joint1.getBodyA();\n    this.m_bodyA = this.m_joint1.getBodyB();\n\n    // Get geometry of joint1\n    const xfA = this.m_bodyA.m_xf;\n    const aA = this.m_bodyA.m_sweep.a;\n    const xfC = this.m_bodyC.m_xf;\n    const aC = this.m_bodyC.m_sweep.a;\n\n    if (this.m_type1 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint1 as RevoluteJoint;\n      this.m_localAnchorC = revolute.m_localAnchorA;\n      this.m_localAnchorA = revolute.m_localAnchorB;\n      this.m_referenceAngleA = revolute.m_referenceAngle;\n      this.m_localAxisC = Vec2.zero();\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const prismatic = this.m_joint1 as PrismaticJoint;\n      this.m_localAnchorC = prismatic.m_localAnchorA;\n      this.m_localAnchorA = prismatic.m_localAnchorB;\n      this.m_referenceAngleA = prismatic.m_referenceAngle;\n      this.m_localAxisC = prismatic.m_localXAxisA;\n\n      const pC = this.m_localAnchorC;\n      const pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n      coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);\n    }\n\n    this.m_bodyD = this.m_joint2.getBodyA();\n    this.m_bodyB = this.m_joint2.getBodyB();\n\n    // Get geometry of joint2\n    const xfB = this.m_bodyB.m_xf;\n    const aB = this.m_bodyB.m_sweep.a;\n    const xfD = this.m_bodyD.m_xf;\n    const aD = this.m_bodyD.m_sweep.a;\n\n    if (this.m_type2 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint2 as RevoluteJoint;\n      this.m_localAnchorD = revolute.m_localAnchorA;\n      this.m_localAnchorB = revolute.m_localAnchorB;\n      this.m_referenceAngleB = revolute.m_referenceAngle;\n      this.m_localAxisD = Vec2.zero();\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const prismatic = this.m_joint2 as PrismaticJoint;\n      this.m_localAnchorD = prismatic.m_localAnchorA;\n      this.m_localAnchorB = prismatic.m_localAnchorB;\n      this.m_referenceAngleB = prismatic.m_referenceAngle;\n      this.m_localAxisD = prismatic.m_localXAxisA;\n\n      const pD = this.m_localAnchorD;\n      const pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    this.m_constant = coordinateA + this.m_ratio * coordinateB;\n\n    this.m_impulse = 0.0;\n\n    // Gear Joint:\n    // C0 = (coordinate1 + ratio * coordinate2)_initial\n    // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n    // J = [J1 ratio * J2]\n    // K = J * invM * JT\n    // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n    //\n    // Revolute:\n    // coordinate = rotation\n    // Cdot = angularVelocity\n    // J = [0 0 1]\n    // K = J * invM * JT = invI\n    //\n    // Prismatic:\n    // coordinate = dot(p - pg, ug)\n    // Cdot = dot(v + cross(w, r), ug)\n    // J = [ug cross(r, ug)]\n    // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      joint1: this.m_joint1,\n      joint2: this.m_joint2,\n      ratio: this.m_ratio,\n\n      // _constant: this.m_constant,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): GearJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.joint1 = restore(Joint, data.joint1, world);\n    data.joint2 = restore(Joint, data.joint2, world);\n    const joint = new GearJoint(data);\n    // if (data._constant) joint.m_constant = data._constant;\n    return joint;\n  }\n\n  /**\n   * Get the first joint.\n   */\n  getJoint1(): Joint {\n    return this.m_joint1;\n  }\n\n  /**\n   * Get the second joint.\n   */\n  getJoint2(): Joint {\n    return this.m_joint2;\n  }\n\n  /**\n   * Set the gear ratio.\n   */\n  setRatio(ratio: number): void {\n    _ASSERT && common.assert(Math.isFinite(ratio));\n    this.m_ratio = ratio;\n  }\n\n  /**\n   * Get the gear ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    const L = this.m_impulse * this.m_JwA; // float\n    return inv_dt * L;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n    this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n    this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n    this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n    this.m_mA = this.m_bodyA.m_invMass;\n    this.m_mB = this.m_bodyB.m_invMass;\n    this.m_mC = this.m_bodyC.m_invMass;\n    this.m_mD = this.m_bodyD.m_invMass;\n    this.m_iA = this.m_bodyA.m_invI;\n    this.m_iB = this.m_bodyB.m_invI;\n    this.m_iC = this.m_bodyC.m_invI;\n    this.m_iD = this.m_bodyD.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const aC = this.m_bodyC.c_position.a;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n\n    const aD = this.m_bodyD.c_position.a;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    this.m_mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      this.m_JvAC = Vec2.zero();\n      this.m_JwA = 1.0;\n      this.m_JwC = 1.0;\n      this.m_mass += this.m_iA + this.m_iC;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      this.m_JvAC = u;\n      this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n      this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n      this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      this.m_JvBD = Vec2.zero();\n      this.m_JwB = this.m_ratio;\n      this.m_JwD = this.m_ratio;\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n      this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n    }\n\n    // Compute effective mass.\n    this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n\n    if (step.warmStarting) {\n      vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n      wA += this.m_iA * this.m_impulse * this.m_JwA;\n\n      vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n      wB += this.m_iB * this.m_impulse * this.m_JwB;\n\n      vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n      wC -= this.m_iC * this.m_impulse * this.m_JwC;\n\n      vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n      wD -= this.m_iD * this.m_impulse * this.m_JwD;\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    let Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n        + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n    Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n        + (this.m_JwB * wB - this.m_JwD * wD);\n\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    vA.addMul(this.m_mA * impulse, this.m_JvAC);\n    wA += this.m_iA * impulse * this.m_JwA;\n    vB.addMul(this.m_mB * impulse, this.m_JvBD);\n    wB += this.m_iB * impulse * this.m_JwB;\n    vC.subMul(this.m_mC * impulse, this.m_JvAC);\n    wC -= this.m_iC * impulse * this.m_JwC;\n    vD.subMul(this.m_mD * impulse, this.m_JvBD);\n    wD -= this.m_iD * impulse * this.m_JwD;\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n    const cC = this.m_bodyC.c_position.c;\n    let aC = this.m_bodyC.c_position.a;\n    const cD = this.m_bodyD.c_position.c;\n    let aD = this.m_bodyD.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    const linearError = 0.0;\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    let JvAC: Vec2;\n    let JvBD: Vec2;\n    let JwA: number;\n    let JwB: number;\n    let JwC: number;\n    let JwD: number;\n    let mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      JvAC = Vec2.zero();\n      JwA = 1.0;\n      JwC = 1.0;\n      mass += this.m_iA + this.m_iC;\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      JvAC = u;\n      JwC = Vec2.crossVec2Vec2(rC, u);\n      JwA = Vec2.crossVec2Vec2(rA, u);\n      mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n\n      const pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n      const pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n      coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      JvBD = Vec2.zero();\n      JwB = this.m_ratio;\n      JwD = this.m_ratio;\n      mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n          * JwD * JwD + this.m_iB * JwB * JwB;\n\n      const pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n      const pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n      coordinateB = Vec2.dot(pB, this.m_localAxisD)\n          - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n\n    let impulse = 0.0; // float\n    if (mass > 0.0) {\n      impulse = -C / mass;\n    }\n\n    cA.addMul(this.m_mA * impulse, JvAC);\n    aA += this.m_iA * impulse * JwA;\n    cB.addMul(this.m_mB * impulse, JvBD);\n    aB += this.m_iB * impulse * JwB;\n    cC.subMul(this.m_mC * impulse, JvAC);\n    aC -= this.m_iC * impulse * JwC;\n    cD.subMul(this.m_mD * impulse, JvBD);\n    aD -= this.m_iD * impulse * JwD;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n    this.m_bodyC.c_position.c.setVec2(cC);\n    this.m_bodyC.c_position.a = aC;\n    this.m_bodyD.c_position.c.setVec2(cD);\n    this.m_bodyD.c_position.a = aD;\n\n    // TODO_ERIN not implemented\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Motor joint definition.\n */\nexport interface MotorJointOpt extends JointOpt {\n  /**\n   * The bodyB angle minus bodyA angle in radians.\n   */\n  angularOffset?: number;\n  /**\n   * The maximum motor force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum motor torque in N-m.\n   */\n  maxTorque?: number;\n  /**\n   * Position correction factor in the range [0,1].\n   */\n  correctionFactor?: number;\n  /**\n   * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n   */\n  linearOffset?: Vec2;\n}\n/**\n * Motor joint definition.\n */\nexport interface MotorJointDef extends JointDef, MotorJointOpt {\n}\n\nconst DEFAULTS = {\n  maxForce : 1.0,\n  maxTorque : 1.0,\n  correctionFactor : 0.3\n};\n\n/**\n * A motor joint is used to control the relative motion between two bodies. A\n * typical usage is to control the movement of a dynamic body with respect to\n * the ground.\n */\nexport class MotorJoint extends Joint {\n  static TYPE = 'motor-joint' as const;\n\n  /** @internal */ m_type: 'motor-joint';\n  /** @internal */ m_linearOffset: Vec2;\n  /** @internal */ m_angularOffset: number;\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n  /** @internal */ m_correctionFactor: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_linearError: Vec2;\n  /** @internal */ m_angularError: number;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: MotorJointDef);\n  constructor(def: MotorJointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: MotorJointDef | MotorJointOpt, bodyA?: Body, bodyB?: Body) {\n    // @ts-ignore\n    if (!(this instanceof MotorJoint)) {\n      return new MotorJoint(def, bodyA, bodyB);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MotorJoint.TYPE;\n\n    this.m_linearOffset = Math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n    this.m_angularOffset = Math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n    this.m_correctionFactor = def.correctionFactor;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n      correctionFactor: this.m_correctionFactor,\n\n      linearOffset: this.m_linearOffset,\n      angularOffset: this.m_angularOffset,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MotorJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new MotorJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {}): void {\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Set the position correction factor in the range [0,1].\n   */\n  setCorrectionFactor(factor: number): void {\n    _ASSERT && common.assert(Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);\n    this.m_correctionFactor = factor;\n  }\n\n  /**\n   * Get the position correction factor in the range [0,1].\n   */\n  getCorrectionFactor(): number {\n    return this.m_correctionFactor;\n  }\n\n  /**\n   * Set/get the target linear offset, in frame A, in meters.\n   */\n  setLinearOffset(linearOffset: Vec2): void {\n    if (linearOffset.x != this.m_linearOffset.x\n        || linearOffset.y != this.m_linearOffset.y) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_linearOffset = linearOffset;\n    }\n  }\n\n  getLinearOffset(): Vec2 {\n    return this.m_linearOffset;\n  }\n\n  /**\n   * Set/get the target angular offset, in radians.\n   */\n  setAngularOffset(angularOffset: number): void {\n    if (angularOffset != this.m_angularOffset) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_angularOffset = angularOffset;\n    }\n  }\n\n  getAngularOffset(): number {\n    return this.m_angularOffset;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getPosition();\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getPosition();\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    this.m_linearError = Vec2.zero();\n    this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n    this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n    this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));\n\n    this.m_angularError = aB - aA - this.m_angularOffset;\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n    const inv_h = step.inv_dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = Vec2.clone(this.m_linearImpulse);\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      this.m_linearImpulse.clamp(maxImpulse);\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Transform } from '../../common/Transform';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointOpt extends JointOpt {\n  /**\n   * [maxForce = 0.0] The maximum constraint force that can be exerted to move\n   * the candidate body. Usually you will express as some multiple of the\n   * weight (multiplier * mass * gravity).\n   */\n  maxForce?: number;\n  /**\n   * [frequencyHz = 5.0] The response speed.\n   */\n  frequencyHz?: number;\n  /**\n   * [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical\n   * damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointDef extends JointDef, MouseJointOpt {\n  /**\n   * The initial world target point. This is assumed to coincide with the body\n   * anchor initially.\n   */\n  target: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  frequencyHz : 5.0,\n  dampingRatio : 0.7\n};\n\n/**\n * A mouse joint is used to make a point on a body track a specified world\n * point. This a soft constraint with a maximum force. This allows the\n * constraint to stretch and without applying huge forces.\n *\n * NOTE: this joint is not documented in the manual because it was developed to\n * be used in the testbed. If you want to learn how to use the mouse joint, look\n * at the testbed.\n */\nexport class MouseJoint extends Joint {\n  static TYPE = 'mouse-joint' as const;\n\n  /** @internal */ m_type: 'mouse-joint';\n  /** @internal */ m_targetA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_impulse: Vec2;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_beta: number;\n  /** @internal */ m_gamma: number;\n  // Solver temp\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat22;\n  /** @internal */ m_C: Vec2;\n\n  constructor(def: MouseJointDef);\n  constructor(def: MouseJointOpt, bodyA: Body, bodyB: Body, target: Vec2);\n  constructor(def: MouseJointDef, bodyA?: Body, bodyB?: Body, target?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof MouseJoint)) {\n      return new MouseJoint(def, bodyA, bodyB, target);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MouseJoint.TYPE;\n\n    _ASSERT && common.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);\n\n    this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();\n    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);\n\n    this.m_maxForce = def.maxForce;\n    this.m_impulse = Vec2.zero();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_beta = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rB = Vec2.zero();\n    this.m_localCenterB = Vec2.zero();\n    this.m_invMassB = 0.0;\n    this.m_invIB = 0.0;\n    this.m_mass = new Mat22();\n    this.m_C = Vec2.zero();\n\n    // p = attached point, m = mouse point\n    // C = p - m\n    // Cdot = v\n    // = v + cross(w, r)\n    // J = [I r_skew]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      target: this.m_targetA,\n      maxForce: this.m_maxForce,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      _localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MouseJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.target = Vec2.clone(data.target);\n    const joint = new MouseJoint(data);\n    if (data._localAnchorB) {\n      joint.m_localAnchorB = data._localAnchorB;\n    }\n    return joint;\n  }\n\n  /**\n   * Use this to update the target point.\n   */\n  setTarget(target: Vec2): void {\n    if (this.m_bodyB.isAwake() == false) {\n      this.m_bodyB.setAwake(true);\n    }\n    this.m_targetA = Vec2.clone(target);\n  }\n\n  getTarget(): Vec2 {\n    return this.m_targetA;\n  }\n\n  /**\n   * Set the maximum force in Newtons.\n   */\n  setMaxForce(force: number): void {\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum force in Newtons.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the frequency in Hertz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get the frequency in Hertz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set the damping ratio (dimensionless).\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get the damping ratio (dimensionless).\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return Vec2.clone(this.m_targetA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * 0.0;\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_targetA.sub(newOrigin);\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const position = this.m_bodyB.c_position;\n    const velocity = this.m_bodyB.c_velocity;\n\n    const cB = position.c;\n    const aB = position.a;\n    const vB = velocity.v;\n    let wB = velocity.w;\n\n    const qB = Rot.neo(aB);\n\n    const mass = this.m_bodyB.getMass();\n\n    // Frequency\n    const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n    // Damping coefficient\n    const d = 2.0 * mass * this.m_dampingRatio * omega;\n\n    // Spring stiffness\n    const k = mass * (omega * omega);\n\n    // magic formulas\n    // gamma has units of inverse mass.\n    // beta has units of inverse time.\n    const h = step.dt;\n    _ASSERT && common.assert(d + h * k > Math.EPSILON);\n    this.m_gamma = h * (d + h * k);\n    if (this.m_gamma != 0.0) {\n      this.m_gamma = 1.0 / this.m_gamma;\n    }\n    this.m_beta = h * k * this.m_gamma;\n\n    // Compute the effective mass matrix.\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n    // invI2 * skew(r2)]\n    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n    // -r1.x*r1.y]\n    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n    const K = new Mat22();\n    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n        + this.m_gamma;\n    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n        + this.m_gamma;\n\n    this.m_mass = K.getInverse();\n\n    this.m_C.setVec2(cB);\n    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n    this.m_C.mul(this.m_beta);\n\n    // Cheat with some damping\n    wB *= 0.98;\n\n    if (step.warmStarting) {\n      this.m_impulse.mul(step.dtRatio);\n      vB.addMul(this.m_invMassB, this.m_impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const velocity = this.m_bodyB.c_velocity;\n    const vB = Vec2.clone(velocity.v);\n    let wB = velocity.w;\n\n    // Cdot = v + cross(w, r)\n\n    const Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n    Cdot.add(vB);\n\n    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n    Cdot.neg();\n\n    let impulse = Mat22.mulVec2(this.m_mass, Cdot);\n\n    const oldImpulse = Vec2.clone(this.m_impulse);\n    this.m_impulse.add(impulse);\n    const maxImpulse = step.dt * this.m_maxForce;\n    this.m_impulse.clamp(maxImpulse);\n    impulse = Vec2.sub(this.m_impulse, oldImpulse);\n\n    vB.addMul(this.m_invMassB, impulse);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\n// tslint:disable-next-line:no-empty-interface\nexport interface PulleyJointOpt extends JointOpt {\n}\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\nexport interface PulleyJointDef extends JointDef, PulleyJointOpt {\n  /**\n   * The first ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorA: Vec2;\n  /**\n   * The second ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorB: Vec2;\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The reference length for the segment attached to bodyA.\n   */\n  lengthA: number;\n  /**\n   * The reference length for the segment attached to bodyB.\n   */\n  lengthB: number;\n  /**\n   * The pulley ratio, used to simulate a block-and-tackle.\n   */\n  ratio: number;\n}\n\nconst DEFAULTS = {\n  collideConnected : true\n};\n\n/**\n * The pulley joint is connected to two bodies and two fixed ground points. The\n * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n *\n * Yes, the force transmitted is scaled by the ratio.\n *\n * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n * better when combined with prismatic joints. You should also cover the the\n * anchor points with static shapes to prevent one side from going to zero\n * length.\n */\nexport class PulleyJoint extends Joint {\n  static TYPE = 'pulley-joint' as const;\n  // static MIN_PULLEY_LENGTH: number = 2.0; // TODO where this is used?\n\n  /** @internal */ m_type: 'pulley-joint';\n  /** @internal */ m_groundAnchorA: Vec2;\n  /** @internal */ m_groundAnchorB: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_lengthA: number;\n  /** @internal */ m_lengthB: number;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_uA: Vec2;\n  /** @internal */ m_uB: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: PulleyJointDef);\n  constructor(def: PulleyJointOpt, bodyA: Body, bodyB: Body, groundA: Vec2, groundB: Vec2, anchorA: Vec2, anchorB: Vec2, ratio: number);\n  constructor(def: PulleyJointDef, bodyA?: Body, bodyB?: Body, groundA?: Vec2, groundB?: Vec2, anchorA?: Vec2, anchorB?: Vec2, ratio?: number) {\n    // @ts-ignore\n    if (!(this instanceof PulleyJoint)) {\n      return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PulleyJoint.TYPE;\n    this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n    this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n    this.m_lengthA = Math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n    this.m_lengthB = Math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    _ASSERT && common.assert(ratio > Math.EPSILON);\n\n    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;\n\n    this.m_impulse = 0.0;\n\n    // Pulley:\n    // length1 = norm(p1 - s1)\n    // length2 = norm(p2 - s2)\n    // C0 = (length1 + ratio * length2)_initial\n    // C = C0 - (length1 + ratio * length2)\n    // u1 = (p1 - s1) / norm(p1 - s1)\n    // u2 = (p2 - s2) / norm(p2 - s2)\n    // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n    // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n    // cross(r2, u2)^2)\n  }\n\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      groundAnchorA: this.m_groundAnchorA,\n      groundAnchorB: this.m_groundAnchorB,\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      lengthA: this.m_lengthA,\n      lengthB: this.m_lengthB,\n      ratio: this.m_ratio,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PulleyJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new PulleyJoint(data);\n    return joint;\n  }\n\n  /**\n   * Get the first ground anchor.\n   */\n  getGroundAnchorA(): Vec2 {\n    return this.m_groundAnchorA;\n  }\n\n  /**\n   * Get the second ground anchor.\n   */\n  getGroundAnchorB(): Vec2 {\n    return this.m_groundAnchorB;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getLengthA(): number {\n    return this.m_lengthA;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getLengthB(): number {\n    return this.m_lengthB;\n  }\n\n  /**\n   * Get the pulley ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getCurrentLengthA(): number {\n    const p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const s = this.m_groundAnchorA;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getCurrentLengthB(): number {\n    const p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const s = this.m_groundAnchorB;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   *\n   * @param newOrigin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_groundAnchorA.sub(newOrigin);\n    this.m_groundAnchorB.sub(newOrigin);\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = this.m_uA.length();\n    const lengthB = this.m_uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      this.m_uA.mul(1.0 / lengthA);\n    } else {\n      this.m_uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      this.m_uB.mul(1.0 / lengthB);\n    } else {\n      this.m_uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n    const ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (this.m_mass > 0.0) {\n      this.m_mass = 1.0 / this.m_mass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support variable time steps.\n      this.m_impulse *= step.dtRatio;\n\n      // Warm starting.\n      const PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n      const PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n\n      vA.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n\n      vB.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n\n    const Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n        * Vec2.dot(this.m_uB, vpB); // float\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    const PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n    vA.addMul(this.m_invMassA, PA);\n    wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n    vB.addMul(this.m_invMassB, PB);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    const uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    const uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = uA.length();\n    const lengthB = uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      uA.mul(1.0 / lengthA);\n    } else {\n      uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      uB.mul(1.0 / lengthB);\n    } else {\n      uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(rA, uA);\n    const ruB = Vec2.crossVec2Vec2(rB, uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    let mass = mA + this.m_ratio * this.m_ratio * mB; // float\n\n    if (mass > 0.0) {\n      mass = 1.0 / mass;\n    }\n\n    const C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n    const linearError = Math.abs(C); // float\n\n    const impulse = -mass * C; // float\n\n    const PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n\n    cA.addMul(this.m_invMassA, PA);\n    aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n    cB.addMul(this.m_invMassB, PB);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointOpt extends JointOpt {\n  /**\n   * The maximum length of the rope.\n   * Warning: this must be larger than linearSlop or the joint will have no effect.\n   */\n  maxLength?: number;\n}\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointDef extends JointDef, RopeJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxLength : 0.0,\n};\n\n/**\n * A rope joint enforces a maximum distance between two points on two bodies. It\n * has no other effect.\n *\n * Warning: if you attempt to change the maximum length during the simulation\n * you will get some non-physical behavior.\n *\n * A model that would allow you to dynamically modify the length would have some\n * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n * want to dynamically control length.\n */\nexport class RopeJoint extends Joint {\n  static TYPE = 'rope-joint' as const;\n\n  /** @internal */ m_type: 'rope-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  /** @internal */ m_maxLength: number;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_length: number;\n  /** @internal */ m_state: number; // TODO enum\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  constructor(def: RopeJointDef);\n  constructor(def: RopeJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: RopeJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof RopeJoint)) {\n      return new RopeJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RopeJoint.TYPE;\n    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n\n    this.m_maxLength = def.maxLength;\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_length = 0.0;\n    this.m_state = inactiveLimit;\n\n    // Limit:\n    // C = norm(pB - pA) - L\n    // u = (pB - pA) / norm(pB - pA)\n    // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n    // J = [-u -cross(rA, u) u cross(rB, u)]\n    // K = J * invM * JT\n    // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      maxLength: this.m_maxLength,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): RopeJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RopeJoint(data);\n    return joint;\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum length of the rope.\n   */\n  setMaxLength(length: number): void {\n    this.m_maxLength = length;\n  }\n\n  /**\n   * Get the maximum length of the rope.\n   */\n  getMaxLength(): number {\n    return this.m_maxLength;\n  }\n\n  getLimitState(): number {\n    // TODO LimitState\n    return this.m_state;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    this.m_u = Vec2.zero();\n    this.m_u.addCombine(1, cB, 1, this.m_rB);\n    this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n\n    this.m_length = this.m_u.length();\n\n    const C = this.m_length - this.m_maxLength; // float\n    if (C > 0.0) {\n      this.m_state = atUpperLimit;\n    } else {\n      this.m_state = inactiveLimit;\n    }\n\n    if (this.m_length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / this.m_length);\n    } else {\n      this.m_u.setZero();\n      this.m_mass = 0.0;\n      this.m_impulse = 0.0;\n      return;\n    }\n\n    // Compute effective mass.\n    const crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n    const crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n    const invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n        + this.m_invIB * crB * crB; // float\n\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n    const vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n    const C = this.m_length - this.m_maxLength; // float\n    let Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n\n    // Predictive constraint.\n    if (C < 0.0) {\n      Cdot += step.inv_dt * C;\n    }\n\n    let impulse = -this.m_mass * Cdot; // float\n    const oldImpulse = this.m_impulse; // float\n    this.m_impulse = Math.min(0.0, this.m_impulse + impulse);\n    impulse = this.m_impulse - oldImpulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c; // Vec2\n    let aA = this.m_bodyA.c_position.a; // float\n    const cB = this.m_bodyB.c_position.c; // Vec2\n    let aB = this.m_bodyB.c_position.a; // float\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.zero();\n    u.addCombine(1, cB, 1, rB);\n    u.subCombine(1, cA, 1, rA); // Vec2\n\n    const length = u.normalize(); // float\n    let C = length - this.m_maxLength; // float\n\n    C = Math.clamp(C, 0.0, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C; // float\n    const P = Vec2.mulNumVec2(impulse, u); // Vec2\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return length - this.m_maxLength < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n *\n * @prop {float} frequencyHz\n * @prop {float} dampingRatio\n *\n * @prop {Vec2} localAnchorA\n * @prop {Vec2} localAnchorB\n * @prop {float} referenceAngle\n */\nexport interface WeldJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness\n   * with a value of 0.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle?: number;\n}\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n */\nexport interface WeldJointDef extends JointDef, WeldJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0,\n};\n\n/**\n * A weld joint essentially glues two bodies together. A weld joint may distort\n * somewhat because the island constraint solver is approximate.\n */\nexport class WeldJoint extends Joint {\n  static TYPE = 'weld-joint' as const\n\n  /** @internal */ m_type: 'weld-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_impulse: Vec3;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat33;\n\n  constructor(def: WeldJointDef);\n  constructor(def: WeldJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: WeldJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof WeldJoint)) {\n      return new WeldJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WeldJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_impulse = new Vec3();\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rA; // Vec2\n    this.m_rB; // Vec2\n    this.m_localCenterA; // Vec2\n    this.m_localCenterB; // Vec2\n    this.m_invMassA; // float\n    this.m_invMassB; // float\n    this.m_invIA; // float\n    this.m_invIB; // float\n    this.m_mass = new Mat33();\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // C = angle2 - angle1 - referenceAngle\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WeldJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WeldJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Set frequency in Hz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get frequency in Hz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set damping ratio.\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get damping ratio.\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n        * iB;\n    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n        * iB;\n    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      K.getInverse22(this.m_mass);\n\n      let invM = iA + iB; // float\n      const m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n\n      const C = aB - aA - this.m_referenceAngle; // float\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n      // Damping coefficient\n      const d = 2.0 * m * this.m_dampingRatio * omega; // float\n\n      // Spring stiffness\n      const k = m * omega * omega; // float\n\n      // magic formulas\n      const h = step.dt; // float\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invM += this.m_gamma;\n      this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n    } else if (K.ez.z == 0.0) {\n      K.getInverse22(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    } else {\n      K.getSymInverse33(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    if (this.m_frequencyHz > 0.0) {\n      const Cdot2 = wB - wA; // float\n\n      const impulse2 = -this.m_mass.ez.z\n          * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n      this.m_impulse.z += impulse2;\n\n      wA -= iA * impulse2;\n      wB += iB * impulse2;\n\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n\n      const impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n      this.m_impulse.x += impulse1.x;\n      this.m_impulse.y += impulse1.y;\n\n      const P = Vec2.clone(impulse1); // Vec2\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n    } else {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n\n      const impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n      this.m_impulse.add(impulse);\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    let positionError: number;\n    let angularError: number;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n    K.ez.x = -rA.y * iA - rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n    K.ez.y = rA.x * iA + rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA); // Vec2\n\n      positionError = C1.length();\n      angularError = 0.0;\n\n      const P = Vec2.neg(K.solve22(C1)); // Vec2\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    } else {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      const C2 = aB - aA - this.m_referenceAngle; // float\n\n      positionError = C1.length();\n      angularError = Math.abs(C2);\n\n      const C = new Vec3(C1.x, C1.y, C2);\n\n      let impulse = new Vec3();\n      if (K.ez.z > 0.0) {\n        impulse = Vec3.neg(K.solve33(C));\n      } else {\n        const impulse2 = Vec2.neg(K.solve22(C1));\n        impulse.set(impulse2.x, impulse2.y, 0.0);\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      cA.subMul(mA, P);\n      aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n\n      cB.addMul(mB, P);\n      aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { Settings } from '../../Settings';\nimport { Math } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * Suspension frequency, zero indicates no suspension.\n   */\n  frequencyHz?: number;\n  /**\n   * Suspension damping ratio, one indicates critical damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointDef extends JointDef, WheelJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation axis in bodyA.\n   */\n  localAxisA: Vec2;\n}\n\nconst DEFAULTS = {\n  enableMotor : false,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  frequencyHz : 2.0,\n  dampingRatio : 0.7,\n};\n\n/**\n * A wheel joint. This joint provides two degrees of freedom: translation along\n * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n * point to line constraint with a rotational motor and a linear spring/damper.\n * This joint is designed for vehicle suspensions.\n */\nexport class WheelJoint extends Joint {\n  static TYPE = 'wheel-joint' as const;\n\n  /** @internal */ m_type: 'wheel-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_springMass: number;\n  /** @internal */ m_springImpulse: number;\n\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableMotor: boolean;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  /** @internal */ m_ax: Vec2 = Vec2.zero();\n  /** @internal */ m_ay: Vec2 = Vec2.zero();\n  /** @internal */ m_sAx: number;\n  /** @internal */ m_sBx: number;\n  /** @internal */ m_sAy: number;\n  /** @internal */ m_sBy: number;\n\n  constructor(def: WheelJointDef);\n  constructor(def: WheelJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  // @ts-ignore\n  constructor(def: WheelJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof WheelJoint)) {\n      return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WheelJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    // @ts-ignore localAxis\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n    this.m_springMass = 0.0;\n    this.m_springImpulse = 0.0;\n\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableMotor = def.enableMotor;\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Linear constraint (point-to-line)\n    // d = pB - pA = xB + rB - xA - rA\n    // C = dot(ay, d)\n    // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n    // rA))\n    // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n    // ay), vB)\n    // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n\n    // Spring linear constraint\n    // C = dot(ax, d)\n    // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n    // dot(cross(rB, ax), vB)\n    // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n\n    // Motor rotational constraint\n    // Cdot = wB - wA\n    // J = [0 0 -1 0 0 1]\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      enableMotor: this.m_enableMotor,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WheelJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WheelJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n    const pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n    const d = Vec2.sub(pB, pA); // Vec2\n    const axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n\n    const translation = Vec2.dot(d, axis); // float\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const wA = this.m_bodyA.m_angularVelocity;\n    const wB = this.m_bodyB.m_angularVelocity;\n    return wB - wA;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed, usually in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set/Get the maximum motor force, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step, usually in N-m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n   * the spring.\n   */\n  setSpringFrequencyHz(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getSpringFrequencyHz(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set/Get the spring damping ratio\n   */\n  setSpringDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getSpringDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA); // Vec2\n\n    // Point to line constraint\n    {\n      this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n      this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n\n      this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n          * this.m_sBy;\n\n      if (this.m_mass > 0.0) {\n        this.m_mass = 1.0 / this.m_mass;\n      }\n    }\n\n    // Spring constraint\n    this.m_springMass = 0.0;\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n    if (this.m_frequencyHz > 0.0) {\n      this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n      this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n\n      const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n          * this.m_sBx; // float\n\n      if (invMass > 0.0) {\n        this.m_springMass = 1.0 / invMass;\n\n        const C = Vec2.dot(d, this.m_ax); // float\n\n        // Frequency\n        const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n        // Damping coefficient\n        const damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n\n        // Spring stiffness\n        const k = this.m_springMass * omega * omega; // float\n\n        // magic formulas\n        const h = step.dt; // float\n        this.m_gamma = h * (damp + h * k);\n        if (this.m_gamma > 0.0) {\n          this.m_gamma = 1.0 / this.m_gamma;\n        }\n\n        this.m_bias = C * h * k * this.m_gamma;\n\n        this.m_springMass = invMass + this.m_gamma;\n        if (this.m_springMass > 0.0) {\n          this.m_springMass = 1.0 / this.m_springMass;\n        }\n      }\n    } else {\n      this.m_springImpulse = 0.0;\n    }\n\n    // Rotational motor\n    if (this.m_enableMotor) {\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    } else {\n      this.m_motorMass = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse *= step.dtRatio;\n      this.m_springImpulse *= step.dtRatio;\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n      const LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n      const LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * LA;\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * LB;\n\n    } else {\n      this.m_impulse = 0.0;\n      this.m_springImpulse = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Solve spring constraint\n    {\n      const Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n          * wB - this.m_sAx * wA; // float\n      const impulse = -this.m_springMass\n          * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n      this.m_springImpulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n      const LA = impulse * this.m_sAx; // float\n      const LB = impulse * this.m_sBx; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    // Solve rotational motor constraint\n    {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve point to line constraint\n    {\n      const Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n          * wB - this.m_sAy * wA; // float\n      const impulse = -this.m_mass * Cdot; // float\n      this.m_impulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n      const LA = impulse * this.m_sAy; // float\n      const LB = impulse * this.m_sBy; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const ay = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n    const sBy = Vec2.crossVec2Vec2(rB, ay); // float\n\n    const C = Vec2.dot(d, ay); // float\n\n    const k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n        * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n\n    let impulse; // float\n    if (k != 0.0) {\n      impulse = -C / k;\n    } else {\n      impulse = 0.0;\n    }\n\n    const P = Vec2.mulNumVec2(impulse, ay); // Vec2\n    const LA = impulse * sAy; // float\n    const LB = impulse * sBy; // float\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * LA;\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * LB;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) <= Settings.linearSlop;\n  }\n\n}\n","// tslint:disable:typedef\nimport { World } from '../dynamics/World';\nimport { Body } from '../dynamics/Body';\nimport { Joint } from '../dynamics/Joint';\nimport { Fixture } from '../dynamics/Fixture';\nimport { Shape } from '../collision/Shape';\nimport { Vec2 } from '../common/Vec2';\nimport { Vec3 } from '../common/Vec3';\nimport { ChainShape } from \"../collision/shape/ChainShape\";\nimport { BoxShape } from \"../collision/shape/BoxShape\";\nimport { EdgeShape } from \"../collision/shape/EdgeShape\";\nimport { PolygonShape } from \"../collision/shape/PolygonShape\";\nimport { CircleShape } from \"../collision/shape/CircleShape\";\nimport { DistanceJoint } from \"../dynamics/joint/DistanceJoint\";\nimport { FrictionJoint } from \"../dynamics/joint/FrictionJoint\";\nimport { GearJoint } from \"../dynamics/joint/GearJoint\";\nimport { MotorJoint } from \"../dynamics/joint/MotorJoint\";\nimport { MouseJoint } from \"../dynamics/joint/MouseJoint\";\nimport { PrismaticJoint } from \"../dynamics/joint/PrismaticJoint\";\nimport { PulleyJoint } from \"../dynamics/joint/PulleyJoint\";\nimport { RevoluteJoint } from \"../dynamics/joint/RevoluteJoint\";\nimport { RopeJoint } from \"../dynamics/joint/RopeJoint\";\nimport { WeldJoint } from \"../dynamics/joint/WeldJoint\";\nimport { WheelJoint } from \"../dynamics/joint/WheelJoint\";\n\nlet SID = 0;\n\nexport function Serializer(opts?) {\n  opts = opts || {};\n\n  const rootClass = opts.rootClass || World;\n\n  const preSerialize = opts.preSerialize || function(obj) { return obj; };\n  const postSerialize = opts.postSerialize || function(data, obj) { return data; };\n\n  const preDeserialize = opts.preDeserialize || function(data) { return data; };\n  const postDeserialize = opts.postDeserialize || function(obj, data) { return obj; };\n\n  // This is used to create ref objects during serialize\n  const refTypes = {\n    World,\n    Body,\n    Joint,\n    Fixture,\n    Shape,\n  };\n\n  // This is used by restore to deserialize objects and refs\n  const restoreTypes = {\n    Vec2,\n    Vec3,\n    ...refTypes\n  };\n\n  const CLASS_BY_TYPE_PROP = {\n    [Body.STATIC]: Body,\n    [Body.DYNAMIC]: Body,\n    [Body.KINEMATIC]: Body,\n    [ChainShape.TYPE]: ChainShape,\n    [BoxShape.TYPE]: BoxShape,\n    [EdgeShape.TYPE]: EdgeShape,\n    [PolygonShape.TYPE]: PolygonShape,\n    [CircleShape.TYPE]: CircleShape,\n    [DistanceJoint.TYPE]: DistanceJoint,\n    [FrictionJoint.TYPE]: FrictionJoint,\n    [GearJoint.TYPE]: GearJoint,\n    [MotorJoint.TYPE]: MotorJoint,\n    [MouseJoint.TYPE]: MouseJoint,\n    [PrismaticJoint.TYPE]: PrismaticJoint,\n    [PulleyJoint.TYPE]: PulleyJoint,\n    [RevoluteJoint.TYPE]: RevoluteJoint,\n    [RopeJoint.TYPE]: RopeJoint,\n    [WeldJoint.TYPE]: WeldJoint,\n    [WheelJoint.TYPE]: WheelJoint,\n  }\n\n  this.toJson = function(root) {\n    const json = [];\n\n    const queue = [root];\n    const refMap = {};\n\n    function storeRef(value, typeName) {\n      value.__sid = value.__sid || ++SID;\n      if (!refMap[value.__sid]) {\n        queue.push(value);\n        const index = json.length + queue.length;\n        const ref = {\n          refIndex: index,\n          refType: typeName\n        };\n        refMap[value.__sid] = ref;\n      }\n      return refMap[value.__sid];\n    }\n\n    function serialize(obj) {\n      obj = preSerialize(obj);\n      let data = obj._serialize();\n      data = postSerialize(data, obj);\n      return data;\n    }\n\n    function toJson(value, top?) {\n      if (typeof value !== 'object' || value === null) {\n        return value;\n      }\n      if (typeof value._serialize === 'function') {\n        if (value !== top) {\n          // tslint:disable-next-line:no-for-in\n          for (const typeName in refTypes) {\n            if (value instanceof refTypes[typeName]) {\n              return storeRef(value, typeName);\n            }\n          }\n        }\n        value = serialize(value);\n      }\n      if (Array.isArray(value)) {\n        const newValue = [];\n        for (let key = 0; key < value.length; key++) {\n          newValue[key] = toJson(value[key]);\n        }\n        value = newValue;\n\n      } else {\n        const newValue = {};\n        // tslint:disable-next-line:no-for-in\n        for (const key in value) {\n          if (value.hasOwnProperty(key)) {\n            newValue[key] = toJson(value[key]);\n          }\n        }\n        value = newValue;\n      }\n      return value;\n    }\n\n    while (queue.length) {\n      const obj = queue.shift();\n      const str = toJson(obj, obj);\n      json.push(str);\n    }\n\n    return json;\n  };\n\n  this.fromJson = function(json: object) {\n    const refMap = {};\n\n    function findDeserilizer(data, cls) {\n      if (!cls || !cls._deserialize) {\n        cls = CLASS_BY_TYPE_PROP[data.type]\n      }\n      return cls && cls._deserialize;\n    }\n\n    /**\n     * Deserialize a data object.\n     */\n    function deserialize(cls, data, ctx) {\n      const deserializer = findDeserilizer(data, cls);\n      if (!deserializer) {\n        return;\n      }\n      data = preDeserialize(data);\n      let obj = deserializer(data, ctx, restoreRef);\n      obj = postDeserialize(obj, data);\n      return obj;\n    }\n\n    /**\n     * Restore a ref object or deserialize a data object.\n     *\n     * This is passed as callback to class deserializers.\n     */\n    function restoreRef(cls, ref, ctx) {\n      if (!ref.refIndex) {\n        return cls && cls._deserialize && deserialize(cls, ref, ctx);\n      }\n      cls = restoreTypes[ref.refType] || cls;\n      const index = ref.refIndex;\n      if (!refMap[index]) {\n        const data = json[index];\n        const obj = deserialize(cls, data, ctx);\n        refMap[index] = obj;\n      }\n      return refMap[index];\n    }\n\n    const root = rootClass._deserialize(json[0], null, restoreRef);\n\n    return root;\n  };\n}\n\nconst serializer = new Serializer();\n\nSerializer.toJson = serializer.toJson;\nSerializer.fromJson = serializer.fromJson;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport common from '../../util/common';\nimport { Transform } from '../../common/Transform';\nimport { Vec2 } from '../../common/Vec2';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n\nfunction CircleCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == CircleShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollideCircles(manifold, fixtureA.getShape() as CircleShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nexport function CollideCircles(manifold: Manifold, circleA: CircleShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  const pA = Transform.mulVec2(xfA, circleA.m_p);\n  const pB = Transform.mulVec2(xfB, circleB.m_p);\n\n  const distSqr = Vec2.distanceSquared(pB, pA);\n  const rA = circleA.m_radius;\n  const rB = circleB.m_radius;\n  const radius = rA + rB;\n  if (distSqr > radius * radius) {\n    return;\n  }\n\n  manifold.type = ManifoldType.e_circles;\n  manifold.localPoint.setVec2(circleA.m_p);\n  manifold.localNormal.setZero();\n  manifold.pointCount = 1;\n  manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.cf.indexA = 0;\n  manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n  manifold.points[0].id.cf.indexB = 0;\n  manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { Transform } from '../../common/Transform';\nimport { Vec2 } from '../../common/Vec2';\nimport { Contact } from '../../dynamics/Contact';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n\nfunction EdgeCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == EdgeShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const shapeA = fixtureA.getShape() as EdgeShape;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nfunction ChainCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == ChainShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const chain = fixtureA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  const shapeA = edge;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\n// Compute contact points for edge versus circle.\n// This accounts for edge connectivity.\nexport function CollideEdgeCircle(manifold: Manifold, edgeA: EdgeShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  // Compute circle in frame of edge\n  const Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));\n\n  const A = edgeA.m_vertex1;\n  const B = edgeA.m_vertex2;\n  const e = Vec2.sub(B, A);\n\n  // Barycentric coordinates\n  const u = Vec2.dot(e, Vec2.sub(B, Q));\n  const v = Vec2.dot(e, Vec2.sub(Q, A));\n\n  const radius = edgeA.m_radius + circleB.m_radius;\n\n  // Region A\n  if (v <= 0.0) {\n    const P = Vec2.clone(A);\n    const d = Vec2.sub(Q, P);\n    const dd = Vec2.dot(d, d);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to A?\n    if (edgeA.m_hasVertex0) {\n      const A1 = edgeA.m_vertex0;\n      const B1 = A;\n      const e1 = Vec2.sub(B1, A1);\n      const u1 = Vec2.dot(e1, Vec2.sub(B1, Q));\n\n      // Is the circle in Region AB of the previous edge?\n      if (u1 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    manifold.localNormal.setZero();\n    manifold.localPoint.setVec2(P);\n    manifold.pointCount = 1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Region B\n  if (u <= 0.0) {\n    const P = Vec2.clone(B);\n    const d = Vec2.sub(Q, P);\n    const dd = Vec2.dot(d, d);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to B?\n    if (edgeA.m_hasVertex3) {\n      const B2 = edgeA.m_vertex3;\n      const A2 = B;\n      const e2 = Vec2.sub(B2, A2);\n      const v2 = Vec2.dot(e2, Vec2.sub(Q, A2));\n\n      // Is the circle in Region AB of the next edge?\n      if (v2 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    manifold.localNormal.setZero();\n    manifold.localPoint.setVec2(P);\n    manifold.pointCount = 1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 1;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Region AB\n  const den = Vec2.dot(e, e);\n  _ASSERT && common.assert(den > 0.0);\n  const P = Vec2.combine(u / den, A, v / den, B);\n  const d = Vec2.sub(Q, P);\n  const dd = Vec2.dot(d, d);\n  if (dd > radius * radius) {\n    return;\n  }\n\n  const n = Vec2.neo(-e.y, e.x);\n  if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) {\n    n.setNum(-n.x, -n.y);\n  }\n  n.normalize();\n\n  manifold.type = ManifoldType.e_faceA;\n  manifold.localNormal = n;\n  manifold.localPoint.setVec2(A);\n  manifold.pointCount = 1;\n  manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.cf.indexA = 0;\n  manifold.points[0].id.cf.typeA = ContactFeatureType.e_face;\n  manifold.points[0].id.cf.indexB = 0;\n  manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { Transform } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2 } from '../../common/Vec2';\nimport { Settings } from '../../Settings';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { Contact } from '../../dynamics/Contact';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n\nfunction PolygonContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == PolygonShape.TYPE);\n  CollidePolygons(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as PolygonShape, xfB);\n}\n\ninterface MaxSeparation {\n  maxSeparation: number;\n  bestIndex: number;\n}\n\n/**\n * Find the max separation between poly1 and poly2 using edge normals from\n * poly1.\n */\nfunction findMaxSeparation(poly1: PolygonShape, xf1: Transform, poly2: PolygonShape, xf2: Transform, output: MaxSeparation): void {\n  const count1 = poly1.m_count;\n  const count2 = poly2.m_count;\n  const n1s = poly1.m_normals;\n  const v1s = poly1.m_vertices;\n  const v2s = poly2.m_vertices;\n  const xf = Transform.mulTXf(xf2, xf1);\n\n  let bestIndex = 0;\n  let maxSeparation = -Infinity;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    const n = Rot.mulVec2(xf.q, n1s[i]);\n    const v1 = Transform.mulVec2(xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    let si = Infinity;\n    for (let j = 0; j < count2; ++j) {\n      const sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // used to keep last FindMaxSeparation call values\n  output.maxSeparation = maxSeparation;\n  output.bestIndex = bestIndex;\n}\n\nfunction findIncidentEdge(c: ClipVertex[], poly1: PolygonShape, xf1: Transform, edge1: number, poly2: PolygonShape, xf2: Transform): void {\n  const normals1 = poly1.m_normals;\n\n  const count2 = poly2.m_count;\n  const vertices2 = poly2.m_vertices;\n  const normals2 = poly2.m_normals;\n\n  _ASSERT && common.assert(0 <= edge1 && edge1 < poly1.m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  const normal1 = Rot.mulTVec2(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Infinity;\n  for (let i = 0; i < count2; ++i) {\n    const dot = Vec2.dot(normal1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  c[0].v = Transform.mulVec2(xf2, vertices2[i1]);\n  c[0].id.cf.indexA = edge1;\n  c[0].id.cf.indexB = i1;\n  c[0].id.cf.typeA = ContactFeatureType.e_face;\n  c[0].id.cf.typeB = ContactFeatureType.e_vertex;\n\n  c[1].v = Transform.mulVec2(xf2, vertices2[i2]);\n  c[1].id.cf.indexA = edge1;\n  c[1].id.cf.indexB = i2;\n  c[1].id.cf.typeA = ContactFeatureType.e_face;\n  c[1].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n\nconst maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0,\n};\n\n/**\n *\n * Find edge normal of max separation on A - return if separating axis is found<br>\n * Find edge normal of max separation on B - return if separation axis is found<br>\n * Choose reference edge as min(minA, minB)<br>\n * Find incident edge<br>\n * Clip\n *\n * The normal points from 1 to 2\n */\nexport function CollidePolygons(manifold: Manifold, polyA: PolygonShape, xfA: Transform, polyB: PolygonShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n  const totalRadius = polyA.m_radius + polyB.m_radius;\n\n  findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n  const edgeA = maxSeparation.bestIndex;\n  const separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n\n  findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n  const edgeB = maxSeparation.bestIndex;\n  const separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n\n  let poly1; // reference polygon\n  let poly2; // incident polygon\n  let xf1;\n  let xf2;\n  let edge1; // reference edge\n  let flip;\n  const k_tol = 0.1 * Settings.linearSlop;\n\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = 1;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = 0;\n  }\n\n  const incidentEdge = [ new ClipVertex(), new ClipVertex() ];\n  findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  const count1 = poly1.m_count;\n  const vertices1 = poly1.m_vertices;\n\n  const iv1 = edge1;\n  const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  let v11 = vertices1[iv1];\n  let v12 = vertices1[iv2];\n\n  const localTangent = Vec2.sub(v12, v11);\n  localTangent.normalize();\n\n  const localNormal = Vec2.crossVec2Num(localTangent, 1.0);\n  const planePoint = Vec2.combine(0.5, v11, 0.5, v12);\n\n  const tangent = Rot.mulVec2(xf1.q, localTangent);\n  const normal = Vec2.crossVec2Num(tangent, 1.0);\n\n  v11 = Transform.mulVec2(xf1, v11);\n  v12 = Transform.mulVec2(xf1, v12);\n\n  // Face offset.\n  const frontOffset = Vec2.dot(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  const sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;\n  const sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n  const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n  let np;\n\n  // Clip to box side 1\n  np = clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);\n\n  if (np < 2) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\n\n  if (np < 2) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  manifold.localNormal = localNormal;\n  manifold.localPoint = planePoint;\n\n  let pointCount = 0;\n  for (let i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {\n    const separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius) {\n      const cp = manifold.points[pointCount];\n      cp.localPoint.setVec2(Transform.mulTVec2(xf2, clipPoints2[i].v));\n      cp.id = clipPoints2[i].id;\n      if (flip) {\n        // Swap features\n        const cf = cp.id.cf;\n        const indexA = cf.indexA;\n        const indexB = cf.indexB;\n        const typeA = cf.typeA;\n        const typeB = cf.typeB;\n        cf.indexA = indexB;\n        cf.indexB = indexA;\n        cf.typeA = typeB;\n        cf.typeB = typeA;\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { Math } from '../../common/Math';\nimport { Transform } from '../../common/Transform';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Settings } from '../../Settings';\nimport { Contact } from '../../dynamics/Contact';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n\nfunction EdgePolygonContact(manifold: Manifold, xfA: Transform, fA: Fixture, indexA: number, xfB: Transform, fB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fA.getType() == EdgeShape.TYPE);\n  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);\n\n  CollideEdgePolygon(manifold, fA.getShape() as EdgeShape, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nfunction ChainPolygonContact(manifold: Manifold, xfA: Transform, fA: Fixture, indexA: number, xfB: Transform, fB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fA.getType() == ChainShape.TYPE);\n  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);\n\n  const chain = fA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  CollideEdgePolygon(manifold, edge, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nenum EPAxisType {\n  e_unknown = -1,\n  e_edgeA = 1,\n  e_edgeB = 2,\n}\n\n// unused?\nenum VertexType {\n e_isolated = 0,\n e_concave = 1,\n e_convex = 2,\n}\n\n/**\n * This structure is used to keep track of the best separating axis.\n */\nclass EPAxis {\n  type: EPAxisType;\n  index: number;\n  separation: number;\n}\n\n/**\n * This holds polygon B expressed in frame A.\n */\nclass TempPolygon {\n  vertices: Vec2[] = []; // [Settings.maxPolygonVertices]\n  normals: Vec2[] = []; // [Settings.maxPolygonVertices];\n  count: number = 0;\n}\n\n/**\n * Reference face used for clipping\n */\nclass ReferenceFace {\n  i1: number;\n  i2: number;\n  v1: Vec2;\n  v2: Vec2;\n  normal: Vec2 = Vec2.zero();\n  sideNormal1: Vec2 = Vec2.zero();\n  sideOffset1: number;\n  sideNormal2: Vec2 = Vec2.zero();\n  sideOffset2: number;\n}\n\n// reused\nconst edgeAxis = new EPAxis();\nconst polygonAxis = new EPAxis();\nconst polygonBA = new TempPolygon();\nconst rf = new ReferenceFace();\n\n/**\n * This function collides and edge and a polygon, taking into account edge\n * adjacency.\n */\nexport function CollideEdgePolygon(manifold: Manifold, edgeA: EdgeShape, xfA: Transform, polygonB: PolygonShape, xfB: Transform): void {\n  // Algorithm:\n  // 1. Classify v1 and v2\n  // 2. Classify polygon centroid as front or back\n  // 3. Flip normal if necessary\n  // 4. Initialize normal range to [-pi, pi] about face normal\n  // 5. Adjust normal range according to adjacent edges\n  // 6. Visit each separating axes, only accept axes within the range\n  // 7. Return if _any_ axis indicates separation\n  // 8. Clip\n\n  // let m_type1: VertexType;\n  // let m_type2: VertexType;\n\n  const xf = Transform.mulTXf(xfA, xfB);\n\n  const centroidB = Transform.mulVec2(xf, polygonB.m_centroid);\n\n  const v0 = edgeA.m_vertex0;\n  const v1 = edgeA.m_vertex1;\n  const v2 = edgeA.m_vertex2;\n  const v3 = edgeA.m_vertex3;\n\n  const hasVertex0 = edgeA.m_hasVertex0;\n  const hasVertex3 = edgeA.m_hasVertex3;\n\n  const edge1 = Vec2.sub(v2, v1);\n  edge1.normalize();\n  const normal1 = Vec2.neo(edge1.y, -edge1.x);\n  const offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));\n  let offset0 = 0.0;\n  let offset2 = 0.0;\n  let convex1 = false;\n  let convex2 = false;\n\n  let normal0;\n  let normal2;\n\n  // Is there a preceding edge?\n  if (hasVertex0) {\n    const edge0 = Vec2.sub(v1, v0);\n    edge0.normalize();\n    normal0 = Vec2.neo(edge0.y, -edge0.x);\n    convex1 = Vec2.crossVec2Vec2(edge0, edge1) >= 0.0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n\n  // Is there a following edge?\n  if (hasVertex3) {\n    const edge2 = Vec2.sub(v3, v2);\n    edge2.normalize();\n    normal2 = Vec2.neo(edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n  }\n\n  let front;\n  const normal = Vec2.zero();\n  const lowerLimit = Vec2.zero();\n  const upperLimit = Vec2.zero();\n\n  // Determine front or back collision. Determine collision normal limits.\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setMul(-1, normal0);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setMul(-1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0.0 || offset1 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setMul(-1, normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal1);\n      }\n    } else {\n      front = offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setVec2(normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0.0;\n    if (front) {\n      normal.setVec2(normal1);\n      lowerLimit.setMul(-1, normal1);\n      upperLimit.setMul(-1, normal1);\n    } else {\n      normal.setMul(-1, normal1);\n      lowerLimit.setVec2(normal1);\n      upperLimit.setVec2(normal1);\n    }\n  }\n\n  // Get polygonB in frameA\n  polygonBA.count = polygonB.m_count;\n  for (let i = 0; i < polygonB.m_count; ++i) {\n    polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);\n    polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);\n  }\n\n  const radius = 2.0 * Settings.polygonRadius;\n\n  manifold.pointCount = 0;\n\n  { // ComputeEdgeSeparation\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));\n      if (s < edgeAxis.separation) {\n        edgeAxis.separation = s;\n      }\n    }\n  }\n\n  // If no valid normal can be found than this edge should not collide.\n  // @ts-ignore\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n\n  { // ComputePolygonSeparation\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n\n    const perp = Vec2.neo(-normal.y, normal.x);\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const n = Vec2.neg(polygonBA.normals[i]);\n\n      const s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));\n      const s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));\n      const s = Math.min(s1, s2);\n\n      if (s > radius) {\n        // No collision\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n        break;\n      }\n\n      // Adjacency\n      if (Vec2.dot(n, perp) >= 0.0) {\n        if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {\n          continue;\n        }\n      } else {\n        if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {\n          continue;\n        }\n      }\n\n      if (s > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n      }\n    }\n  }\n\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n\n  // Use hysteresis for jitter reduction.\n  const k_relativeTol = 0.98;\n  const k_absoluteTol = 0.001;\n\n  let primaryAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n\n  const ie = [ new ClipVertex(), new ClipVertex() ];\n\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n\n    // Search for the polygon normal that is most anti-parallel to the edge\n    // normal.\n    let bestIndex = 0;\n    let bestValue = Vec2.dot(normal, polygonBA.normals[0]);\n    for (let i = 1; i < polygonBA.count; ++i) {\n      const value = Vec2.dot(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n\n    const i1 = bestIndex;\n    const i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n\n    ie[0].v = polygonBA.vertices[i1];\n    ie[0].id.cf.indexA = 0;\n    ie[0].id.cf.indexB = i1;\n    ie[0].id.cf.typeA = ContactFeatureType.e_face;\n    ie[0].id.cf.typeB = ContactFeatureType.e_vertex;\n\n    ie[1].v = polygonBA.vertices[i2];\n    ie[1].id.cf.indexA = 0;\n    ie[1].id.cf.indexB = i2;\n    ie[1].id.cf.typeA = ContactFeatureType.e_face;\n    ie[1].id.cf.typeB = ContactFeatureType.e_vertex;\n\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      rf.v1 = v1;\n      rf.v2 = v2;\n      rf.normal.setVec2(normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      rf.v1 = v2;\n      rf.v2 = v1;\n      rf.normal.setMul(-1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n\n    ie[0].v = v1;\n    ie[0].id.cf.indexA = 0;\n    ie[0].id.cf.indexB = primaryAxis.index;\n    ie[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    ie[0].id.cf.typeB = ContactFeatureType.e_face;\n\n    ie[1].v = v2;\n    ie[1].id.cf.indexA = 0;\n    ie[1].id.cf.indexB = primaryAxis.index;\n    ie[1].id.cf.typeA = ContactFeatureType.e_vertex;\n    ie[1].id.cf.typeB = ContactFeatureType.e_face;\n\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    rf.v1 = polygonBA.vertices[rf.i1];\n    rf.v2 = polygonBA.vertices[rf.i2];\n    rf.normal.setVec2(polygonBA.normals[rf.i1]);\n  }\n\n  rf.sideNormal1.setNum(rf.normal.y, -rf.normal.x);\n  rf.sideNormal2.setMul(-1, rf.sideNormal1);\n  rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);\n\n  // Clip incident edge against extruded edge1 side edges.\n  const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n  const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n\n  let np;\n\n  // Clip to box side 1\n  np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n\n  if (np < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n\n  if (np < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.localNormal = Vec2.clone(rf.normal);\n    manifold.localPoint = Vec2.clone(rf.v1);\n  } else {\n    manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);\n    manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);\n  }\n\n  let pointCount = 0;\n  for (let i = 0; i < Settings.maxManifoldPoints; ++i) {\n    const separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));\n\n    if (separation <= radius) {\n      const cp = manifold.points[pointCount]; // ManifoldPoint\n\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        cp.localPoint = Transform.mulTVec2(xf, clipPoints2[i].v);\n        cp.id = clipPoints2[i].id;\n      } else {\n        cp.localPoint = clipPoints2[i].v;\n        cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\n        cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\n        cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\n        cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\n      }\n\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport { Math } from '../../common/Math';\nimport { Transform } from '../../common/Transform';\nimport { Vec2 } from '../../common/Vec2';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n\nfunction PolygonCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollidePolygonCircle(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nexport function CollidePolygonCircle(manifold: Manifold, polygonA: PolygonShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  const c = Transform.mulVec2(xfB, circleB.m_p);\n  const cLocal = Transform.mulTVec2(xfA, c);\n\n  // Find the min separating edge.\n  let normalIndex = 0;\n  let separation = -Infinity;\n  const radius = polygonA.m_radius + circleB.m_radius;\n  const vertexCount = polygonA.m_count;\n  const vertices = polygonA.m_vertices;\n  const normals = polygonA.m_normals;\n\n  for (let i = 0; i < vertexCount; ++i) {\n    const s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));\n\n    if (s > radius) {\n      // Early out.\n      return;\n    }\n\n    if (s > separation) {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  const vertIndex1 = normalIndex;\n  const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  const v1 = vertices[vertIndex1];\n  const v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < Math.EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setVec2(normals[normalIndex]);\n    manifold.localPoint.setCombine(0.5, v1, 0.5, v2);\n    manifold.points[0].localPoint = circleB.m_p;\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Compute barycentric coordinates\n  const u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));\n  const u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));\n  if (u1 <= 0.0) {\n    if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setCombine(1, cLocal, -1, v1);\n    manifold.localNormal.normalize();\n    manifold.localPoint = v1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  } else if (u2 <= 0.0) {\n    if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setCombine(1, cLocal, -1, v2);\n    manifold.localNormal.normalize();\n    manifold.localPoint.setVec2(v2);\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  } else {\n    const faceCenter = Vec2.mid(v1, v2);\n    const separation = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);\n    if (separation > radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setVec2(normals[vertIndex1]);\n    manifold.localPoint.setVec2(faceCenter);\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  }\n}\n","export * from './serializer/index';\n\nexport * from './common/Math';\nexport * from './common/Vec2';\nexport * from './common/Vec3';\nexport * from './common/Mat22';\nexport * from './common/Mat33';\nexport * from './common/Transform';\nexport * from './common/Rot';\n\nexport * from './collision/AABB';\n\nexport * from './collision/Shape';\nexport * from './dynamics/Fixture';\nexport * from './dynamics/Body';\nexport * from './dynamics/Contact';\nexport * from './dynamics/Joint';\nexport * from './dynamics/World';\n\nexport * from './collision/shape/CircleShape';\nexport * from './collision/shape/EdgeShape';\nexport * from './collision/shape/PolygonShape';\nexport * from './collision/shape/ChainShape';\nexport * from './collision/shape/BoxShape';\n\nexport * from './collision/shape/CollideCircle';\nexport * from './collision/shape/CollideEdgeCircle';\nexport * from './collision/shape/CollidePolygon';\nexport * from './collision/shape/CollideCirclePolygon';\nexport * from './collision/shape/CollideEdgePolygon';\n\nexport * from './dynamics/joint/DistanceJoint';\nexport * from './dynamics/joint/FrictionJoint';\nexport * from './dynamics/joint/GearJoint';\nexport * from './dynamics/joint/MotorJoint';\nexport * from './dynamics/joint/MouseJoint';\nexport * from './dynamics/joint/PrismaticJoint';\nexport * from './dynamics/joint/PulleyJoint';\nexport * from './dynamics/joint/RevoluteJoint';\nexport * from './dynamics/joint/RopeJoint';\nexport * from './dynamics/joint/WeldJoint';\nexport * from './dynamics/joint/WheelJoint';\n\nexport * from './Settings';\n\nexport * from './common/Sweep';\nexport * from './collision/Manifold';\nexport * from './collision/Distance';\nexport * from './collision/TimeOfImpact';\nexport * from './collision/DynamicTree';\n\nimport { CollidePolygons } from './collision/shape/CollidePolygon';\nimport { Settings } from './Settings';\nimport { Sweep } from './common/Sweep';\nimport { DynamicTree } from './collision/DynamicTree';\nimport { Manifold } from './collision/Manifold';\n\nimport { Solver, TimeStep } from './dynamics/Solver';\nimport { Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache, testOverlap } from './collision/Distance';\nimport { TimeOfImpact, TOIInput, TOIOutput } from './collision/TimeOfImpact';\n\nimport { stats } from './util/stats'; // todo: what to do with this?\n\nexport { ContactImpulse } from './dynamics/Solver';\n\n/** @deprecated Merged with main namespace */\nexport const internal = {};\n\n// @ts-ignore\ninternal.CollidePolygons = CollidePolygons;\n// @ts-ignore\ninternal.Settings = Settings;\n// @ts-ignore\ninternal.Sweep = Sweep;\n// @ts-ignore\ninternal.Manifold = Manifold;\n// @ts-ignore\ninternal.Distance = Distance;\n// @ts-ignore\ninternal.TimeOfImpact = TimeOfImpact;\n// @ts-ignore\ninternal.DynamicTree = DynamicTree;\n// @ts-ignore\ninternal.stats = stats;\n\n// @ts-ignore\nSolver.TimeStep = TimeStep;\n\n// @ts-ignore\nDistance.testOverlap = testOverlap;\n// @ts-ignore\nDistance.Input = DistanceInput;\n// @ts-ignore\nDistance.Output = DistanceOutput;\n// @ts-ignore\nDistance.Proxy = DistanceProxy;\n// @ts-ignore\nDistance.Cache = SimplexCache;\n\n// @ts-ignore\nTimeOfImpact.Input = TOIInput;\n// @ts-ignore\nTimeOfImpact.Output = TOIOutput;\n","import Stage from 'stage-js';\n\nexport * from '../src/index';\n\nimport {\n  AABB,\n  Body,\n  Fixture,\n  Joint,\n  MouseJoint,\n  Vec2,\n  World,\n  Edge,\n  Polygon,\n  Chain,\n  Circle,\n} from '../src';\n\ntype RenderOption = {\n  stroke?: string;\n  fill?: string;\n}\n\ntype JointX = Joint & {\n  render?: RenderOption;\n}\n\ntype FixtureX = Fixture & {\n  render?: RenderOption;\n}\n\ntype BodyX = Body & {\n  render?: RenderOption;\n}\n\ninterface Options {\n  speed: number;\n  hz: number;\n  scaleY: number;\n  ratio: number;\n  lineWidth: number;\n  strokeStyle: string | undefined;\n  fillStyle: string | undefined;\n}\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ntype KEY = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' |\n  '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' |\n  'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' |\n  'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' |\n  'Z' | 'right' | 'left' | 'up' | 'down' | 'fire';\n\nexport type ActiveKeys = { [key in KEY]?: boolean };\n\nfunction findBody(world: World, point: Point) {\n  let body: Body | null = null;\n  const aabb = new AABB(point as Vec2, point as Vec2);\n  world.queryAABB(aabb, (fixture) => {\n    if (body) {\n      return false;\n    }\n    if (!fixture.getBody().isDynamic() || !fixture.testPoint(point as Vec2)) {\n      return false;\n    }\n    body = fixture.getBody();\n    return true;\n  });\n  return body;\n}\n\nlet playButton: HTMLElement | null = null;\nlet status: HTMLElement | null = null;\nlet info: HTMLElement | null = null;\n\n// status.innerText = '';\n// info.innerText = '';\n\nexport class Testbed {\n  // camera position\n\n  /** World viewbox width. */\n  width: number = 80;\n\n  /** World viewbox height. */\n  height: number = 60;\n\n  /** World viewbox center vertical offset. */\n  x: number = 0;\n\n  /** World viewbox center horizontal offset. */\n  y: number = -10;\n\n  scaleY: number = -1;\n\n  /** World simulation step frequency */\n  hz: number = 60;\n\n  /** World simulation speed, default is 1 */\n  speed: number = 1;\n\n  ratio: number = 16;\n  background: string = '#222222';\n\n  mouseForce?: number;\n  activeKeys: ActiveKeys = {};\n\n  /** callback, to be implemented by user */\n  step = (dt: number, t: number): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keydown = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keyup = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  private canvas: any;\n  private stage: any;\n  private lastDrawHash = \"\";\n  private newDrawHash = \"\";\n  private buffer: ((context: CanvasRenderingContext2D, ratio: number)=> void)[] = [];\n\n  start = (world: World) => {\n    const stage = this.stage = Stage.mount();\n    const canvas = this.canvas = stage.dom as HTMLCanvasElement;\n\n    const testbed = this;\n    this.canvas = canvas;\n\n    stage.on(Stage.Mouse.START, () => {\n      window.focus();\n      // @ts-ignore\n      document.activeElement?.blur();\n      canvas.focus();\n    });\n\n    (stage as any).MAX_ELAPSE = 1000 / 30;\n\n    stage.on('resume', () => {\n      this.paused = false;\n      this._resume?.();\n    });\n    stage.on('pause', () => {\n      this.paused = true;\n      this._pause?.();\n    });\n\n    const drawingTexture = new Stage.Texture();\n    stage.append(Stage.sprite(drawingTexture));\n    stage.tick(() => {\n      this.buffer.length = 0;\n    }, true);\n\n    drawingTexture.draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.save();\n      ctx.transform(1, 0, 0, this.scaleY, -this.x, -this.y);\n      ctx.lineWidth = 2  / this.ratio;\n      ctx.lineCap = 'round';\n      for (let drawing = this.buffer.shift(); drawing; drawing = this.buffer.shift()) {\n        drawing(ctx, this.ratio);\n      }\n      ctx.restore();\n    };\n\n    const worldNode = new WorldNode(world, this);\n\n    let lastX = 0;\n    let lastY = 0;\n    stage.tick((dt: number, t: number) => {\n      // update camera position\n      if (lastX !== this.x || lastY !== this.y) {\n        worldNode.offset(-this.x, -this.y);\n        lastX = this.x;\n        lastY = this.y;\n      }\n    });\n\n    worldNode.tick((dt: number, t: number) => {\n      this.step(dt, t);\n\n      if (targetBody) {\n        this.drawSegment(targetBody.getPosition(), mouseMove, 'rgba(255,255,255,0.2)');\n      }\n\n      if (this.lastDrawHash !== this.newDrawHash) {\n        this.lastDrawHash = this.newDrawHash;\n        stage.touch();\n      }\n      this.newDrawHash = \"\";\n\n      return true;\n    });\n\n    // stage.empty();\n    stage.background(this.background);\n    stage.viewbox(this.width, this.height);\n    stage.pin('alignX', -0.5);\n    stage.pin('alignY', -0.5);\n    stage.prepend(worldNode);\n\n    const mouseGround = world.createBody();\n    let mouseJoint: MouseJoint | null = null;\n    let targetBody: Body | null = null;\n    const mouseMove = {x: 0, y: 0};\n\n    worldNode.attr('spy', true);\n\n    worldNode.on(Stage.Mouse.START, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (targetBody) {\n        return;\n      }\n\n      const body = findBody(world, point);\n      if (!body) {\n        return;\n      }\n\n      if (this.mouseForce) {\n        targetBody = body;\n\n      } else {\n        mouseJoint = new MouseJoint({maxForce: 1000}, mouseGround, body, Vec2.clone(point as Vec2));\n        world.createJoint(mouseJoint);\n      }\n    });\n\n    worldNode.on(Stage.Mouse.MOVE, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        mouseJoint.setTarget(point as Vec2);\n      }\n\n      mouseMove.x = point.x;\n      mouseMove.y = point.y;\n    });\n\n    worldNode.on(Stage.Mouse.END, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        world.destroyJoint(mouseJoint);\n        mouseJoint = null;\n      }\n      if (targetBody && this.mouseForce) {\n        const force = Vec2.sub(point as Vec2, targetBody.getPosition());\n        targetBody.applyForceToCenter(force.mul(this.mouseForce), true);\n        targetBody = null;\n      }\n    });\n\n    worldNode.on(Stage.Mouse.CANCEL, (point: Point) => {\n      point = { x: point.x, y: testbed.scaleY * point.y };\n      if (mouseJoint) {\n        world.destroyJoint(mouseJoint);\n        mouseJoint = null;\n      }\n      if (targetBody) {\n        targetBody = null;\n      }\n    });\n\n    window.addEventListener(\"keydown\", (e) => {\n      switch (e.keyCode) {\n        case 'P'.charCodeAt(0):\n          this.togglePause();\n          break;\n      }\n    }, false);\n\n    const activeKeys = testbed.activeKeys;\n    const downKeys: Record<number, boolean> = {};\n    function updateActiveKeys(keyCode: number, down: boolean) {\n      const char = String.fromCharCode(keyCode) as KEY;\n      if (/\\w/.test(char)) {\n        activeKeys[char] = down;\n      }\n      activeKeys.right = downKeys[39] || activeKeys['D'];\n      activeKeys.left = downKeys[37] || activeKeys['A'];\n      activeKeys.up = downKeys[38] || activeKeys['W'];\n      activeKeys.down = downKeys[40] || activeKeys['S'];\n      activeKeys.fire = downKeys[32] || downKeys[13] ;\n    }\n\n    window.addEventListener(\"keydown\", function(e) {\n      const keyCode = e.keyCode;\n      downKeys[keyCode] = true;\n      updateActiveKeys(keyCode, true);\n      testbed.keydown && testbed.keydown(keyCode, String.fromCharCode(keyCode));\n    });\n    window.addEventListener(\"keyup\", function(e) {\n      const keyCode = e.keyCode;\n      downKeys[keyCode] = false;\n      updateActiveKeys(keyCode, false);\n      testbed.keyup && testbed.keyup(keyCode, String.fromCharCode(keyCode));\n    });\n\n\n    playButton?.addEventListener('click', () => {\n      testbed.isPaused() ? testbed.resume() : testbed.pause();\n    });\n\n    this.resume();\n  }\n\n  /** @private @internal */\n  focus = () => {\n    // @ts-ignore\n    document.activeElement && document.activeElement.blur();\n    this.canvas.focus();\n  };\n\n  private paused: boolean = false;\n\n  /** @internal */\n  _pause = () => {\n    playButton?.classList.add('pause');\n    playButton?.classList.remove('play');\n  };\n  /** @internal */\n  _resume = () => {\n    playButton?.classList.add('play');\n    playButton?.classList.remove('pause');\n  };\n\n  private lastStatus = '';\n  private lastInfo = '';\n  \n  /** @internal */\n  _status = (statusText: string, statusMap: Record<string, any>) => {\n    var newline = '\\n';\n    var string = statusText || '';\n    for (var key in statusMap) {\n      var value = statusMap[key];\n      if (typeof value === 'function') continue;\n      string += (string && newline) + key + ': ' + value;\n    }\n  \n    if (this.lastStatus !== string) {\n      status.innerText = this.lastStatus = string;\n    }\n  };\n  /** @internal */  \n  _info = (text: string) => {\n    if (this.lastInfo !== text) {\n      info.innerText = this.lastInfo = text;\n    }\n  };\n\n  /** @internal */\n  isPaused = () => {\n    return this.paused;\n  };\n  /** @internal */\n  togglePause = () => {\n    this.paused ? this.resume() : this.pause();\n  };\n  /** @internal */\n  pause = () => {\n    this.stage.pause();\n  };\n  /** @internal */\n  resume = () => {\n    this.stage.resume();\n    this.focus();\n  };\n\n  statusText = '';\n  statusMap: Record<string, any> = {};\n\n  private statusSet(name: string, value: string | number | boolean) {\n    if (typeof value !== 'function' && typeof value !== 'object') {\n      this.statusMap[name] = value;\n    }\n  }\n  private statusMerge(obj: Record<string, any>) {\n    // tslint:disable-next-line:no-for-in\n    for (const key in obj) {\n      this.statusSet(key, obj[key]);\n    }\n  }\n\n  status(name: string, value: any): void;\n  status(value: object | string): void;\n  status(a: any, b?: any) {\n    if (typeof b !== 'undefined') {\n      this.statusSet(a, b);\n    } else if (a && typeof a === 'object') {\n      this.statusMerge(a);\n    } else if (typeof a === 'string') {\n      this.statusText = a;\n    }\n\n    this._status?.(this.statusText, this.statusMap);\n  };\n\n  info = (text: string): void => {\n    this._info?.(text);\n  };\n\n  drawPoint = (p: {x: number, y: number}, r: any, color: string): void => {\n    this.buffer.push(function(ctx, ratio) {\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, 5  / ratio, 0, 2 * Math.PI);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"point\" + p.x + ',' + p.y + ',' + r + ',' + color;\n  };\n\n  drawCircle = (p: {x: number, y: number}, r: number, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.arc(p.x, p.y, r, 0, 2 * Math.PI);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"circle\" + p.x + ',' + p.y + ',' + r + ',' + color;\n  };\n\n  drawEdge = (a: {x: number, y: number}, b: {x: number, y: number}, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(a.x, a.y);\n      ctx.lineTo(b.x, b.y);\n      ctx.strokeStyle = color;\n      ctx.stroke();\n    });\n    this.newDrawHash += \"segment\" + a.x + ',' + a.y + ',' + b.x + ',' + b.y + ',' + color;\n  };\n\n  drawSegment = this.drawEdge;\n\n  drawPolygon = (points: Array<{x: number, y: number}>, color: string): void => {\n    if (!points || !points.length) {\n      return;\n    }\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.strokeStyle = color;\n      ctx.closePath();\n      ctx.stroke();\n    });\n    this.newDrawHash += \"segment\";\n    for (let i = 1; i < points.length; i++) {\n      this.newDrawHash += points[i].x + ',' + points[i].y + ',';\n    }\n    this.newDrawHash += color;\n  };\n\n  drawAABB = (aabb: AABB, color: string): void => {\n    this.buffer.push(function(ctx) {\n      ctx.beginPath();\n      ctx.moveTo(aabb.lowerBound.x, aabb.lowerBound.y);\n      ctx.lineTo(aabb.upperBound.x, aabb.lowerBound.y);\n      ctx.lineTo(aabb.upperBound.x, aabb.upperBound.y);\n      ctx.lineTo(aabb.lowerBound.x, aabb.upperBound.y);\n      ctx.strokeStyle = color;\n      ctx.closePath();\n      ctx.stroke();\n    });\n    this.newDrawHash += \"aabb\";\n    this.newDrawHash += aabb.lowerBound.x + ',' + aabb.lowerBound.y + ',';\n    this.newDrawHash += aabb.upperBound.x + ',' + aabb.upperBound.y + ',';\n    this.newDrawHash += color;\n  };\n\n  color = function(r: number, g: number, b: number): string {\n    r = r * 256 | 0;\n    g = g * 256 | 0;\n    b = b * 256 | 0;\n    return 'rgb(' + r + ', ' + g + ', ' + b + ')';\n  };\n\n  findOne = (query: string): (Body | Joint | Fixture | null) => {\n    // todo: implement\n    return null;\n  };\n\n  findAll = (query: string): (Body | Joint | Fixture)[] => {\n    // todo: implement\n    return [];\n  };\n}\n\nclass WorldNode extends Stage.Node {\n  private nodes = new WeakMap<BodyX | FixtureX | JointX, Stage.Node>();\n\n  private options: Options = {\n    speed: 1,\n    hz: 60,\n    scaleY: -1,\n    ratio: 16,\n    lineWidth: 1,\n    strokeStyle: undefined,\n    fillStyle: undefined\n  };\n\n  private world: World;\n\n  constructor(world: World, opts: Partial<Options> = {}) {\n    super();\n    this.label('Planck');\n\n    this.options.speed = opts.speed ?? this.options.speed;\n    this.options.hz = opts.hz ?? this.options.speed;\n    if (Math.abs(this.options.hz) < 1) {\n      this.options.hz = 1 / this.options.hz;\n    }\n    this.options.scaleY = opts.scaleY ?? this.options.scaleY;\n    this.options.ratio = opts.ratio ?? this.options.ratio;\n    this.options.lineWidth = 2 / this.options.ratio;\n\n    this.world = world;\n\n    const timeStep = 1 / this.options.hz;\n    let elapsedTime = 0;\n    this.tick((dt) => {\n      dt = dt * 0.001 * this.options.speed;\n      elapsedTime += dt;\n      while (elapsedTime > timeStep) {\n        world.step(timeStep);\n        elapsedTime -= timeStep;\n      }\n      this.renderWorld();\n      return true;\n    }, true);\n\n    world.on('remove-fixture', (obj: FixtureX) => {\n      this.nodes.get(obj)?.remove();\n    });\n\n    world.on('remove-joint', (obj: JointX) => {\n      this.nodes.get(obj)?.remove();\n    });\n  }\n\n  renderWorld = () => {\n    const world = this.world;\n    const options = this.options;\n    const viewer = this;\n\n    for (let b = world.getBodyList() as BodyX; b; b = b.getNext() as BodyX) {\n      for (let f = b.getFixtureList() as FixtureX; f; f = f.getNext() as FixtureX) {\n\n        let node = this.nodes.get(f);\n        if (!node) {\n          if (f.render && f.render.stroke) {\n            options.strokeStyle = f.render.stroke;\n          } else if (b.render && b.render.stroke) {\n            options.strokeStyle = b.render.stroke;\n          } else if (b.isDynamic()) {\n            options.strokeStyle = 'rgba(255,255,255,0.9)';\n          } else if (b.isKinematic()) {\n            options.strokeStyle = 'rgba(255,255,255,0.7)';\n          } else if (b.isStatic()) {\n            options.strokeStyle = 'rgba(255,255,255,0.5)';\n          }\n\n          if (f.render && f.render.fill) {\n            options.fillStyle = f.render.fill;\n          } else if (b.render && b.render.fill) {\n            options.fillStyle = b.render.fill;\n          } else {\n            options.fillStyle = '';\n          }\n\n          const type = f.getType();\n          const shape = f.getShape();\n          if (type == 'circle') {\n            node = viewer.drawCircle(shape as Circle, options);\n          }\n          if (type == 'edge') {\n            node = viewer.drawEdge(shape as Edge, options);\n          }\n          if (type == 'polygon') {\n            node = viewer.drawPolygon(shape as Polygon, options);\n          }\n          if (type == 'chain') {\n            node = viewer.drawChain(shape as Chain, options);\n          }\n\n          if (node) {\n            node.appendTo(viewer);\n            this.nodes.set(f, node);\n          }\n        }\n\n        if (node) {\n          const p = b.getPosition();\n          const r = b.getAngle();\n          // @ts-ignore\n          const isChanged = node.__lastX !== p.x || node.__lastY !== p.y || node.__lastR !== r;\n          if (isChanged) {\n            // @ts-ignore\n            node.__lastX = p.x;\n            // @ts-ignore\n            node.__lastY = p.y;\n            // @ts-ignore\n            node.__lastR = r;\n            node.offset(p.x, options.scaleY * p.y);\n            node.rotate(options.scaleY * r);\n          }\n        }\n\n      }\n    }\n\n    for (let j = world.getJointList() as JointX; j; j = j.getNext() as JointX) {\n      const type = j.getType();\n      const a = j.getAnchorA();\n      const b = j.getAnchorB();\n\n      let node = this.nodes.get(j);\n      if (!node) {\n        options.strokeStyle = 'rgba(255,255,255,0.2)';\n\n        node = viewer.drawJoint(j, options);\n        node.pin('handle', 0.5);\n        node.appendTo(viewer);\n        this.nodes.set(j, node);\n      }\n\n      if (node) {\n        const cx = (a.x + b.x) * 0.5;\n        const cy = options.scaleY * (a.y + b.y) * 0.5;\n        const dx = a.x - b.x;\n        const dy = options.scaleY * (a.y - b.y);\n        const d = Math.sqrt(dx * dx + dy * dy);\n        node.width(d);\n        node.rotate(Math.atan2(dy, dx));\n        node.offset(cx, cy);\n      }\n    }\n  }\n\n  drawJoint = (joint: Joint, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const length = 10;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(length + 2 * lw, 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      ctx.moveTo(lw, lw);\n      ctx.lineTo(lw + length, lw);\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.strokeStyle ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture).stretch();\n    return image;\n  }\n\n  drawCircle = (shape: Circle, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const r = shape.m_radius;\n    const cx = r + lw;\n    const cy = r + lw;\n    const w = r * 2 + lw * 2;\n    const h = r * 2 + lw * 2;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(w, h, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.arc(cx, cy, r, 0, 2 * Math.PI);\n      if (options.fillStyle) {\n        ctx.fillStyle = options.fillStyle;\n        ctx.fill();\n      }\n      ctx.lineTo(cx, cy);\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.strokeStyle ?? '';\n      ctx.stroke();\n    });\n    const image = Stage.sprite(texture)\n      .offset(shape.m_p.x - cx, options.scaleY * shape.m_p.y - cy);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawEdge = (edge: Edge, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const v1 = edge.m_vertex1;\n    const v2 = edge.m_vertex2;\n\n    const dx = v2.x - v1.x;\n    const dy = v2.y - v1.y;\n\n    const length = Math.sqrt(dx * dx + dy * dy);\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(length + 2 * lw, 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      ctx.moveTo(lw, lw);\n      ctx.lineTo(lw + length, lw);\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.strokeStyle ?? '';\n      ctx.stroke();\n    });\n\n    const minX = Math.min(v1.x, v2.x);\n    const minY = Math.min(options.scaleY * v1.y, options.scaleY * v2.y);\n\n    const image = Stage.sprite(texture);\n    image.rotate(options.scaleY * Math.atan2(dy, dx));\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawPolygon = (shape: Polygon, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const vertices = shape.m_vertices;\n\n    if (!vertices.length) {\n      return;\n    }\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < vertices.length; ++i) {\n      const v = vertices[i];\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, options.scaleY * v.y);\n      maxY = Math.max(maxY, options.scaleY * v.y);\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    const texture = Stage.canvas(function (ctx: CanvasRenderingContext2D) {\n      // @ts-ignore\n      this.size(width + 2 * lw, height + 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      for (let i = 0; i < vertices.length; ++i) {\n        const v = vertices[i];\n        const x = v.x - minX + lw;\n        const y = options.scaleY * v.y - minY + lw;\n        if (i == 0)\n          ctx.moveTo(x, y);\n\n        else\n          ctx.lineTo(x, y);\n      }\n\n      if (vertices.length > 2) {\n        ctx.closePath();\n      }\n\n      if (options.fillStyle) {\n        ctx.fillStyle = options.fillStyle;\n        ctx.fill();\n        ctx.closePath();\n      }\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.strokeStyle ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture);\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n\n  drawChain = (shape: Chain, options: Options) => {\n    const lw = options.lineWidth;\n    const ratio = options.ratio;\n\n    const vertices = shape.m_vertices;\n\n    if (!vertices.length) {\n      return;\n    }\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < vertices.length; ++i) {\n      const v = vertices[i];\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, options.scaleY * v.y);\n      maxY = Math.max(maxY, options.scaleY * v.y);\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n\n    const texture = Stage.canvas(function (ctx) {\n      // @ts-ignore\n      this.size(width + 2 * lw, height + 2 * lw, ratio);\n\n      ctx.scale(ratio, ratio);\n      ctx.beginPath();\n      for (let i = 0; i < vertices.length; ++i) {\n        const v = vertices[i];\n        const x = v.x - minX + lw;\n        const y = options.scaleY * v.y - minY + lw;\n        if (i == 0)\n          ctx.moveTo(x, y);\n\n        else\n          ctx.lineTo(x, y);\n      }\n\n      // TODO: if loop\n      if (vertices.length > 2) {\n        // ctx.closePath();\n      }\n\n      if (options.fillStyle) {\n        ctx.fillStyle = options.fillStyle;\n        ctx.fill();\n        ctx.closePath();\n      }\n\n      ctx.lineCap = 'round';\n      ctx.lineWidth = options.lineWidth;\n      ctx.strokeStyle = options.strokeStyle ?? '';\n      ctx.stroke();\n    });\n\n    const image = Stage.sprite(texture);\n    image.offset(minX - lw, minY - lw);\n    const node = Stage.create().append(image);\n    return node;\n  }\n}\n\nconst tb = new Testbed();\n\n/** @deprecated */\ntype testbedLegacyWithOptions = (options: any, factory: (testbed: Testbed) => World) => void;\n/** @deprecated */\ntype testbedLegacy = (factory: (testbed: Testbed) => World) => void;\n\nexport const testbed: ((options: any) => Testbed) | testbedLegacyWithOptions | testbedLegacy | undefined = (a, b) => {\n  playButton = null;document.getElementById('testbed-play');\n  status = document.getElementById('testbed-status');\n  info = document.getElementById('testbed-info');\n  let callback;\n  let options;\n  if (typeof a === 'function') {\n    callback = a;\n    options = b;\n  } else if (typeof b === 'function') {\n    callback = b;\n    options = a;\n  } else {\n    options = a ?? b;\n  }\n  if (callback) {\n    // this is for backwards compatibility\n    const world = callback(tb);\n    tb.start(world);\n  } else {\n    return tb;\n  }\n};\n\n"],"names":["options","input","defaults","output","__assign","key","hasOwnProperty","Object","getOwnPropertySymbols","symbols","i","length","symbol","propertyIsEnumerable","common","native","create","Math","extended","assign","EPSILON","isFinite","x","isNaN","assert","invSqrt","sqrt","nextPowerOfTwo","isPowerOfTwo","mod","num","min","max","clamp","random","Vec2","y","this","prototype","_serialize","_deserialize","data","obj","zero","neo","clone","v","toString","JSON","stringify","isValid","o","setZero","set","setNum","setVec2","value","wSet","a","b","w","setCombine","setMul","add","wAdd","addCombine","addMul","wSub","subCombine","subMul","sub","mul","m","lengthOf","lengthSquared","normalize","invLength","distance","dx","dy","distanceSquared","areEqual","skew","dot","cross","crossVec2Vec2","crossVec2Num","crossNumVec2","addCross","addCrossVec2Num","addCrossNumVec2","combine","mulNumVec2","mulVec2Num","neg","abs","mid","upper","lower","lengthSqr","scaleFn","translateFn","AABB","lowerBound","upperBound","getCenter","getExtents","getPerimeter","lowerA","upperA","lowerB","upperB","lowerX","lowerY","upperX","upperY","combinePoints","aabb","contains","result","extend","testOverlap","d1x","d2x","d1y","d2y","diff","wD","hD","rayCast","tmin","Infinity","tmax","p","p1","d","p2","absD","normal","f","inv_d","t1","t2","s","temp","maxFraction","fraction","Settings","defineProperty","linearSlop","maxTranslation","maxRotation","get","pow","linearSleepTolerance","angularSleepTolerance","maxManifoldPoints","maxPolygonVertices","aabbExtension","aabbMultiplier","angularSlop","PI","maxSubSteps","maxTOIContacts","maxTOIIterations","maxDistnceIterations","velocityThreshold","maxLinearCorrection","maxAngularCorrection","baumgarte","toiBaugarte","timeToSleep","Pool","opts","_list","_max","_createCount","_outCount","_inCount","_discardCount","_createFn","_outFn","allocate","_inFn","release","_discardFn","discard","n","size","item","shift","push","TreeNode","id","userData","parent","child1","child2","height","isLeaf","DynamicTree","inputPool","stack","stackPool","iteratorPool","Iterator","iterator","close","m_root","m_nodes","m_lastProxyId","m_pool","getUserData","getFatAABB","allocateNode","node","freeNode","createProxy","insertLeaf","destroyProxy","removeLeaf","moveProxy","leaf","leafAABB","index","area","combinedAABB","combinedArea","cost","inheritanceCost","cost1","oldArea","cost2","sibling","oldParent","newParent","balance","grandParent","iA","A","B","C","F","G","D","E","getHeight","getAreaRatio","rootArea","totalArea","it","preorder","next","computeHeight","height1","height2","validateStructure","validateMetrics","validate","getMaxBalance","maxBalance","rebuildBottomUp","nodes","count","minCost","iMin","jMin","aabbi","j","aabbj","parent_1","shiftOrigin","newOrigin","query","queryCallback","pop","rayCastCallback","r","abs_v","segmentAABB","t","subInput","c","h","parents","states","root","BroadPhase","_this","m_tree","m_proxyCount","m_moveBuffer","proxyId","m_queryProxyId","proxyIdA","proxyIdB","userDataA","userDataB","m_callback","aabbA","aabbB","getProxyCount","getTreeHeight","getTreeBalance","getTreeQuality","bufferMove","unbufferMove","displacement","touchProxy","updatePairs","addPairCallback","fatAABB","Rot","angle","setAngle","setRot","setIdentity","rot","identity","sin","cos","getAngle","atan2","getXAxis","getYAxis","qr","mulRot","mulVec2","mulSub","mulT","mulTRot","mulTVec2","Transform","position","rotation","q","xf","setTransform","Array","isArray","arr","mulXf","mulAll","mulFn","mulTXf","px","py","Sweep","localCenter","alpha0","c0","a0","setLocalCenter","getTransform","beta","advance","alpha","forward","that","Velocity","Position","Shape","_reset","m_type","m_radius","getRadius","getType","FixtureDefDefault","friction","restitution","density","isSensor","filterGroupIndex","filterCategoryBits","filterMaskBits","FixtureProxy","fixture","childIndex","Fixture","body","shape","def","m_body","m_friction","m_restitution","m_density","m_isSensor","m_filterGroupIndex","m_filterCategoryBits","m_filterMaskBits","m_shape","m_next","m_proxies","childCount","getChildCount","m_userData","getBody","broadPhase","m_world","m_broadPhase","destroyProxies","createProxies","m_xf","resetMassData","restore","getShape","setSensor","sensor","setAwake","setUserData","getNext","getDensity","setDensity","getFriction","setFriction","getRestitution","setRestitution","testPoint","getMassData","massData","computeMass","getAABB","proxy","computeAABB","synchronize","xf1","xf2","aabb1","aabb2","setFilterData","filter","groupIndex","categoryBits","maskBits","refilter","getFilterGroupIndex","setFilterGroupIndex","getFilterCategoryBits","setFilterCategoryBits","getFilterMaskBits","setFilterMaskBits","edge","getContactList","contact","fixtureA","getFixtureA","fixtureB","getFixtureB","flagForFiltering","world","getWorld","shouldCollide","collideA","collideB","STATIC","KINEMATIC","DYNAMIC","BodyDefDefault","type","linearVelocity","angularVelocity","linearDamping","angularDamping","fixedRotation","bullet","gravityScale","allowSleep","awake","active","MassData","mass","center","I","Body","m_awakeFlag","m_autoSleepFlag","m_bulletFlag","m_fixedRotationFlag","m_activeFlag","m_islandFlag","m_toiFlag","m_mass","m_invMass","m_I","m_invI","m_sweep","c_velocity","c_position","m_force","m_torque","m_linearVelocity","m_angularVelocity","m_linearDamping","m_angularDamping","m_gravityScale","m_sleepTime","m_jointList","m_contactList","m_fixtureList","m_prev","m_destroyed","fixtures","_addFixture","isWorldLocked","isLocked","getFixtureList","getJointList","isStatic","isDynamic","isKinematic","setStatic","setType","setDynamic","setKinematic","synchronizeFixtures","ce","ce0","destroyContact","proxyCount","isBullet","setBullet","flag","isSleepingAllowed","setSleepingAllowed","isAwake","isActive","setActive","isFixedRotation","setFixedRotation","synchronizeTransform","getPosition","setPosition","getWorldCenter","getLocalCenter","getLinearVelocity","getLinearVelocityFromWorldPoint","worldPoint","getLinearVelocityFromLocalPoint","localPoint","getWorldPoint","setLinearVelocity","getAngularVelocity","setAngularVelocity","getLinearDamping","setLinearDamping","getAngularDamping","setAngularDamping","getGravityScale","setGravityScale","scale","getMass","getInertia","oldCenter","setMassData","applyForce","force","point","wake","applyForceToCenter","applyTorque","torque","applyLinearImpulse","impulse","applyAngularImpulse","jn","other","joint","m_collideConnected","m_newFixture","createFixture","fixdef","destroyFixture","publish","getWorldVector","localVector","getLocalPoint","getLocalVector","worldVector","JointEdge","prev","Joint","bodyA","bodyB","m_edgeA","m_edgeB","m_bodyA","m_bodyB","collideConnected","getBodyA","getBodyB","getCollideConnected","stats","gjkCalls","gjkIters","gjkMaxIters","toiTime","toiMaxTime","toiCalls","toiIters","toiMaxIters","toiRootIters","toiMaxRootIters","newline","string","name_1","Timer","Date","now","time","DistanceInput","proxyA","DistanceProxy","proxyB","transformA","transformB","useRadii","DistanceOutput","pointA","pointB","SimplexCache","metric","indexA","indexB","Distance","cache","xfA","xfB","simplex","Simplex","readCache","vertices","m_v","k_maxIters","saveA","saveB","saveCount","iter","m_count","solve","getClosestPoint","getSearchDirection","vertex","getSupport","wA","getVertex","wB","duplicate","getWitnessPoints","iterations","writeCache","rA","rB","m_buffer","m_vertices","getVertexCount","bestIndex","bestValue","getSupportVertex","computeDistanceProxy","SimplexVertex","m_v1","m_v2","m_v3","wALocal","wBLocal","metric1","metric2","getMetric","e12","pA","pB","solve2","solve3","w1","w2","d12_2","d12_1","inv_d12","w3","w1e12","e13","w1e13","d13_1","d13_2","e23","w2e23","d23_1","d23_2","n123","d123_1","d123_2","d123_3","inv_d13","inv_d23","inv_d123","shapeA","shapeB","TOIOutputState","TOIInput","sweepA","sweepB","exports","SeparationFunctionType","TOIOutput","TimeOfImpact","timer","state","e_unknown","tMax","totalRadius","target","tolerance","k_maxIterations","distanceInput","distanceOutput","e_overlapped","e_touching","fcn","SeparationFunction","initialize","done","pushBackIter","s2","findMinSeparation","e_separated","s1","evaluate","e_failed","rootIterCount","a1","a2","ManifoldType","ContactFeatureType","PointState","m_proxyA","m_proxyB","m_localPoint","m_axis","m_sweepA","m_sweepB","e_points","localPointA","localPointB","e_faceB","localPointB1","localPointB2","e_faceA","localPointA1","localPointA2","compute","find","axisA","axisB","TimeStep","dt","inv_dt","velocityIterations","positionIterations","warmStarting","blockSolve","inv_dt0","dtRatio","reset","s_subStep","ContactImpulse","normals","tangents","v_points","normalImpulse","tangentImpulse","Solver","m_stack","m_bodies","m_contacts","m_joints","clear","addBody","addContact","addJoint","solveWorld","step","m_bodyList","seed","isEnabled","isTouching","sensorA","m_fixtureA","sensorB","m_fixtureB","je","solveIsland","gravity","m_gravity","m_allowSleep","initConstraint","initVelocityConstraint","warmStartConstraint","initVelocityConstraints","solveVelocityConstraints","solveVelocityConstraint","storeConstraintImpulses","translation","maxTranslationSquared","ratio","maxRotationSquared","positionSolved","minSeparation","separation","solvePositionConstraint","contactsOkay","jointsOkay","jointOkay","solvePositionConstraints","postSolveIsland","minSleepTime","linTolSqr","linearSleepToleranceSqr","angTolSqr","angularSleepToleranceSqr","printBodies","tag","solveWorldTOI","m_stepComplete","m_toiCount","m_toi","minContact","minAlpha","fA_1","fB_1","bA_1","bB_1","activeA","activeB","getChildIndexA","getChildIndexB","fA","fB","bA","bB","backup1","backup2","update","bodies","backup","solveIslandTOI","findNewContacts","m_subStepping","setEnabled","subStep","toiA","toiB","solvePositionConstraintTOI","postSolve","m_impulse","Mat22","ex","ey","getInverse","det","imx","mx","mulMat22","mulTMat22","mx1","mx2","ClipVertex","ContactID","Manifold","localNormal","points","ManifoldPoint","pointCount","getWorldManifold","wm","radiusA","radiusB","WorldManifold","separations","e_circles","dist","cA","cB","planePoint","clipPoint","clipSegmentToLine","getPointStates","cf","ContactFeature","typeA","typeB","state1","state2","manifold1","manifold2","removeState","persistState","addState","vOut","vIn","offset","vertexIndexA","numOut","distance0","distance1","interp","e_vertex","e_face","ContactEdge","mixFriction","friction1","friction2","mixRestitution","restitution1","restitution2","s_registers","VelocityConstraintPoint","normalMass","tangentMass","velocityBias","Contact","evaluateFcn","m_manifold","m_tangentSpeed","m_enabledFlag","m_touchingFlag","m_filterFlag","m_bulletHitFlag","v_normal","v_normalMass","v_K","p_localPoints","p_localNormal","p_localPoint","p_localCenterA","p_localCenterB","m_nodeA","m_nodeB","m_indexA","m_indexB","m_evaluateFcn","manifold","getManifold","v_invMassA","v_invMassB","v_invIA","v_invIB","v_friction","v_restitution","v_tangentSpeed","v_pointCount","p_invMassA","p_invMassB","p_invIA","p_invIB","p_radiusA","p_radiusB","p_type","p_pointCount","cp","vcp","worldManifold","resetFriction","resetRestitution","setTangentSpeed","speed","getTangentSpeed","listener","oldManifold","touching","wasTouching","nmp","omp","beginContact","endContact","preSolve","_solvePositionConstraint","toi","positionA","positionB","localCenterA","localCenterB","mA","mB","iB","aA","aB","rnA","rnB","K","P","velocityA","velocityB","vA","vB","kNormal","tangent","rtA","rtB","kTangent","vRel","vcp1","vcp2","rn1A","rn1B","rn2A","rn2B","k11","k22","k12","dv","vt","lambda","maxFriction","newImpulse","vn","dv1","dv2","vn1","vn2","P1","P2","addType","type1","type2","callback","destroy","WorldDefDefault","continuousPhysics","subStepping","World","s_step","m_solver","m_contactCount","m_bodyCount","m_jointCount","m_clearForces","m_locked","m_warmStarting","m_continuousPhysics","m_blockSolve","m_velocityIterations","m_positionIterations","m_t","joints","getBodyList","context","_addBody","createJoint","getBodyCount","getJointCount","getContactCount","setGravity","getGravity","setAllowSleeping","getAllowSleeping","setWarmStarting","getWarmStarting","setContinuousPhysics","getContinuousPhysics","setSubStepping","getSubStepping","setAutoClearForces","getAutoClearForces","clearForces","queryAABB","point1","point2","createBody","arg1","arg2","createDynamicBody","createKinematicBody","destroyBody","je0","destroyJoint","f0","timeStep","updateContacts","createContact","next_c","on","name","_listeners","off","listeners","indexOf","splice","arg3","l","call","Vec3","z","EdgeShape","_super","v1","v2","TYPE","polygonRadius","m_vertex1","m_vertex2","m_vertex0","m_vertex3","m_hasVertex0","m_hasVertex3","__extends","vertex1","vertex2","vertex0","vertex3","hasVertex0","hasVertex3","setPrevVertex","setNextVertex","setNext","getNextVertex","setPrev","getPrevVertex","_set","_clone","e","numerator","denominator","rr","ChainShape","loop","m_prevVertex","m_nextVertex","m_hasPrevVertex","m_hasNextVertex","m_isLoop","_createLoop","_createChain","isLoop","hasPrevVertex","hasNextVertex","prevVertex","nextVertex","getChildEdge","PolygonShape","m_centroid","m_normals","_setAsBox","ps","unique","linearSlopSquared","i0","x0","hull","ih","ie","i1","i2","vs","pRef","inv3","p3","e1","e2","triangleArea","ComputeCentroid","hx","hy","pLocal","minX","minY","maxX","maxY","k_inv3","ex1","ey1","ex2","ey2","BoxShape","CircleShape","m_p","radius","sigma","DEFAULTS","frequencyHz","dampingRatio","DistanceJoint","anchorA","anchorB","m_localAnchorA","localAnchorA","m_localAnchorB","localAnchorB","m_length","m_frequencyHz","m_dampingRatio","m_gamma","m_bias","gamma","bias","_setAnchors","getLocalAnchorA","getLocalAnchorB","setLength","getLength","setFrequency","hz","getFrequency","setDampingRatio","getDampingRatio","getAnchorA","getAnchorB","getReactionForce","m_u","getReactionTorque","m_localCenterA","m_localCenterB","m_invMassA","m_invMassB","m_invIA","m_invIB","qA","qB","m_rA","m_rB","crAu","crBu","invMass","omega","k","vpA","vpB","Cdot","u","maxForce","maxTorque","FrictionJoint","anchor","m_linearImpulse","m_angularImpulse","m_maxForce","m_maxTorque","setMaxForce","getMaxForce","setMaxTorque","getMaxTorque","m_linearMass","m_angularMass","oldImpulse","maxImpulse","Mat33","ez","solve33","solve22","a11","a12","a21","a22","getInverse22","M","getSymInverse33","a13","a23","a33","mulVec3","lowerAngle","upperAngle","maxMotorTorque","motorSpeed","enableLimit","enableMotor","RevoluteJoint","m_limitState","m_referenceAngle","referenceAngle","m_motorImpulse","m_lowerAngle","m_upperAngle","m_maxMotorTorque","m_motorSpeed","m_enableLimit","m_enableMotor","getReferenceAngle","getJointAngle","getJointSpeed","isMotorEnabled","getMotorTorque","setMotorSpeed","getMotorSpeed","setMaxMotorTorque","getMaxMotorTorque","isLimitEnabled","getLowerLimit","getUpperLimit","setLimits","m_motorMass","jointAngle","Cdot1","Cdot2","rhs","reduced","positionError","angularError","limitImpulse","lowerTranslation","upperTranslation","maxMotorForce","PrismaticJoint","axis","m_localXAxisA","localAxisA","m_localYAxisA","m_lowerTranslation","m_upperTranslation","m_maxMotorForce","m_perp","m_K","getLocalAxisA","getJointTranslation","setMaxMotorForce","getMaxMotorForce","getMotorForce","m_a1","m_a2","m_s1","m_s2","k13","k23","k33","jointTranslation","LA","LB","f1","df","f2r","perp","C1","linearError","C2","impulse1","GearJoint","joint1","joint2","coordinateA","coordinateB","m_joint1","m_joint2","m_ratio","m_type1","m_type2","m_bodyC","xfC","aC","revolute","m_localAnchorC","m_referenceAngleA","m_localAxisC","prismatic","pC","m_bodyD","xfD","aD","m_localAnchorD","m_referenceAngleB","m_localAxisD","pD","m_constant","getJoint1","getJoint2","setRatio","getRatio","m_JvAC","m_JwA","m_lcA","m_lcB","m_lcC","m_lcD","m_mA","m_mB","m_mC","m_mD","m_iA","m_iB","m_iC","m_iD","vC","wC","vD","qC","qD","m_JwC","rC","m_JvBD","m_JwB","m_JwD","rD","JvAC","JvBD","JwA","JwB","JwC","JwD","cC","cD","correctionFactor","MotorJoint","m_linearOffset","linearOffset","m_angularOffset","angularOffset","m_correctionFactor","setCorrectionFactor","factor","getCorrectionFactor","setLinearOffset","getLinearOffset","setAngularOffset","getAngularOffset","m_linearError","m_angularError","inv_h","MouseJoint","m_targetA","m_beta","m_C","_localAnchorB","setTarget","getTarget","velocity","PulleyJoint","groundA","groundB","m_groundAnchorA","groundAnchorA","m_groundAnchorB","groundAnchorB","m_lengthA","lengthA","m_lengthB","lengthB","getGroundAnchorA","getGroundAnchorB","getLengthA","getLengthB","getCurrentLengthA","getCurrentLengthB","m_uB","m_uA","ruA","ruB","PA","PB","uA","uB","maxLength","RopeJoint","m_maxLength","m_state","setMaxLength","getMaxLength","getLimitState","crA","crB","WeldJoint","invM","impulse2","WheelJoint","m_ax","m_ay","localAxis","m_springMass","m_springImpulse","setSpringFrequencyHz","getSpringFrequencyHz","setSpringDampingRatio","getSpringDampingRatio","m_sAy","m_sBy","m_sAx","m_sBx","damp","ay","sAy","sBy","SID","Serializer","rootClass","preSerialize","postSerialize","preDeserialize","postDeserialize","refTypes","restoreTypes","CLASS_BY_TYPE_PROP","_a","toJson","json","queue","refMap","storeRef","typeName","__sid","ref","refIndex","refType","top","serialize","newValue","str","fromJson","deserialize","cls","ctx","deserializer","findDeserilizer","restoreRef","serializer","CollideCircles","circleA","circleB","distSqr","CollideEdgeCircle","edgeA","Q","P_1","d_1","A1","B1","P_2","d_2","B2","A2","den","findMaxSeparation","poly1","poly2","count1","count2","n1s","v1s","v2s","maxSeparation","si","sij","chain","CollidePolygons","EPAxisType","VertexType","polyA","polyB","separationA","edgeB","separationB","edge1","flip","incidentEdge","normals1","vertices2","normals2","normal1","minDot","findIncidentEdge","vertices1","iv1","iv2","v11","v12","localTangent","frontOffset","sideOffset1","sideOffset2","clipPoints1","clipPoints2","CollidePolygonCircle","polygonA","cLocal","normalIndex","vertexCount","vertIndex1","vertIndex2","u1","u2","faceCenter","CollideEdgePolygon","EPAxis","TempPolygon","ReferenceFace","sideNormal1","sideNormal2","edgeAxis","polygonAxis","polygonBA","rf","polygonB","centroidB","v0","v3","normal0","normal2","front","offset1","offset0","offset2","convex1","convex2","edge0","edge2","lowerLimit","upperLimit","e_edgeA","e_edgeB","primaryAxis","internal","Input","Output","Proxy","Cache","playButton","status","info","Testbed","width","scaleY","background","activeKeys","keydown","keyCode","label","keyup","lastDrawHash","newDrawHash","buffer","start","stage","Stage","mount","canvas","dom","testbed","Mouse","START","window","focus","document","activeElement","blur","MAX_ELAPSE","paused","_resume","_pause","drawingTexture","Texture","append","sprite","tick","draw","save","transform","lineWidth","lineCap","drawing","worldNode","WorldNode","lastX","lastY","targetBody","drawSegment","mouseMove","touch","viewbox","pin","prepend","mouseGround","mouseJoint","attr","findBody","mouseForce","MOVE","END","CANCEL","addEventListener","charCodeAt","togglePause","downKeys","updateActiveKeys","down","char","String","fromCharCode","test","right","left","up","fire","isPaused","resume","pause","classList","remove","lastStatus","lastInfo","_status","statusText","statusMap","innerText","_info","text","drawPoint","color","beginPath","arc","strokeStyle","stroke","drawCircle","drawEdge","moveTo","lineTo","drawPolygon","closePath","drawAABB","g","findOne","findAll","statusSet","statusMerge","WeakMap","undefined","fillStyle","renderWorld","viewer","render","fill","drawChain","appendTo","__lastX","__lastY","__lastR","rotate","drawJoint","cx","cy","lw","texture","stretch","image","_b","_c","_d","elapsedTime","Node","tb","getElementById"],"mappings":"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"}